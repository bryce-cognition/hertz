
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>bytesconv: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/cloudwego/hertz/internal/bytesconv/bytesconv.go (93.0%)</option>
				
				<option value="file1">github.com/cloudwego/hertz/internal/stats/stats_util.go (100.0%)</option>
				
				<option value="file2">github.com/cloudwego/hertz/internal/stats/tracer.go (93.3%)</option>
				
				<option value="file3">github.com/cloudwego/hertz/pkg/app/client/client.go (81.3%)</option>
				
				<option value="file4">github.com/cloudwego/hertz/pkg/app/client/discovery/discovery.go (100.0%)</option>
				
				<option value="file5">github.com/cloudwego/hertz/pkg/app/client/loadbalance/lbcache.go (78.3%)</option>
				
				<option value="file6">github.com/cloudwego/hertz/pkg/app/client/loadbalance/loadbalance.go (100.0%)</option>
				
				<option value="file7">github.com/cloudwego/hertz/pkg/app/client/loadbalance/weight_random.go (90.3%)</option>
				
				<option value="file8">github.com/cloudwego/hertz/pkg/app/client/middleware.go (100.0%)</option>
				
				<option value="file9">github.com/cloudwego/hertz/pkg/app/client/option.go (96.0%)</option>
				
				<option value="file10">github.com/cloudwego/hertz/pkg/app/client/retry/option.go (100.0%)</option>
				
				<option value="file11">github.com/cloudwego/hertz/pkg/app/client/retry/retry.go (100.0%)</option>
				
				<option value="file12">github.com/cloudwego/hertz/pkg/app/context.go (94.3%)</option>
				
				<option value="file13">github.com/cloudwego/hertz/pkg/app/fs.go (68.0%)</option>
				
				<option value="file14">github.com/cloudwego/hertz/pkg/app/middlewares/client/sd/discovery.go (91.7%)</option>
				
				<option value="file15">github.com/cloudwego/hertz/pkg/app/middlewares/client/sd/options.go (86.4%)</option>
				
				<option value="file16">github.com/cloudwego/hertz/pkg/app/middlewares/server/basic_auth/basic_auth.go (100.0%)</option>
				
				<option value="file17">github.com/cloudwego/hertz/pkg/app/middlewares/server/recovery/option.go (100.0%)</option>
				
				<option value="file18">github.com/cloudwego/hertz/pkg/app/middlewares/server/recovery/recovery.go (91.9%)</option>
				
				<option value="file19">github.com/cloudwego/hertz/pkg/app/server/binding/config.go (79.2%)</option>
				
				<option value="file20">github.com/cloudwego/hertz/pkg/app/server/binding/default.go (83.6%)</option>
				
				<option value="file21">github.com/cloudwego/hertz/pkg/app/server/binding/reflect.go (100.0%)</option>
				
				<option value="file22">github.com/cloudwego/hertz/pkg/app/server/hertz.go (86.4%)</option>
				
				<option value="file23">github.com/cloudwego/hertz/pkg/app/server/option.go (98.9%)</option>
				
				<option value="file24">github.com/cloudwego/hertz/pkg/app/server/registry/registry.go (100.0%)</option>
				
				<option value="file25">github.com/cloudwego/hertz/pkg/app/server/render/data.go (100.0%)</option>
				
				<option value="file26">github.com/cloudwego/hertz/pkg/app/server/render/html.go (83.0%)</option>
				
				<option value="file27">github.com/cloudwego/hertz/pkg/app/server/render/json.go (96.8%)</option>
				
				<option value="file28">github.com/cloudwego/hertz/pkg/app/server/render/protobuf.go (100.0%)</option>
				
				<option value="file29">github.com/cloudwego/hertz/pkg/app/server/render/render.go (100.0%)</option>
				
				<option value="file30">github.com/cloudwego/hertz/pkg/app/server/render/text.go (100.0%)</option>
				
				<option value="file31">github.com/cloudwego/hertz/pkg/app/server/render/xml.go (100.0%)</option>
				
				<option value="file32">github.com/cloudwego/hertz/pkg/common/adaptor/request.go (88.9%)</option>
				
				<option value="file33">github.com/cloudwego/hertz/pkg/common/adaptor/response.go (93.5%)</option>
				
				<option value="file34">github.com/cloudwego/hertz/pkg/common/bytebufferpool/bytebuffer.go (75.0%)</option>
				
				<option value="file35">github.com/cloudwego/hertz/pkg/common/bytebufferpool/pool.go (97.9%)</option>
				
				<option value="file36">github.com/cloudwego/hertz/pkg/common/compress/compress.go (88.0%)</option>
				
				<option value="file37">github.com/cloudwego/hertz/pkg/common/config/client_option.go (100.0%)</option>
				
				<option value="file38">github.com/cloudwego/hertz/pkg/common/config/option.go (100.0%)</option>
				
				<option value="file39">github.com/cloudwego/hertz/pkg/common/config/request_option.go (85.4%)</option>
				
				<option value="file40">github.com/cloudwego/hertz/pkg/common/errors/errors.go (91.2%)</option>
				
				<option value="file41">github.com/cloudwego/hertz/pkg/common/hlog/default.go (85.5%)</option>
				
				<option value="file42">github.com/cloudwego/hertz/pkg/common/hlog/hlog.go (77.8%)</option>
				
				<option value="file43">github.com/cloudwego/hertz/pkg/common/hlog/log.go (100.0%)</option>
				
				<option value="file44">github.com/cloudwego/hertz/pkg/common/hlog/system.go (83.3%)</option>
				
				<option value="file45">github.com/cloudwego/hertz/pkg/common/stackless/func.go (88.9%)</option>
				
				<option value="file46">github.com/cloudwego/hertz/pkg/common/stackless/writer.go (91.7%)</option>
				
				<option value="file47">github.com/cloudwego/hertz/pkg/common/test/mock/body_data.go (95.7%)</option>
				
				<option value="file48">github.com/cloudwego/hertz/pkg/common/test/mock/network.go (94.0%)</option>
				
				<option value="file49">github.com/cloudwego/hertz/pkg/common/test/mock/reader.go (94.7%)</option>
				
				<option value="file50">github.com/cloudwego/hertz/pkg/common/test/mock/writer.go (100.0%)</option>
				
				<option value="file51">github.com/cloudwego/hertz/pkg/common/timer/timer.go (93.3%)</option>
				
				<option value="file52">github.com/cloudwego/hertz/pkg/common/tracer/stats/event.go (94.1%)</option>
				
				<option value="file53">github.com/cloudwego/hertz/pkg/common/ut/context.go (95.0%)</option>
				
				<option value="file54">github.com/cloudwego/hertz/pkg/common/ut/request.go (100.0%)</option>
				
				<option value="file55">github.com/cloudwego/hertz/pkg/common/ut/response.go (100.0%)</option>
				
				<option value="file56">github.com/cloudwego/hertz/pkg/common/utils/bufpool.go (100.0%)</option>
				
				<option value="file57">github.com/cloudwego/hertz/pkg/common/utils/chunk.go (96.3%)</option>
				
				<option value="file58">github.com/cloudwego/hertz/pkg/common/utils/env.go (0.0%)</option>
				
				<option value="file59">github.com/cloudwego/hertz/pkg/common/utils/ioutil.go (84.6%)</option>
				
				<option value="file60">github.com/cloudwego/hertz/pkg/common/utils/netaddr.go (100.0%)</option>
				
				<option value="file61">github.com/cloudwego/hertz/pkg/common/utils/network.go (82.4%)</option>
				
				<option value="file62">github.com/cloudwego/hertz/pkg/common/utils/path.go (96.6%)</option>
				
				<option value="file63">github.com/cloudwego/hertz/pkg/common/utils/utils.go (100.0%)</option>
				
				<option value="file64">github.com/cloudwego/hertz/pkg/network/dialer/default.go (100.0%)</option>
				
				<option value="file65">github.com/cloudwego/hertz/pkg/network/dialer/dialer.go (100.0%)</option>
				
				<option value="file66">github.com/cloudwego/hertz/pkg/network/netpoll/connection.go (69.7%)</option>
				
				<option value="file67">github.com/cloudwego/hertz/pkg/network/netpoll/dial.go (100.0%)</option>
				
				<option value="file68">github.com/cloudwego/hertz/pkg/network/netpoll/transport.go (94.2%)</option>
				
				<option value="file69">github.com/cloudwego/hertz/pkg/network/standard/buffer.go (96.4%)</option>
				
				<option value="file70">github.com/cloudwego/hertz/pkg/network/standard/connection.go (86.0%)</option>
				
				<option value="file71">github.com/cloudwego/hertz/pkg/network/standard/dial.go (93.8%)</option>
				
				<option value="file72">github.com/cloudwego/hertz/pkg/network/standard/transport.go (86.8%)</option>
				
				<option value="file73">github.com/cloudwego/hertz/pkg/network/utils.go (66.7%)</option>
				
				<option value="file74">github.com/cloudwego/hertz/pkg/network/writer.go (97.4%)</option>
				
				<option value="file75">github.com/cloudwego/hertz/pkg/protocol/args.go (87.4%)</option>
				
				<option value="file76">github.com/cloudwego/hertz/pkg/protocol/cookie.go (93.4%)</option>
				
				<option value="file77">github.com/cloudwego/hertz/pkg/protocol/header.go (85.9%)</option>
				
				<option value="file78">github.com/cloudwego/hertz/pkg/protocol/http1/client.go (81.8%)</option>
				
				<option value="file79">github.com/cloudwego/hertz/pkg/protocol/http1/ext/common.go (79.9%)</option>
				
				<option value="file80">github.com/cloudwego/hertz/pkg/protocol/http1/ext/error.go (37.5%)</option>
				
				<option value="file81">github.com/cloudwego/hertz/pkg/protocol/http1/ext/headerscanner.go (80.6%)</option>
				
				<option value="file82">github.com/cloudwego/hertz/pkg/protocol/http1/ext/stream.go (83.0%)</option>
				
				<option value="file83">github.com/cloudwego/hertz/pkg/protocol/http1/req/header.go (88.4%)</option>
				
				<option value="file84">github.com/cloudwego/hertz/pkg/protocol/http1/req/request.go (83.9%)</option>
				
				<option value="file85">github.com/cloudwego/hertz/pkg/protocol/http1/resp/header.go (86.3%)</option>
				
				<option value="file86">github.com/cloudwego/hertz/pkg/protocol/http1/resp/response.go (77.7%)</option>
				
				<option value="file87">github.com/cloudwego/hertz/pkg/protocol/http1/resp/writer.go (87.9%)</option>
				
				<option value="file88">github.com/cloudwego/hertz/pkg/protocol/http1/server.go (84.0%)</option>
				
				<option value="file89">github.com/cloudwego/hertz/pkg/protocol/multipart.go (87.0%)</option>
				
				<option value="file90">github.com/cloudwego/hertz/pkg/protocol/request.go (84.6%)</option>
				
				<option value="file91">github.com/cloudwego/hertz/pkg/protocol/response.go (88.5%)</option>
				
				<option value="file92">github.com/cloudwego/hertz/pkg/protocol/trailer.go (94.7%)</option>
				
				<option value="file93">github.com/cloudwego/hertz/pkg/protocol/uri.go (94.0%)</option>
				
				<option value="file94">github.com/cloudwego/hertz/pkg/protocol/uri_unix.go (100.0%)</option>
				
				<option value="file95">github.com/cloudwego/hertz/pkg/route/default.go (100.0%)</option>
				
				<option value="file96">github.com/cloudwego/hertz/pkg/route/engine.go (76.4%)</option>
				
				<option value="file97">github.com/cloudwego/hertz/pkg/route/routergroup.go (79.5%)</option>
				
				<option value="file98">github.com/cloudwego/hertz/pkg/route/tree.go (98.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015-present Aliaksandr Valialkin, VertaMedia, Kirill Danshin, Erik Dubbelboer, FastHTTP Authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This file may have been modified by CloudWeGo authors. All CloudWeGo
 * Modifications are Copyright 2022 CloudWeGo Authors.
 */

package bytesconv

import (
        "net/http"
        "reflect"
        "sync"
        "time"
        "unsafe"

        "github.com/cloudwego/hertz/pkg/network"
)

const (
        upperhex = "0123456789ABCDEF"
        lowerhex = "0123456789abcdef"
)

var hexIntBufPool sync.Pool

func LowercaseBytes(b []byte) <span class="cov8" title="1">{
        for i := 0; i &lt; len(b); i++ </span><span class="cov8" title="1">{
                p := &amp;b[i]
                *p = ToLowerTable[*p]
        }</span>
}

// B2s converts byte slice to a string without memory allocation.
// See https://groups.google.com/forum/#!msg/Golang-Nuts/ENgbUzYvCuU/90yGx7GUAgAJ .
//
// Note it may break if string and/or slice header will change
// in the future go versions.
func B2s(b []byte) string <span class="cov8" title="1">{
        /* #nosec G103 */
        return *(*string)(unsafe.Pointer(&amp;b))
}</span>

// S2b converts string to a byte slice without memory allocation.
//
// Note it may break if string and/or slice header will change
// in the future go versions.
func S2b(s string) (b []byte) <span class="cov8" title="1">{
        /* #nosec G103 */
        bh := (*reflect.SliceHeader)(unsafe.Pointer(&amp;b))
        /* #nosec G103 */
        sh := (*reflect.StringHeader)(unsafe.Pointer(&amp;s))
        bh.Data = sh.Data
        bh.Len = sh.Len
        bh.Cap = sh.Len
        return b
}</span>

func WriteHexInt(w network.Writer, n int) error <span class="cov8" title="1">{
        if n &lt; 0 </span><span class="cov0" title="0">{
                panic("BUG: int must be positive")</span>
        }

        <span class="cov8" title="1">v := hexIntBufPool.Get()
        if v == nil </span><span class="cov8" title="1">{
                v = make([]byte, maxHexIntChars+1)
        }</span>
        <span class="cov8" title="1">buf := v.([]byte)
        i := len(buf) - 1
        for </span><span class="cov8" title="1">{
                buf[i] = lowerhex[n&amp;0xf]
                n &gt;&gt;= 4
                if n == 0 </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">i--</span>
        }
        <span class="cov8" title="1">safeBuf, err := w.Malloc(maxHexIntChars + 1 - i)
        copy(safeBuf, buf[i:])
        hexIntBufPool.Put(v)
        return err</span>
}

func ReadHexInt(r network.Reader) (int, error) <span class="cov8" title="1">{
        n := 0
        i := 0
        var k int
        for </span><span class="cov8" title="1">{
                buf, err := r.Peek(1)
                if err != nil </span><span class="cov8" title="1">{
                        r.Skip(1)

                        if i &gt; 0 </span><span class="cov8" title="1">{
                                return n, nil
                        }</span>
                        <span class="cov0" title="0">return -1, err</span>
                }

                <span class="cov8" title="1">c := buf[0]
                k = int(Hex2intTable[c])
                if k == 16 </span><span class="cov8" title="1">{
                        if i == 0 </span><span class="cov0" title="0">{
                                r.Skip(1)
                                return -1, errEmptyHexNum
                        }</span>
                        <span class="cov8" title="1">return n, nil</span>
                }
                <span class="cov8" title="1">if i &gt;= maxHexIntChars </span><span class="cov0" title="0">{
                        r.Skip(1)
                        return -1, errTooLargeHexNum
                }</span>

                <span class="cov8" title="1">r.Skip(1)
                n = (n &lt;&lt; 4) | k
                i++</span>
        }
}

func ParseUintBuf(b []byte) (int, int, error) <span class="cov8" title="1">{
        n := len(b)
        if n == 0 </span><span class="cov8" title="1">{
                return -1, 0, errEmptyInt
        }</span>
        <span class="cov8" title="1">v := 0
        for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                c := b[i]
                k := c - '0'
                if k &gt; 9 </span><span class="cov8" title="1">{
                        if i == 0 </span><span class="cov8" title="1">{
                                return -1, i, errUnexpectedFirstChar
                        }</span>
                        <span class="cov8" title="1">return v, i, nil</span>
                }
                <span class="cov8" title="1">vNew := 10*v + int(k)
                // Test for overflow.
                if vNew &lt; v </span><span class="cov8" title="1">{
                        return -1, i, errTooLongInt
                }</span>
                <span class="cov8" title="1">v = vNew</span>
        }
        <span class="cov8" title="1">return v, n, nil</span>
}

// AppendUint appends n to dst and returns the extended dst.
func AppendUint(dst []byte, n int) []byte <span class="cov8" title="1">{
        if n &lt; 0 </span><span class="cov0" title="0">{
                panic("BUG: int must be positive")</span>
        }

        <span class="cov8" title="1">var b [20]byte
        buf := b[:]
        i := len(buf)
        var q int
        for n &gt;= 10 </span><span class="cov8" title="1">{
                i--
                q = n / 10
                buf[i] = '0' + byte(n-q*10)
                n = q
        }</span>
        <span class="cov8" title="1">i--
        buf[i] = '0' + byte(n)

        dst = append(dst, buf[i:]...)
        return dst</span>
}

// AppendHTTPDate appends HTTP-compliant representation of date
// to dst and returns the extended dst.
func AppendHTTPDate(dst []byte, date time.Time) []byte <span class="cov8" title="1">{
        return date.UTC().AppendFormat(dst, http.TimeFormat)
}</span>

func AppendQuotedPath(dst, src []byte) []byte <span class="cov8" title="1">{
        // Fix issue in https://github.com/golang/go/issues/11202
        if len(src) == 1 &amp;&amp; src[0] == '*' </span><span class="cov8" title="1">{
                return append(dst, '*')
        }</span>

        <span class="cov8" title="1">for _, c := range src </span><span class="cov8" title="1">{
                if QuotedPathShouldEscapeTable[int(c)] != 0 </span><span class="cov8" title="1">{
                        dst = append(dst, '%', upperhex[c&gt;&gt;4], upperhex[c&amp;15])
                }</span> else<span class="cov8" title="1"> {
                        dst = append(dst, c)
                }</span>
        }
        <span class="cov8" title="1">return dst</span>
}

// AppendQuotedArg appends url-encoded src to dst and returns appended dst.
func AppendQuotedArg(dst, src []byte) []byte <span class="cov8" title="1">{
        for _, c := range src </span><span class="cov8" title="1">{
                switch </span>{
                case c == ' ':<span class="cov8" title="1">
                        dst = append(dst, '+')</span>
                case QuotedArgShouldEscapeTable[int(c)] != 0:<span class="cov8" title="1">
                        dst = append(dst, '%', upperhex[c&gt;&gt;4], upperhex[c&amp;0xf])</span>
                default:<span class="cov8" title="1">
                        dst = append(dst, c)</span>
                }
        }
        <span class="cov8" title="1">return dst</span>
}

// ParseHTTPDate parses HTTP-compliant (RFC1123) date.
func ParseHTTPDate(date []byte) (time.Time, error) <span class="cov8" title="1">{
        return time.Parse(time.RFC1123, B2s(date))
}</span>

// ParseUint parses uint from buf.
func ParseUint(buf []byte) (int, error) <span class="cov8" title="1">{
        v, n, err := ParseUintBuf(buf)
        if n != len(buf) </span><span class="cov8" title="1">{
                return -1, errUnexpectedTrailingChar
        }</span>
        <span class="cov8" title="1">return v, err</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package stats

import (
        "github.com/cloudwego/hertz/pkg/common/tracer/stats"
        "github.com/cloudwego/hertz/pkg/common/tracer/traceinfo"
)

// Record records the event to HTTPStats.
func Record(ti traceinfo.TraceInfo, event stats.Event, err error) <span class="cov8" title="1">{
        if ti == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                ti.Stats().Record(event, stats.StatusError, err.Error())
        }</span> else<span class="cov8" title="1"> {
                ti.Stats().Record(event, stats.StatusInfo, "")
        }</span>
}

// CalcEventCostUs calculates the duration between start and end and returns in microsecond.
func CalcEventCostUs(start, end traceinfo.Event) uint64 <span class="cov8" title="1">{
        if start == nil || end == nil || start.IsNil() || end.IsNil() </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return uint64(end.Time().Sub(start.Time()).Microseconds())</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package stats

import (
        "context"
        "runtime/debug"

        "github.com/cloudwego/hertz/pkg/app"
        "github.com/cloudwego/hertz/pkg/common/hlog"
        "github.com/cloudwego/hertz/pkg/common/tracer"
        "github.com/cloudwego/hertz/pkg/common/tracer/stats"
)

// Controller controls tracers.
type Controller struct {
        tracers []tracer.Tracer
}

// Append appends a new tracer to the controller.
func (ctl *Controller) Append(col tracer.Tracer) <span class="cov8" title="1">{
        ctl.tracers = append(ctl.tracers, col)
}</span>

// DoStart starts the tracers.
func (ctl *Controller) DoStart(ctx context.Context, c *app.RequestContext) context.Context <span class="cov8" title="1">{
        defer ctl.tryRecover()
        Record(c.GetTraceInfo(), stats.HTTPStart, nil)

        for _, col := range ctl.tracers </span><span class="cov8" title="1">{
                ctx = col.Start(ctx, c)
        }</span>
        <span class="cov8" title="1">return ctx</span>
}

// DoFinish calls the tracers in reversed order.
func (ctl *Controller) DoFinish(ctx context.Context, c *app.RequestContext, err error) <span class="cov8" title="1">{
        defer ctl.tryRecover()
        Record(c.GetTraceInfo(), stats.HTTPFinish, err)
        if err != nil </span><span class="cov8" title="1">{
                c.GetTraceInfo().Stats().SetError(err)
        }</span>

        // reverse the order
        <span class="cov8" title="1">for i := len(ctl.tracers) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                ctl.tracers[i].Finish(ctx, c)
        }</span>
}

func (ctl *Controller) HasTracer() bool <span class="cov0" title="0">{
        return ctl != nil &amp;&amp; len(ctl.tracers) &gt; 0
}</span>

func (ctl *Controller) tryRecover() <span class="cov8" title="1">{
        if err := recover(); err != nil </span><span class="cov8" title="1">{
                hlog.SystemLogger().Warnf("Panic happened during tracer call. This doesn't affect the http call, but may lead to lack of monitor data such as metrics and logs: %s, %s", err, string(debug.Stack()))
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015-present Aliaksandr Valialkin, VertaMedia, Kirill Danshin, Erik Dubbelboer, FastHTTP Authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This file may have been modified by CloudWeGo authors. All CloudWeGo
 * Modifications are Copyright 2022 CloudWeGo Authors.
 */

package client

import (
        "bytes"
        "context"
        "fmt"
        "io"
        "reflect"
        "strings"
        "sync"
        "time"

        "github.com/cloudwego/hertz/internal/bytestr"
        "github.com/cloudwego/hertz/internal/nocopy"
        "github.com/cloudwego/hertz/pkg/common/config"
        "github.com/cloudwego/hertz/pkg/common/errors"
        "github.com/cloudwego/hertz/pkg/common/hlog"
        "github.com/cloudwego/hertz/pkg/common/utils"
        "github.com/cloudwego/hertz/pkg/network/dialer"
        "github.com/cloudwego/hertz/pkg/protocol"
        "github.com/cloudwego/hertz/pkg/protocol/client"
        "github.com/cloudwego/hertz/pkg/protocol/consts"
        "github.com/cloudwego/hertz/pkg/protocol/http1"
        "github.com/cloudwego/hertz/pkg/protocol/http1/factory"
        "github.com/cloudwego/hertz/pkg/protocol/suite"
)

var (
        errorInvalidURI          = errors.NewPublic("invalid uri")
        errorLastMiddlewareExist = errors.NewPublic("last middleware already set")
)

// Do performs the given http request and fills the given http response.
//
// Request must contain at least non-zero RequestURI with full url (including
// scheme and host) or non-zero Host header + RequestURI.Â©
//
// Client determines the server to be requested in the following order:
//
//   - from RequestURI if it contains full url with scheme and host;
//   - from Host header otherwise.
//
// The function doesn't follow redirects. Use Get* for following redirects.
//
// Response is ignored if resp is nil.
//
// ErrNoFreeConns is returned if all DefaultMaxConnsPerHost connections
// to the requested host are busy.
//
// It is recommended obtaining req and resp via AcquireRequest
// and AcquireResponse in performance-critical code.
func Do(ctx context.Context, req *protocol.Request, resp *protocol.Response) error <span class="cov0" title="0">{
        return defaultClient.Do(ctx, req, resp)
}</span>

// DoTimeout performs the given request and waits for response during
// the given timeout duration.
//
// Request must contain at least non-zero RequestURI with full url (including
// scheme and host) or non-zero Host header + RequestURI.
//
// Client determines the server to be requested in the following order:
//
//   - from RequestURI if it contains full url with scheme and host;
//   - from Host header otherwise.
//
// The function doesn't follow redirects. Use Get* for following redirects.
//
// Response is ignored if resp is nil.
//
// errTimeout is returned if the response wasn't returned during
// the given timeout.
//
// ErrNoFreeConns is returned if all DefaultMaxConnsPerHost connections
// to the requested host are busy.
//
// It is recommended obtaining req and resp via AcquireRequest
// and AcquireResponse in performance-critical code.
//
// Warning: DoTimeout does not terminate the request itself. The request will
// continue in the background and the response will be discarded.
// If requests take too long and the connection pool gets filled up please
// try using a customized Client instance with a ReadTimeout config or set the request level read timeout like:
// `req.SetOptions(config.WithReadTimeout(1 * time.Second))`
func DoTimeout(ctx context.Context, req *protocol.Request, resp *protocol.Response, timeout time.Duration) error <span class="cov0" title="0">{
        return defaultClient.DoTimeout(ctx, req, resp, timeout)
}</span>

// DoDeadline performs the given request and waits for response until
// the given deadline.
//
// Request must contain at least non-zero RequestURI with full url (including
// scheme and host) or non-zero Host header + RequestURI.
//
// Client determines the server to be requested in the following order:
//
//   - from RequestURI if it contains full url with scheme and host;
//   - from Host header otherwise.
//
// The function doesn't follow redirects. Use Get* for following redirects.
//
// Response is ignored if resp is nil.
//
// errTimeout is returned if the response wasn't returned until
// the given deadline.
//
// ErrNoFreeConns is returned if all DefaultMaxConnsPerHost connections
// to the requested host are busy.
//
// It is recommended obtaining req and resp via AcquireRequest
// and AcquireResponse in performance-critical code.
//
// Warning: DoDeadline does not terminate the request itself. The request will
// continue in the background and the response will be discarded.
// If requests take too long and the connection pool gets filled up please
// try using a customized Client instance with a ReadTimeout config or set the request level read timeout like:
// `req.SetOptions(config.WithReadTimeout(1 * time.Second))`
func DoDeadline(ctx context.Context, req *protocol.Request, resp *protocol.Response, deadline time.Time) error <span class="cov0" title="0">{
        return defaultClient.DoDeadline(ctx, req, resp, deadline)
}</span>

// DoRedirects performs the given http request and fills the given http response,
// following up to maxRedirectsCount redirects. When the redirect count exceeds
// maxRedirectsCount, ErrTooManyRedirects is returned.
//
// Request must contain at least non-zero RequestURI with full url (including
// scheme and host) or non-zero Host header + RequestURI.
//
// Client determines the server to be requested in the following order:
//
//   - from RequestURI if it contains full url with scheme and host;
//   - from Host header otherwise.
//
// Response is ignored if resp is nil.
//
// ErrNoFreeConns is returned if all DefaultMaxConnsPerHost connections
// to the requested host are busy.
//
// It is recommended obtaining req and resp via AcquireRequest
// and AcquireResponse in performance-critical code.
func DoRedirects(ctx context.Context, req *protocol.Request, resp *protocol.Response, maxRedirectsCount int) error <span class="cov0" title="0">{
        _, _, err := client.DoRequestFollowRedirects(ctx, req, resp, req.URI().String(), maxRedirectsCount, defaultClient)
        return err
}</span>

// Get returns the status code and body of url.
//
// The contents of dst will be replaced by the body and returned, if the dst
// is too small a new slice will be allocated.
//
// The function follows redirects. Use Do* for manually handling redirects.
func Get(ctx context.Context, dst []byte, url string, requestOptions ...config.RequestOption) (statusCode int, body []byte, err error) <span class="cov0" title="0">{
        return defaultClient.Get(ctx, dst, url, requestOptions...)
}</span>

// GetTimeout returns the status code and body of url.
//
// The contents of dst will be replaced by the body and returned, if the dst
// is too small a new slice will be allocated.
//
// The function follows redirects. Use Do* for manually handling redirects.
//
// errTimeout error is returned if url contents couldn't be fetched
// during the given timeout.
//
// Warning: GetTimeout does not terminate the request itself. The request will
// continue in the background and the response will be discarded.
// If requests take too long and the connection pool gets filled up please
// try using a customized Client instance with a ReadTimeout config or set the request level read timeout like:
// `GetTimeout(ctx, dst, url, timeout, config.WithReadTimeout(1 * time.Second))`
func GetTimeout(ctx context.Context, dst []byte, url string, timeout time.Duration, requestOptions ...config.RequestOption) (statusCode int, body []byte, err error) <span class="cov0" title="0">{
        return defaultClient.GetTimeout(ctx, dst, url, timeout, requestOptions...)
}</span>

// GetDeadline returns the status code and body of url.
//
// The contents of dst will be replaced by the body and returned, if the dst
// is too small a new slice will be allocated.
//
// The function follows redirects. Use Do* for manually handling redirects.
//
// errTimeout error is returned if url contents couldn't be fetched
// until the given deadline.
//
// Warning: GetDeadline does not terminate the request itself. The request will
// continue in the background and the response will be discarded.
// If requests take too long and the connection pool gets filled up please
// try using a customized Client instance with a ReadTimeout config or set the request level read timeout like:
// `GetDeadline(ctx, dst, url, timeout, config.WithReadTimeout(1 * time.Second))`
func GetDeadline(ctx context.Context, dst []byte, url string, deadline time.Time, requestOptions ...config.RequestOption) (statusCode int, body []byte, err error) <span class="cov0" title="0">{
        return defaultClient.GetDeadline(ctx, dst, url, deadline, requestOptions...)
}</span>

// Post sends POST request to the given url with the given POST arguments.
//
// The contents of dst will be replaced by the body and returned, if the dst
// is too small a new slice will be allocated.
//
// The function follows redirects. Use Do* for manually handling redirects.
//
// Empty POST body is sent if postArgs is nil.
func Post(ctx context.Context, dst []byte, url string, postArgs *protocol.Args, requestOptions ...config.RequestOption) (statusCode int, body []byte, err error) <span class="cov0" title="0">{
        return defaultClient.Post(ctx, dst, url, postArgs, requestOptions...)
}</span>

var defaultClient, _ = NewClient(WithDialTimeout(consts.DefaultDialTimeout))

// Client implements http client.
//
// Copying Client by value is prohibited. Create new instance instead.
//
// It is safe calling Client methods from concurrently running goroutines.
type Client struct {
        noCopy nocopy.NoCopy //lint:ignore U1000 until noCopy is used

        options *config.ClientOptions

        // Proxy specifies a function to return a proxy for a given
        // Request. If the function returns a non-nil error, the
        // request is aborted with the provided error.
        //
        // The proxy type is determined by the URL scheme.
        // "http" and "https" are supported. If the scheme is empty,
        // "http" is assumed.
        //
        // If Proxy is nil or returns a nil *URL, no proxy is used.
        Proxy protocol.Proxy

        // RetryIfFunc sets the retry decision function. If nil, the client.DefaultRetryIf will be applied.
        RetryIfFunc client.RetryIfFunc

        clientFactory suite.ClientFactory

        mLock          sync.Mutex
        m              map[string]client.HostClient
        ms             map[string]client.HostClient
        mws            Middleware
        lastMiddleware Middleware
}

func (c *Client) GetOptions() *config.ClientOptions <span class="cov8" title="1">{
        return c.options
}</span>

func (c *Client) SetRetryIfFunc(retryIf client.RetryIfFunc) <span class="cov8" title="1">{
        c.RetryIfFunc = retryIf
}</span>

// Deprecated: use SetRetryIfFunc instead of SetRetryIf
func (c *Client) SetRetryIf(fn func(request *protocol.Request) bool) <span class="cov0" title="0">{
        f := func(req *protocol.Request, resp *protocol.Response, err error) bool </span><span class="cov0" title="0">{
                return fn(req)
        }</span>
        <span class="cov0" title="0">c.SetRetryIfFunc(f)</span>
}

// SetProxy is used to set client proxy.
//
// Don't SetProxy twice for a client.
// If you want to use another proxy, please create another client and set proxy to it.
func (c *Client) SetProxy(p protocol.Proxy) <span class="cov8" title="1">{
        c.Proxy = p
}</span>

// Get returns the status code and body of url.
//
// The contents of dst will be replaced by the body and returned, if the dst
// is too small a new slice will be allocated.
//
// The function follows redirects. Use Do* for manually handling redirects.
func (c *Client) Get(ctx context.Context, dst []byte, url string, requestOptions ...config.RequestOption) (statusCode int, body []byte, err error) <span class="cov8" title="1">{
        return client.GetURL(ctx, dst, url, c, requestOptions...)
}</span>

// GetTimeout returns the status code and body of url.
//
// The contents of dst will be replaced by the body and returned, if the dst
// is too small a new slice will be allocated.
//
// The function follows redirects. Use Do* for manually handling redirects.
//
// errTimeout error is returned if url contents couldn't be fetched
// during the given timeout.
func (c *Client) GetTimeout(ctx context.Context, dst []byte, url string, timeout time.Duration, requestOptions ...config.RequestOption) (statusCode int, body []byte, err error) <span class="cov0" title="0">{
        return client.GetURLTimeout(ctx, dst, url, timeout, c, requestOptions...)
}</span>

// GetDeadline returns the status code and body of url.
//
// The contents of dst will be replaced by the body and returned, if the dst
// is too small a new slice will be allocated.
//
// The function follows redirects. Use Do* for manually handling redirects.
//
// errTimeout error is returned if url contents couldn't be fetched
// until the given deadline.
func (c *Client) GetDeadline(ctx context.Context, dst []byte, url string, deadline time.Time, requestOptions ...config.RequestOption) (statusCode int, body []byte, err error) <span class="cov0" title="0">{
        return client.GetURLDeadline(ctx, dst, url, deadline, c, requestOptions...)
}</span>

// Post sends POST request to the given url with the given POST arguments.
//
// The contents of dst will be replaced by the body and returned, if the dst
// is too small a new slice will be allocated.
//
// The function follows redirects. Use Do* for manually handling redirects.
//
// Empty POST body is sent if postArgs is nil.
func (c *Client) Post(ctx context.Context, dst []byte, url string, postArgs *protocol.Args, requestOptions ...config.RequestOption) (statusCode int, body []byte, err error) <span class="cov8" title="1">{
        return client.PostURL(ctx, dst, url, postArgs, c, requestOptions...)
}</span>

// DoTimeout performs the given request and waits for response during
// the given timeout duration.
//
// Request must contain at least non-zero RequestURI with full url (including
// scheme and host) or non-zero Host header + RequestURI.
//
// Client determines the server to be requested in the following order:
//
//   - from RequestURI if it contains full url with scheme and host;
//   - from Host header otherwise.
//
// The function doesn't follow redirects. Use Get* for following redirects.
//
// Response is ignored if resp is nil.
//
// errTimeout is returned if the response wasn't returned during
// the given timeout.
//
// ErrNoFreeConns is returned if all Client.MaxConnsPerHost connections
// to the requested host are busy.
//
// It is recommended obtaining req and resp via AcquireRequest
// and AcquireResponse in performance-critical code.
//
// Warning: DoTimeout does not terminate the request itself. The request will
// continue in the background and the response will be discarded.
// If requests take too long and the connection pool gets filled up please
// try using a customized Client instance with a ReadTimeout config or set the request level read timeout like:
// `req.SetOptions(config.WithReadTimeout(1 * time.Second))`
func (c *Client) DoTimeout(ctx context.Context, req *protocol.Request, resp *protocol.Response, timeout time.Duration) error <span class="cov8" title="1">{
        return client.DoTimeout(ctx, req, resp, timeout, c)
}</span>

// DoDeadline performs the given request and waits for response until
// the given deadline.
//
// Request must contain at least non-zero RequestURI with full url (including
// scheme and host) or non-zero Host header + RequestURI.
//
// Client determines the server to be requested in the following order:
//
//   - from RequestURI if it contains full url with scheme and host;
//   - from Host header otherwise.
//
// The function doesn't follow redirects. Use Get* for following redirects.
//
// Response is ignored if resp is nil.
//
// errTimeout is returned if the response wasn't returned until
// the given deadline.
//
// ErrNoFreeConns is returned if all Client.MaxConnsPerHost connections
// to the requested host are busy.
//
// It is recommended obtaining req and resp via AcquireRequest
// and AcquireResponse in performance-critical code.
func (c *Client) DoDeadline(ctx context.Context, req *protocol.Request, resp *protocol.Response, deadline time.Time) error <span class="cov0" title="0">{
        return client.DoDeadline(ctx, req, resp, deadline, c)
}</span>

// DoRedirects performs the given http request and fills the given http response,
// following up to maxRedirectsCount redirects. When the redirect count exceeds
// maxRedirectsCount, ErrTooManyRedirects is returned.
//
// Request must contain at least non-zero RequestURI with full url (including
// scheme and host) or non-zero Host header + RequestURI.
//
// Client determines the server to be requested in the following order:
//
//   - from RequestURI if it contains full url with scheme and host;
//   - from Host header otherwise.
//
// Response is ignored if resp is nil.
//
// ErrNoFreeConns is returned if all DefaultMaxConnsPerHost connections
// to the requested host are busy.
//
// It is recommended obtaining req and resp via AcquireRequest
// and AcquireResponse in performance-critical code.
func (c *Client) DoRedirects(ctx context.Context, req *protocol.Request, resp *protocol.Response, maxRedirectsCount int) error <span class="cov0" title="0">{
        _, _, err := client.DoRequestFollowRedirects(ctx, req, resp, req.URI().String(), maxRedirectsCount, c)
        return err
}</span>

// Do performs the given http request and fills the given http response.
//
// Request must contain at least non-zero RequestURI with full url (including
// scheme and host) or non-zero Host header + RequestURI.
//
// Client determines the server to be requested in the following order:
//
//   - from RequestURI if it contains full url with scheme and host;
//   - from Host header otherwise.
//
// Response is ignored if resp is nil.
//
// The function doesn't follow redirects. Use Get* for following redirects.
//
// ErrNoFreeConns is returned if all Client.MaxConnsPerHost connections
// to the requested host are busy.
//
// It is recommended obtaining req and resp via AcquireRequest
// and AcquireResponse in performance-critical code.
func (c *Client) Do(ctx context.Context, req *protocol.Request, resp *protocol.Response) error <span class="cov8" title="1">{
        if c.mws == nil </span><span class="cov8" title="1">{
                return c.do(ctx, req, resp)
        }</span>
        <span class="cov8" title="1">if c.lastMiddleware != nil </span><span class="cov8" title="1">{
                return c.mws(c.lastMiddleware(c.do))(ctx, req, resp)
        }</span>
        <span class="cov8" title="1">return c.mws(c.do)(ctx, req, resp)</span>
}

func (c *Client) do(ctx context.Context, req *protocol.Request, resp *protocol.Response) error <span class="cov8" title="1">{
        if !c.options.KeepAlive </span><span class="cov8" title="1">{
                req.Header.SetConnectionClose(true)
        }</span>
        <span class="cov8" title="1">uri := req.URI()
        if uri == nil </span><span class="cov0" title="0">{
                return errorInvalidURI
        }</span>

        <span class="cov8" title="1">var proxyURI *protocol.URI
        var err error

        if c.Proxy != nil </span><span class="cov8" title="1">{
                proxyURI, err = c.Proxy(req)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("proxy error=%w", err)
                }</span>
        }

        <span class="cov8" title="1">isTLS := false
        scheme := uri.Scheme()
        if bytes.Equal(scheme, bytestr.StrHTTPS) </span><span class="cov8" title="1">{
                isTLS = true
        }</span> else<span class="cov8" title="1"> if !bytes.Equal(scheme, bytestr.StrHTTP) &amp;&amp; !bytes.Equal(scheme, bytestr.StrSD) </span><span class="cov0" title="0">{
                return fmt.Errorf("unsupported protocol %q. http and https are supported", scheme)
        }</span>
        <span class="cov8" title="1">host := uri.Host()
        startCleaner := false

        c.mLock.Lock()

        m := c.m
        if isTLS </span><span class="cov8" title="1">{
                m = c.ms
        }</span>

        <span class="cov8" title="1">h := string(host)
        hc := m[h]
        if hc == nil </span><span class="cov8" title="1">{
                if c.clientFactory == nil </span><span class="cov8" title="1">{
                        // load http1 client by default
                        c.clientFactory = factory.NewClientFactory(newHttp1OptionFromClient(c))
                }</span>
                <span class="cov8" title="1">hc, _ = c.clientFactory.NewHostClient()
                hc.SetDynamicConfig(&amp;client.DynamicConfig{
                        Addr:     utils.AddMissingPort(h, isTLS),
                        ProxyURI: proxyURI,
                        IsTLS:    isTLS,
                })

                // re-configure hook
                if c.options.HostClientConfigHook != nil </span><span class="cov8" title="1">{
                        err = c.options.HostClientConfigHook(hc)
                        if err != nil </span><span class="cov8" title="1">{
                                c.mLock.Unlock()
                                return err
                        }</span>
                }

                <span class="cov8" title="1">m[h] = hc
                if len(m) == 1 </span><span class="cov8" title="1">{
                        startCleaner = true
                }</span>
        }

        <span class="cov8" title="1">c.mLock.Unlock()

        if startCleaner </span><span class="cov8" title="1">{
                go c.mCleaner()
        }</span>

        <span class="cov8" title="1">return hc.Do(ctx, req, resp)</span>
}

// CloseIdleConnections closes any connections which were previously
// connected from previous requests but are now sitting idle in a
// "keep-alive" state. It does not interrupt any connections currently
// in use.
func (c *Client) CloseIdleConnections() <span class="cov8" title="1">{
        c.mLock.Lock()
        for _, v := range c.m </span><span class="cov8" title="1">{
                v.CloseIdleConnections()
        }</span>
        <span class="cov8" title="1">c.mLock.Unlock()</span>
}

func (c *Client) mCleaner() <span class="cov8" title="1">{
        mustStop := false

        for </span><span class="cov8" title="1">{
                time.Sleep(10 * time.Second)
                c.mLock.Lock()
                for k, v := range c.m </span><span class="cov8" title="1">{
                        shouldRemove := v.ShouldRemove()

                        if shouldRemove </span><span class="cov8" title="1">{
                                delete(c.m, k)
                                if f, ok := v.(io.Closer); ok </span><span class="cov8" title="1">{
                                        err := f.Close()
                                        if err != nil </span><span class="cov0" title="0">{
                                                hlog.Warnf("clean hostclient error, addr: %s, err: %s", k, err.Error())
                                        }</span>
                                }
                        }
                }
                <span class="cov8" title="1">if len(c.m) == 0 </span><span class="cov8" title="1">{
                        mustStop = true
                }</span>
                <span class="cov8" title="1">c.mLock.Unlock()

                if mustStop </span><span class="cov8" title="1">{
                        break</span>
                }
        }
}

func (c *Client) SetClientFactory(cf suite.ClientFactory) <span class="cov0" title="0">{
        c.clientFactory = cf
}</span>

// GetDialerName returns the name of the dialer
func (c *Client) GetDialerName() (dName string, err error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                err := recover()
                if err != nil </span><span class="cov0" title="0">{
                        dName = "unknown"
                }</span>
        }()

        <span class="cov8" title="1">opt := c.GetOptions()
        if opt == nil || opt.Dialer == nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("abnormal process: there is no client options or dialer")
        }</span>

        <span class="cov8" title="1">dName = reflect.TypeOf(opt.Dialer).String()
        dSlice := strings.Split(dName, ".")
        dName = dSlice[0]
        if dName[0] == '*' </span><span class="cov8" title="1">{
                dName = dName[1:]
        }</span>

        <span class="cov8" title="1">return</span>
}

// NewClient return a client with options
func NewClient(opts ...config.ClientOption) (*Client, error) <span class="cov8" title="1">{
        opt := config.NewClientOptions(opts)
        if opt.Dialer == nil </span><span class="cov8" title="1">{
                opt.Dialer = dialer.DefaultDialer()
        }</span>
        <span class="cov8" title="1">c := &amp;Client{
                options: opt,
                m:       make(map[string]client.HostClient),
                ms:      make(map[string]client.HostClient),
        }

        return c, nil</span>
}

func (c *Client) Use(mws ...Middleware) <span class="cov8" title="1">{
        // Put the original middlewares to the first
        middlewares := make([]Middleware, 0, 1+len(mws))
        if c.mws != nil </span><span class="cov8" title="1">{
                middlewares = append(middlewares, c.mws)
        }</span>
        <span class="cov8" title="1">middlewares = append(middlewares, mws...)
        c.mws = chain(middlewares...)</span>
}

// UseAsLast is used to add middleware to the end of the middleware chain.
//
// Will return an error if last middleware has been set before, to ensure all middleware has the change to work,
// Please use `TakeOutLastMiddleware` to take out the already set middleware.
// Chain the middleware after or before is both Okay - but remember to put it back.
func (c *Client) UseAsLast(mw Middleware) error <span class="cov8" title="1">{
        if c.lastMiddleware != nil </span><span class="cov8" title="1">{
                return errorLastMiddlewareExist
        }</span>
        <span class="cov8" title="1">c.lastMiddleware = mw
        return nil</span>
}

// TakeOutLastMiddleware will return the set middleware and remove it from client.
//
// Remember to set it back after chain it with other middleware.
func (c *Client) TakeOutLastMiddleware() Middleware <span class="cov8" title="1">{
        last := c.lastMiddleware
        c.lastMiddleware = nil
        return last
}</span>

func newHttp1OptionFromClient(c *Client) *http1.ClientOptions <span class="cov8" title="1">{
        return &amp;http1.ClientOptions{
                Name:                          c.options.Name,
                NoDefaultUserAgentHeader:      c.options.NoDefaultUserAgentHeader,
                Dialer:                        c.options.Dialer,
                DialTimeout:                   c.options.DialTimeout,
                DialDualStack:                 c.options.DialDualStack,
                TLSConfig:                     c.options.TLSConfig,
                MaxConns:                      c.options.MaxConnsPerHost,
                MaxConnDuration:               c.options.MaxConnDuration,
                MaxIdleConnDuration:           c.options.MaxIdleConnDuration,
                ReadTimeout:                   c.options.ReadTimeout,
                WriteTimeout:                  c.options.WriteTimeout,
                MaxResponseBodySize:           c.options.MaxResponseBodySize,
                DisableHeaderNamesNormalizing: c.options.DisableHeaderNamesNormalizing,
                DisablePathNormalizing:        c.options.DisablePathNormalizing,
                MaxConnWaitTimeout:            c.options.MaxConnWaitTimeout,
                ResponseBodyStream:            c.options.ResponseBodyStream,
                RetryConfig:                   c.options.RetryConfig,
                RetryIfFunc:                   c.RetryIfFunc,
                StateObserve:                  c.options.HostClientStateObserve,
                ObservationInterval:           c.options.ObservationInterval,
        }
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package discovery

import (
        "context"
        "net"

        "github.com/cloudwego/hertz/pkg/app/server/registry"
        "github.com/cloudwego/hertz/pkg/common/utils"
)

type TargetInfo struct {
        Host string
        Tags map[string]string
}

type Resolver interface {
        // Target should return a description for the given target that is suitable for being a key for cache.
        Target(ctx context.Context, target *TargetInfo) string

        // Resolve returns a list of instances for the given description of a target.
        Resolve(ctx context.Context, desc string) (Result, error)

        // Name returns the name of the resolver.
        Name() string
}

// SynthesizedResolver synthesizes a Resolver using a resolve function.
type SynthesizedResolver struct {
        TargetFunc  func(ctx context.Context, target *TargetInfo) string
        ResolveFunc func(ctx context.Context, key string) (Result, error)
        NameFunc    func() string
}

func (sr SynthesizedResolver) Target(ctx context.Context, target *TargetInfo) string <span class="cov8" title="1">{
        if sr.TargetFunc == nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return sr.TargetFunc(ctx, target)</span>
}

func (sr SynthesizedResolver) Resolve(ctx context.Context, key string) (Result, error) <span class="cov8" title="1">{
        return sr.ResolveFunc(ctx, key)
}</span>

// Name implements the Resolver interface
func (sr SynthesizedResolver) Name() string <span class="cov8" title="1">{
        if sr.NameFunc == nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return sr.NameFunc()</span>
}

// Instance contains information of an instance from the target service.
type Instance interface {
        Address() net.Addr
        Weight() int
        Tag(key string) (value string, exist bool)
}

type instance struct {
        addr   net.Addr
        weight int
        tags   map[string]string
}

func (i *instance) Address() net.Addr <span class="cov8" title="1">{
        return i.addr
}</span>

func (i *instance) Weight() int <span class="cov8" title="1">{
        if i.weight &gt; 0 </span><span class="cov8" title="1">{
                return i.weight
        }</span>
        <span class="cov8" title="1">return registry.DefaultWeight</span>
}

func (i *instance) Tag(key string) (value string, exist bool) <span class="cov8" title="1">{
        value, exist = i.tags[key]
        return
}</span>

// NewInstance creates an Instance using the given network, address and tags
func NewInstance(network, address string, weight int, tags map[string]string) Instance <span class="cov8" title="1">{
        return &amp;instance{
                addr:   utils.NewNetAddr(network, address),
                weight: weight,
                tags:   tags,
        }
}</span>

// Result contains the result of service discovery process.
// the instance list can/should be cached and CacheKey can be used to map the instance list in cache.
type Result struct {
        CacheKey  string
        Instances []Instance
}
</pre>
		
		<pre class="file" id="file5" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package loadbalance

import (
        "context"
        "fmt"
        "sync"
        "sync/atomic"
        "time"

        "github.com/cloudwego/hertz/pkg/app/client/discovery"
        "github.com/cloudwego/hertz/pkg/common/errors"
        "github.com/cloudwego/hertz/pkg/common/hlog"
        "github.com/cloudwego/hertz/pkg/protocol"
        "golang.org/x/sync/singleflight"
)

type cacheResult struct {
        res         atomic.Value // newest and previous discovery result
        expire      int32        // 0 = normal, 1 = expire and collect next ticker
        serviceName string       // service psm
}

var (
        balancerFactories    sync.Map // key: resolver name + load-balancer name
        balancerFactoriesSfg singleflight.Group
)

func cacheKey(resolver, balancer string, opts Options) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s|%s|{%s %s}", resolver, balancer, opts.RefreshInterval, opts.ExpireInterval)
}</span>

type BalancerFactory struct {
        opts     Options
        cache    sync.Map // key -&gt; LoadBalancer
        resolver discovery.Resolver
        balancer Loadbalancer
        sfg      singleflight.Group
}

type Config struct {
        Resolver discovery.Resolver
        Balancer Loadbalancer
        LbOpts   Options
}

// NewBalancerFactory get or create a balancer with given target.
// If it has the same key(resolver.Target(target)), we will cache and reuse the Balance.
func NewBalancerFactory(config Config) *BalancerFactory <span class="cov8" title="1">{
        config.LbOpts.Check()
        uniqueKey := cacheKey(config.Resolver.Name(), config.Balancer.Name(), config.LbOpts)
        val, ok := balancerFactories.Load(uniqueKey)
        if ok </span><span class="cov8" title="1">{
                return val.(*BalancerFactory)
        }</span>
        <span class="cov8" title="1">val, _, _ = balancerFactoriesSfg.Do(uniqueKey, func() (interface{}, error) </span><span class="cov8" title="1">{
                b := &amp;BalancerFactory{
                        opts:     config.LbOpts,
                        resolver: config.Resolver,
                        balancer: config.Balancer,
                }
                go b.watcher()
                go b.refresh()
                balancerFactories.Store(uniqueKey, b)
                return b, nil
        }</span>)
        <span class="cov8" title="1">return val.(*BalancerFactory)</span>
}

// watch expired balancer
func (b *BalancerFactory) watcher() <span class="cov8" title="1">{
        for range time.Tick(b.opts.ExpireInterval) </span><span class="cov0" title="0">{
                b.cache.Range(func(key, value interface{}) bool </span><span class="cov0" title="0">{
                        cache := value.(*cacheResult)
                        if atomic.CompareAndSwapInt32(&amp;cache.expire, 0, 1) </span>{<span class="cov0" title="0">
                                // 1. set expire flag
                                // 2. wait next ticker for collect, maybe the balancer is used again
                                // (avoid being immediate delete the balancer which had been created recently)
                        }</span> else<span class="cov0" title="0"> {
                                b.cache.Delete(key)
                                b.balancer.Delete(key.(string))
                        }</span>
                        <span class="cov0" title="0">return true</span>
                })
        }
}

// cache key with resolver name prefix avoid conflict for balancer
func renameResultCacheKey(res *discovery.Result, resolverName string) <span class="cov8" title="1">{
        res.CacheKey = resolverName + ":" + res.CacheKey
}</span>

// refresh is used to update service discovery information periodically.
func (b *BalancerFactory) refresh() <span class="cov8" title="1">{
        for range time.Tick(b.opts.RefreshInterval) </span><span class="cov8" title="1">{
                b.cache.Range(func(key, value interface{}) bool </span><span class="cov8" title="1">{
                        res, err := b.resolver.Resolve(context.Background(), key.(string))
                        if err != nil </span><span class="cov0" title="0">{
                                hlog.SystemLogger().Warnf("resolver refresh failed, key=%s error=%s", key, err.Error())
                                return true
                        }</span>
                        <span class="cov8" title="1">renameResultCacheKey(&amp;res, b.resolver.Name())
                        cache := value.(*cacheResult)
                        cache.res.Store(res)
                        atomic.StoreInt32(&amp;cache.expire, 0)
                        b.balancer.Rebalance(res)
                        return true</span>
                })
        }
}

func (b *BalancerFactory) GetInstance(ctx context.Context, req *protocol.Request) (discovery.Instance, error) <span class="cov8" title="1">{
        cacheRes, err := b.getCacheResult(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">atomic.StoreInt32(&amp;cacheRes.expire, 0)
        ins := b.balancer.Pick(cacheRes.res.Load().(discovery.Result))
        if ins == nil </span><span class="cov0" title="0">{
                hlog.SystemLogger().Errorf("null instance. serviceName: %s, options: %v", string(req.Host()), req.Options())
                return nil, errors.NewPublic("instance not found")
        }</span>
        <span class="cov8" title="1">return ins, nil</span>
}

func (b *BalancerFactory) getCacheResult(ctx context.Context, req *protocol.Request) (*cacheResult, error) <span class="cov8" title="1">{
        target := b.resolver.Target(ctx, &amp;discovery.TargetInfo{Host: string(req.Host()), Tags: req.Options().Tags()})
        cr, existed := b.cache.Load(target)
        if existed </span><span class="cov8" title="1">{
                return cr.(*cacheResult), nil
        }</span>
        <span class="cov8" title="1">cr, err, _ := b.sfg.Do(target, func() (interface{}, error) </span><span class="cov8" title="1">{
                cache := &amp;cacheResult{
                        serviceName: string(req.Host()),
                }
                res, err := b.resolver.Resolve(ctx, target)
                if err != nil </span><span class="cov0" title="0">{
                        return cache, err
                }</span>
                <span class="cov8" title="1">renameResultCacheKey(&amp;res, b.resolver.Name())
                cache.res.Store(res)
                atomic.StoreInt32(&amp;cache.expire, 0)
                b.balancer.Rebalance(res)
                b.cache.Store(target, cache)
                return cache, nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return cr.(*cacheResult), nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package loadbalance

import (
        "time"

        "github.com/cloudwego/hertz/pkg/app/client/discovery"
)

// Loadbalancer picks instance for the given service discovery result.
type Loadbalancer interface {
        // Pick is used to select an instance according to discovery result
        Pick(discovery.Result) discovery.Instance

        // Rebalance is used to refresh the cache of load balance's information
        Rebalance(discovery.Result)

        // Delete is used to delete the cache of load balance's information when it is expired
        Delete(string)

        // Name returns the name of the Loadbalancer.
        Name() string
}

const (
        DefaultRefreshInterval = 5 * time.Second
        DefaultExpireInterval  = 15 * time.Second
)

var DefaultLbOpts = Options{
        RefreshInterval: DefaultRefreshInterval,
        ExpireInterval:  DefaultExpireInterval,
}

// Options for LoadBalance option
type Options struct {
        // refresh discovery result timely
        RefreshInterval time.Duration

        // Balancer expire check interval
        // we need remove idle Balancers for resource saving
        ExpireInterval time.Duration
}

// Check checks option's param
func (v *Options) Check() <span class="cov8" title="1">{
        if v.RefreshInterval &lt;= 0 </span><span class="cov8" title="1">{
                v.RefreshInterval = DefaultRefreshInterval
        }</span>
        <span class="cov8" title="1">if v.ExpireInterval &lt;= 0 </span><span class="cov8" title="1">{
                v.ExpireInterval = DefaultExpireInterval
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package loadbalance

import (
        "sync"

        "github.com/bytedance/gopkg/lang/fastrand"
        "github.com/cloudwego/hertz/pkg/app/client/discovery"
        "github.com/cloudwego/hertz/pkg/common/hlog"
        "golang.org/x/sync/singleflight"
)

type weightedBalancer struct {
        cachedWeightInfo sync.Map
        sfg              singleflight.Group
}

type weightInfo struct {
        instances []discovery.Instance
        entries   []int
        weightSum int
}

// NewWeightedBalancer creates a loadbalancer using weighted-random algorithm.
func NewWeightedBalancer() Loadbalancer <span class="cov8" title="1">{
        lb := &amp;weightedBalancer{}
        return lb
}</span>

func (wb *weightedBalancer) calcWeightInfo(e discovery.Result) *weightInfo <span class="cov8" title="1">{
        w := &amp;weightInfo{
                instances: make([]discovery.Instance, len(e.Instances)),
                weightSum: 0,
                entries:   make([]int, len(e.Instances)),
        }

        var cnt int

        for idx := range e.Instances </span><span class="cov8" title="1">{
                weight := e.Instances[idx].Weight()
                if weight &gt; 0 </span><span class="cov8" title="1">{
                        w.instances[cnt] = e.Instances[idx]
                        w.entries[cnt] = weight
                        w.weightSum += weight
                        cnt++
                }</span> else<span class="cov0" title="0"> {
                        hlog.SystemLogger().Warnf("Invalid weight=%d on instance address=%s", weight, e.Instances[idx].Address())
                }</span>
        }

        <span class="cov8" title="1">w.instances = w.instances[:cnt]

        return w</span>
}

// Pick implements the Loadbalancer interface.
func (wb *weightedBalancer) Pick(e discovery.Result) discovery.Instance <span class="cov8" title="1">{
        wi, ok := wb.cachedWeightInfo.Load(e.CacheKey)
        if !ok </span><span class="cov8" title="1">{
                wi, _, _ = wb.sfg.Do(e.CacheKey, func() (interface{}, error) </span><span class="cov8" title="1">{
                        return wb.calcWeightInfo(e), nil
                }</span>)
                <span class="cov8" title="1">wb.cachedWeightInfo.Store(e.CacheKey, wi)</span>
        }

        <span class="cov8" title="1">w := wi.(*weightInfo)
        if w.weightSum &lt;= 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">weight := fastrand.Intn(w.weightSum)
        for i := 0; i &lt; len(w.instances); i++ </span><span class="cov8" title="1">{
                weight -= w.entries[i]
                if weight &lt; 0 </span><span class="cov8" title="1">{
                        return w.instances[i]
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Rebalance implements the Loadbalancer interface.
func (wb *weightedBalancer) Rebalance(e discovery.Result) <span class="cov8" title="1">{
        wb.cachedWeightInfo.Store(e.CacheKey, wb.calcWeightInfo(e))
}</span>

// Delete implements the Loadbalancer interface.
func (wb *weightedBalancer) Delete(cacheKey string) <span class="cov0" title="0">{
        wb.cachedWeightInfo.Delete(cacheKey)
}</span>

func (wb *weightedBalancer) Name() string <span class="cov8" title="1">{
        return "weight_random"
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package client

import (
        "context"

        "github.com/cloudwego/hertz/pkg/protocol"
)

// Endpoint represent one method for calling from remote.
type Endpoint func(ctx context.Context, req *protocol.Request, resp *protocol.Response) (err error)

// Middleware deal with input Endpoint and output Endpoint.
type Middleware func(Endpoint) Endpoint

// Chain connect middlewares into one middleware.
func chain(mws ...Middleware) Middleware <span class="cov8" title="1">{
        return func(next Endpoint) Endpoint </span><span class="cov8" title="1">{
                for i := len(mws) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                        next = mws[i](next)
                }</span>
                <span class="cov8" title="1">return next</span>
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package client

import (
        "crypto/tls"
        "time"

        "github.com/cloudwego/hertz/pkg/app/client/retry"
        "github.com/cloudwego/hertz/pkg/common/config"
        "github.com/cloudwego/hertz/pkg/network"
        "github.com/cloudwego/hertz/pkg/network/dialer"
        "github.com/cloudwego/hertz/pkg/network/standard"
        "github.com/cloudwego/hertz/pkg/protocol/consts"
)

// WithDialTimeout sets dial timeout.
func WithDialTimeout(dialTimeout time.Duration) config.ClientOption <span class="cov8" title="1">{
        return config.ClientOption{F: func(o *config.ClientOptions) </span><span class="cov8" title="1">{
                o.DialTimeout = dialTimeout
        }</span>}
}

// WithMaxConnsPerHost sets maximum number of connections per host which may be established.
func WithMaxConnsPerHost(mc int) config.ClientOption <span class="cov8" title="1">{
        return config.ClientOption{F: func(o *config.ClientOptions) </span><span class="cov8" title="1">{
                o.MaxConnsPerHost = mc
        }</span>}
}

// WithMaxIdleConnDuration sets max idle connection duration, idle keep-alive connections are closed after this duration.
func WithMaxIdleConnDuration(t time.Duration) config.ClientOption <span class="cov8" title="1">{
        return config.ClientOption{F: func(o *config.ClientOptions) </span><span class="cov8" title="1">{
                o.MaxIdleConnDuration = t
        }</span>}
}

// WithMaxConnDuration sets max connection duration, keep-alive connections are closed after this duration.
func WithMaxConnDuration(t time.Duration) config.ClientOption <span class="cov8" title="1">{
        return config.ClientOption{F: func(o *config.ClientOptions) </span><span class="cov8" title="1">{
                o.MaxConnDuration = t
        }</span>}
}

// WithMaxConnWaitTimeout sets maximum duration for waiting for a free connection.
func WithMaxConnWaitTimeout(t time.Duration) config.ClientOption <span class="cov8" title="1">{
        return config.ClientOption{F: func(o *config.ClientOptions) </span><span class="cov8" title="1">{
                o.MaxConnWaitTimeout = t
        }</span>}
}

// WithKeepAlive determines whether use keep-alive connection.
func WithKeepAlive(b bool) config.ClientOption <span class="cov8" title="1">{
        return config.ClientOption{F: func(o *config.ClientOptions) </span><span class="cov8" title="1">{
                o.KeepAlive = b
        }</span>}
}

// WithClientReadTimeout sets maximum duration for full response reading (including body).
func WithClientReadTimeout(t time.Duration) config.ClientOption <span class="cov8" title="1">{
        return config.ClientOption{F: func(o *config.ClientOptions) </span><span class="cov8" title="1">{
                o.ReadTimeout = t
        }</span>}
}

// WithTLSConfig sets tlsConfig to create a tls connection.
func WithTLSConfig(cfg *tls.Config) config.ClientOption <span class="cov8" title="1">{
        return config.ClientOption{F: func(o *config.ClientOptions) </span><span class="cov8" title="1">{
                o.TLSConfig = cfg
                o.Dialer = standard.NewDialer()
        }</span>}
}

// WithDialer sets the specific dialer.
func WithDialer(d network.Dialer) config.ClientOption <span class="cov8" title="1">{
        return config.ClientOption{F: func(o *config.ClientOptions) </span><span class="cov8" title="1">{
                o.Dialer = d
        }</span>}
}

// WithResponseBodyStream is used to determine whether read body in stream or not.
func WithResponseBodyStream(b bool) config.ClientOption <span class="cov8" title="1">{
        return config.ClientOption{F: func(o *config.ClientOptions) </span><span class="cov8" title="1">{
                o.ResponseBodyStream = b
        }</span>}
}

// WithHostClientConfigHook is used to set the function hook for re-configure the host client.
func WithHostClientConfigHook(h func(hc interface{}) error) config.ClientOption <span class="cov8" title="1">{
        return config.ClientOption{F: func(o *config.ClientOptions) </span><span class="cov8" title="1">{
                o.HostClientConfigHook = h
        }</span>}
}

// WithDisableHeaderNamesNormalizing is used to set whether disable header names normalizing.
func WithDisableHeaderNamesNormalizing(disable bool) config.ClientOption <span class="cov8" title="1">{
        return config.ClientOption{F: func(o *config.ClientOptions) </span><span class="cov8" title="1">{
                o.DisableHeaderNamesNormalizing = disable
        }</span>}
}

// WithName sets client name which used in User-Agent Header.
func WithName(name string) config.ClientOption <span class="cov8" title="1">{
        return config.ClientOption{F: func(o *config.ClientOptions) </span><span class="cov8" title="1">{
                o.Name = name
        }</span>}
}

// WithNoDefaultUserAgentHeader sets whether no default User-Agent header.
func WithNoDefaultUserAgentHeader(isNoDefaultUserAgentHeader bool) config.ClientOption <span class="cov8" title="1">{
        return config.ClientOption{F: func(o *config.ClientOptions) </span><span class="cov8" title="1">{
                o.NoDefaultUserAgentHeader = isNoDefaultUserAgentHeader
        }</span>}
}

// WithDisablePathNormalizing sets whether disable path normalizing.
func WithDisablePathNormalizing(isDisablePathNormalizing bool) config.ClientOption <span class="cov8" title="1">{
        return config.ClientOption{F: func(o *config.ClientOptions) </span><span class="cov8" title="1">{
                o.DisablePathNormalizing = isDisablePathNormalizing
        }</span>}
}

func WithRetryConfig(opts ...retry.Option) config.ClientOption <span class="cov8" title="1">{
        retryCfg := &amp;retry.Config{
                MaxAttemptTimes: consts.DefaultMaxRetryTimes,
                Delay:           1 * time.Millisecond,
                MaxDelay:        100 * time.Millisecond,
                MaxJitter:       20 * time.Millisecond,
                DelayPolicy:     retry.CombineDelay(retry.DefaultDelayPolicy),
        }
        retryCfg.Apply(opts)

        return config.ClientOption{F: func(o *config.ClientOptions) </span><span class="cov8" title="1">{
                o.RetryConfig = retryCfg
        }</span>}
}

// WithWriteTimeout sets write timeout.
func WithWriteTimeout(t time.Duration) config.ClientOption <span class="cov8" title="1">{
        return config.ClientOption{F: func(o *config.ClientOptions) </span><span class="cov8" title="1">{
                o.WriteTimeout = t
        }</span>}
}

// WithConnStateObserve sets the connection state observation function.
// The first param is used to set hostclient state func.
// The second param is used to set observation interval, default value is 5 seconds.
// Warn: Do not start go routine in HostClientStateFunc.
func WithConnStateObserve(hs config.HostClientStateFunc, interval ...time.Duration) config.ClientOption <span class="cov8" title="1">{
        return config.ClientOption{F: func(o *config.ClientOptions) </span><span class="cov8" title="1">{
                o.HostClientStateObserve = hs
                if len(interval) &gt; 0 </span><span class="cov8" title="1">{
                        o.ObservationInterval = interval[0]
                }</span>
        }}
}

// WithDialFunc is used to set dialer function.
// Note: WithDialFunc will overwrite custom dialer.
func WithDialFunc(f network.DialFunc, dialers ...network.Dialer) config.ClientOption <span class="cov8" title="1">{
        return config.ClientOption{F: func(o *config.ClientOptions) </span><span class="cov8" title="1">{
                d := dialer.DefaultDialer()
                if len(dialers) != 0 </span><span class="cov0" title="0">{
                        d = dialers[0]
                }</span>
                <span class="cov8" title="1">o.Dialer = newCustomDialerWithDialFunc(d, f)</span>
        }}
}

// customDialer set customDialerFunc and params to set dailFunc
type customDialer struct {
        network.Dialer
        dialFunc network.DialFunc
}

func (m *customDialer) DialConnection(network, address string, timeout time.Duration, tlsConfig *tls.Config) (conn network.Conn, err error) <span class="cov8" title="1">{
        if m.dialFunc != nil </span><span class="cov8" title="1">{
                return m.dialFunc(address)
        }</span>
        <span class="cov0" title="0">return m.Dialer.DialConnection(network, address, timeout, tlsConfig)</span>
}

func newCustomDialerWithDialFunc(dialer network.Dialer, dialFunc network.DialFunc) network.Dialer <span class="cov8" title="1">{
        return &amp;customDialer{
                Dialer:   dialer,
                dialFunc: dialFunc,
        }
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package retry

import "time"

// Option is the only struct that can be used to set Retry Config.
type Option struct {
        F func(o *Config)
}

// WithMaxAttemptTimes set WithMaxAttemptTimes , including the first call.
func WithMaxAttemptTimes(maxAttemptTimes uint) Option <span class="cov8" title="1">{
        return Option{F: func(o *Config) </span><span class="cov8" title="1">{
                o.MaxAttemptTimes = maxAttemptTimes
        }</span>}
}

// WithInitDelay set init Delay.
func WithInitDelay(delay time.Duration) Option <span class="cov8" title="1">{
        return Option{F: func(o *Config) </span><span class="cov8" title="1">{
                o.Delay = delay
        }</span>}
}

// WithMaxDelay set MaxDelay.
func WithMaxDelay(maxDelay time.Duration) Option <span class="cov8" title="1">{
        return Option{F: func(o *Config) </span><span class="cov8" title="1">{
                o.MaxDelay = maxDelay
        }</span>}
}

// WithDelayPolicy set DelayPolicy.
func WithDelayPolicy(delayPolicy DelayPolicyFunc) Option <span class="cov8" title="1">{
        return Option{F: func(o *Config) </span><span class="cov8" title="1">{
                o.DelayPolicy = delayPolicy
        }</span>}
}

// WithMaxJitter set MaxJitter.
func WithMaxJitter(maxJitter time.Duration) Option <span class="cov8" title="1">{
        return Option{F: func(o *Config) </span><span class="cov8" title="1">{
                o.MaxJitter = maxJitter
        }</span>}
}
</pre>
		
		<pre class="file" id="file11" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package retry

import (
        "math"
        "time"

        "github.com/bytedance/gopkg/lang/fastrand"
)

// Config All configurations related to retry
type Config struct {
        // The maximum number of call attempt times, including the initial call
        MaxAttemptTimes uint

        // Initial retry delay time
        Delay time.Duration

        // Maximum retry delay time. When the retry time increases beyond this time,
        // this configuration will limit the upper limit of waiting time
        MaxDelay time.Duration

        // The maximum jitter time, which takes effect when the delay policy is configured as RandomDelay
        MaxJitter time.Duration

        // Delay strategy, which can combine multiple delay strategies. such as CombineDelay(BackOffDelayPolicy, RandomDelayPolicy) or BackOffDelayPolicy,etc
        DelayPolicy DelayPolicyFunc
}

func (o *Config) Apply(opts []Option) <span class="cov8" title="1">{
        for _, op := range opts </span><span class="cov8" title="1">{
                op.F(o)
        }</span>
}

// DelayPolicyFunc signature of delay policy function
// is called to return the delay of retry
type DelayPolicyFunc func(attempts uint, err error, retryConfig *Config) time.Duration

// DefaultDelayPolicy is a DelayPolicyFunc which keep 0 delay in all iterations
func DefaultDelayPolicy(_ uint, _ error, _ *Config) time.Duration <span class="cov8" title="1">{
        return 0 * time.Millisecond
}</span>

// FixedDelayPolicy is a DelayPolicyFunc which keeps delay the same through all iterations
func FixedDelayPolicy(_ uint, _ error, retryConfig *Config) time.Duration <span class="cov8" title="1">{
        return retryConfig.Delay
}</span>

// RandomDelayPolicy is a DelayPolicyFunc which picks a random delay up to RetryConfig.MaxJitter, if the retryConfig.MaxJitter less than or equal to 0, the final delay is 0
func RandomDelayPolicy(_ uint, _ error, retryConfig *Config) time.Duration <span class="cov8" title="1">{
        if retryConfig.MaxJitter &lt;= 0 </span><span class="cov8" title="1">{
                return 0 * time.Millisecond
        }</span>
        <span class="cov8" title="1">return time.Duration(fastrand.Int63n(int64(retryConfig.MaxJitter)))</span>
}

// BackOffDelayPolicy is a DelayPolicyFunc which exponentially increases delay between consecutive retries, if the retryConfig.Delay less than or equal to 0, the final delay is 0
func BackOffDelayPolicy(attempts uint, _ error, retryConfig *Config) time.Duration <span class="cov8" title="1">{
        if retryConfig.Delay &lt;= 0 </span><span class="cov8" title="1">{
                return 0 * time.Millisecond
        }</span>
        // 1 &lt;&lt; 63 would overflow signed int64 (time.Duration), thus 62.
        <span class="cov8" title="1">const max uint = 62
        if attempts &gt; max </span><span class="cov8" title="1">{
                attempts = max
        }</span>

        <span class="cov8" title="1">return retryConfig.Delay &lt;&lt; attempts</span>
}

// CombineDelay return DelayPolicyFunc, which combines the optional DelayPolicyFunc into a new DelayPolicyFunc
func CombineDelay(delays ...DelayPolicyFunc) DelayPolicyFunc <span class="cov8" title="1">{
        const maxInt64 = uint64(math.MaxInt64)

        return func(attempts uint, err error, config *Config) time.Duration </span><span class="cov8" title="1">{
                var total uint64
                for _, delay := range delays </span><span class="cov8" title="1">{
                        total += uint64(delay(attempts, err, config))
                        if total &gt; maxInt64 </span><span class="cov8" title="1">{
                                total = maxInt64
                        }</span>
                }

                <span class="cov8" title="1">return time.Duration(total)</span>
        }
}

// Delay generate the delay time required for the current retry config, if the retryConfig.DelayPolicy == nil, the final delay is 0
func Delay(attempts uint, err error, retryConfig *Config) time.Duration <span class="cov8" title="1">{
        if retryConfig.DelayPolicy == nil </span><span class="cov8" title="1">{
                return 0 * time.Millisecond
        }</span>

        <span class="cov8" title="1">delayTime := retryConfig.DelayPolicy(attempts, err, retryConfig)
        if retryConfig.MaxDelay &gt; 0 &amp;&amp; delayTime &gt; retryConfig.MaxDelay </span><span class="cov8" title="1">{
                delayTime = retryConfig.MaxDelay
        }</span>
        <span class="cov8" title="1">return delayTime</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015-present Aliaksandr Valialkin, VertaMedia, Kirill Danshin, Erik Dubbelboer, FastHTTP Authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This file may have been modified by CloudWeGo authors. All CloudWeGo
 * Modifications are Copyright 2022 CloudWeGo Authors.
 */

package app

import (
        "context"
        "fmt"
        "io"
        "mime/multipart"
        "net"
        "net/url"
        "os"
        "reflect"
        "strings"
        "sync"
        "time"

        "github.com/cloudwego/hertz/internal/bytesconv"
        "github.com/cloudwego/hertz/internal/bytestr"
        "github.com/cloudwego/hertz/pkg/app/server/binding"
        "github.com/cloudwego/hertz/pkg/app/server/render"
        "github.com/cloudwego/hertz/pkg/common/errors"
        "github.com/cloudwego/hertz/pkg/common/tracer/traceinfo"
        "github.com/cloudwego/hertz/pkg/common/utils"
        "github.com/cloudwego/hertz/pkg/network"
        "github.com/cloudwego/hertz/pkg/protocol"
        "github.com/cloudwego/hertz/pkg/protocol/consts"
        rConsts "github.com/cloudwego/hertz/pkg/route/consts"
        "github.com/cloudwego/hertz/pkg/route/param"
)

var zeroTCPAddr = &amp;net.TCPAddr{
        IP: net.IPv4zero,
}

type Handler interface {
        ServeHTTP(c context.Context, ctx *RequestContext)
}

type ClientIP func(ctx *RequestContext) string

type ClientIPOptions struct {
        RemoteIPHeaders []string
        TrustedCIDRs    []*net.IPNet
}

var defaultTrustedCIDRs = []*net.IPNet{
        { // 0.0.0.0/0 (IPv4)
                IP:   net.IP{0x0, 0x0, 0x0, 0x0},
                Mask: net.IPMask{0x0, 0x0, 0x0, 0x0},
        },
        { // ::/0 (IPv6)
                IP:   net.IP{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
                Mask: net.IPMask{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
        },
}

var defaultClientIPOptions = ClientIPOptions{
        RemoteIPHeaders: []string{"X-Forwarded-For", "X-Real-IP"},
        TrustedCIDRs:    defaultTrustedCIDRs,
}

// ClientIPWithOption used to generate custom ClientIP function and set by engine.SetClientIPFunc
func ClientIPWithOption(opts ClientIPOptions) ClientIP <span class="cov8" title="1">{
        return func(ctx *RequestContext) string </span><span class="cov8" title="1">{
                RemoteIPHeaders := opts.RemoteIPHeaders
                TrustedCIDRs := opts.TrustedCIDRs

                remoteIPStr, _, err := net.SplitHostPort(strings.TrimSpace(ctx.RemoteAddr().String()))
                if err != nil </span><span class="cov0" title="0">{
                        return ""
                }</span>

                <span class="cov8" title="1">remoteIP := net.ParseIP(remoteIPStr)
                if remoteIP == nil </span><span class="cov0" title="0">{
                        return ""
                }</span>

                <span class="cov8" title="1">trusted := isTrustedProxy(TrustedCIDRs, remoteIP)

                if trusted </span><span class="cov8" title="1">{
                        for _, headerName := range RemoteIPHeaders </span><span class="cov8" title="1">{
                                ip, valid := validateHeader(TrustedCIDRs, ctx.Request.Header.Get(headerName))
                                if valid </span><span class="cov8" title="1">{
                                        return ip
                                }</span>
                        }
                }

                <span class="cov8" title="1">return remoteIPStr</span>
        }
}

// isTrustedProxy will check whether the IP address is included in the trusted list according to trustedCIDRs
func isTrustedProxy(trustedCIDRs []*net.IPNet, remoteIP net.IP) bool <span class="cov8" title="1">{
        if trustedCIDRs == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for _, cidr := range trustedCIDRs </span><span class="cov8" title="1">{
                if cidr.Contains(remoteIP) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// validateHeader will parse X-Real-IP and X-Forwarded-For header and return the Initial client IP address or an untrusted IP address
func validateHeader(trustedCIDRs []*net.IPNet, header string) (clientIP string, valid bool) <span class="cov8" title="1">{
        if header == "" </span><span class="cov8" title="1">{
                return "", false
        }</span>
        <span class="cov8" title="1">items := strings.Split(header, ",")
        for i := len(items) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                ipStr := strings.TrimSpace(items[i])
                ip := net.ParseIP(ipStr)
                if ip == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                // X-Forwarded-For is appended by proxy
                // Check IPs in reverse order and stop when find untrusted proxy
                <span class="cov8" title="1">if (i == 0) || (!isTrustedProxy(trustedCIDRs, ip)) </span><span class="cov8" title="1">{
                        return ipStr, true
                }</span>
        }
        <span class="cov0" title="0">return "", false</span>
}

var defaultClientIP = ClientIPWithOption(defaultClientIPOptions)

// SetClientIPFunc sets ClientIP function implementation to get ClientIP.
// Deprecated: Use engine.SetClientIPFunc instead of SetClientIPFunc
func SetClientIPFunc(fn ClientIP) <span class="cov8" title="1">{
        defaultClientIP = fn
}</span>

type FormValueFunc func(*RequestContext, string) []byte

var defaultFormValue = func(ctx *RequestContext, key string) []byte <span class="cov8" title="1">{
        v := ctx.QueryArgs().Peek(key)
        if len(v) &gt; 0 </span><span class="cov8" title="1">{
                return v
        }</span>
        <span class="cov8" title="1">v = ctx.PostArgs().Peek(key)
        if len(v) &gt; 0 </span><span class="cov8" title="1">{
                return v
        }</span>
        <span class="cov8" title="1">mf, err := ctx.MultipartForm()
        if err == nil &amp;&amp; mf.Value != nil </span><span class="cov8" title="1">{
                vv := mf.Value[key]
                if len(vv) &gt; 0 </span><span class="cov8" title="1">{
                        return []byte(vv[0])
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

type RequestContext struct {
        conn     network.Conn
        Request  protocol.Request
        Response protocol.Response

        // Errors is a list of errors attached to all the handlers/middlewares who used this context.
        Errors errors.ErrorChain

        Params     param.Params
        handlers   HandlersChain
        fullPath   string
        index      int8
        HTMLRender render.HTMLRender

        // This mutex protect Keys map.
        mu sync.RWMutex

        // Keys is a key/value pair exclusively for the context of each request.
        Keys map[string]interface{}

        hijackHandler HijackHandler

        finishedMu sync.Mutex

        // finished means the request end.
        finished chan struct{}

        // traceInfo defines the trace information.
        traceInfo traceinfo.TraceInfo

        // enableTrace defines whether enable trace.
        enableTrace bool

        // clientIPFunc get client ip by use custom function.
        clientIPFunc ClientIP

        // clientIPFunc get form value by use custom function.
        formValueFunc FormValueFunc

        binder    binding.Binder
        validator binding.StructValidator
        exiled    bool
}

// Exile marks this RequestContext as not to be recycled.
// Experimental features: Use with caution, it may have a slight impact on performance.
func (ctx *RequestContext) Exile() <span class="cov0" title="0">{
        ctx.exiled = true
}</span>

func (ctx *RequestContext) IsExiled() bool <span class="cov0" title="0">{
        return ctx.exiled
}</span>

// Flush is the shortcut for ctx.Response.GetHijackWriter().Flush().
// Will return nil if the response writer is not hijacked.
func (ctx *RequestContext) Flush() error <span class="cov8" title="1">{
        if ctx.Response.GetHijackWriter() == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov0" title="0">return ctx.Response.GetHijackWriter().Flush()</span>
}

func (ctx *RequestContext) SetClientIPFunc(f ClientIP) <span class="cov8" title="1">{
        ctx.clientIPFunc = f
}</span>

func (ctx *RequestContext) SetFormValueFunc(f FormValueFunc) <span class="cov8" title="1">{
        ctx.formValueFunc = f
}</span>

func (ctx *RequestContext) SetBinder(binder binding.Binder) <span class="cov8" title="1">{
        ctx.binder = binder
}</span>

func (ctx *RequestContext) SetValidator(validator binding.StructValidator) <span class="cov8" title="1">{
        ctx.validator = validator
}</span>

func (ctx *RequestContext) GetTraceInfo() traceinfo.TraceInfo <span class="cov8" title="1">{
        return ctx.traceInfo
}</span>

func (ctx *RequestContext) SetTraceInfo(t traceinfo.TraceInfo) <span class="cov8" title="1">{
        ctx.traceInfo = t
}</span>

func (ctx *RequestContext) IsEnableTrace() bool <span class="cov8" title="1">{
        return ctx.enableTrace
}</span>

// SetEnableTrace sets whether enable trace.
//
// NOTE: biz handler must not modify this value, otherwise, it may panic.
func (ctx *RequestContext) SetEnableTrace(enable bool) <span class="cov8" title="1">{
        ctx.enableTrace = enable
}</span>

// NewContext make a pure RequestContext without any http request/response information
//
// Set the Request filed before use it for handlers
func NewContext(maxParams uint16) *RequestContext <span class="cov8" title="1">{
        v := make(param.Params, 0, maxParams)
        ctx := &amp;RequestContext{Params: v, index: -1}
        return ctx
}</span>

// Loop fn for every k/v in Keys
func (ctx *RequestContext) ForEachKey(fn func(k string, v interface{})) <span class="cov8" title="1">{
        ctx.mu.RLock()
        for key, val := range ctx.Keys </span><span class="cov8" title="1">{
                fn(key, val)
        }</span>
        <span class="cov8" title="1">ctx.mu.RUnlock()</span>
}

func (ctx *RequestContext) SetConn(c network.Conn) <span class="cov8" title="1">{
        ctx.conn = c
}</span>

func (ctx *RequestContext) GetConn() network.Conn <span class="cov8" title="1">{
        return ctx.conn
}</span>

func (ctx *RequestContext) SetHijackHandler(h HijackHandler) <span class="cov8" title="1">{
        ctx.hijackHandler = h
}</span>

func (ctx *RequestContext) GetHijackHandler() HijackHandler <span class="cov8" title="1">{
        return ctx.hijackHandler
}</span>

func (ctx *RequestContext) GetReader() network.Reader <span class="cov8" title="1">{
        return ctx.conn
}</span>

func (ctx *RequestContext) GetWriter() network.Writer <span class="cov8" title="1">{
        return ctx.conn
}</span>

func (ctx *RequestContext) GetIndex() int8 <span class="cov8" title="1">{
        return ctx.index
}</span>

// SetIndex reset the handler's execution index
// Disclaimer: You can loop yourself to deal with this, use wisely.
func (ctx *RequestContext) SetIndex(index int8) <span class="cov8" title="1">{
        ctx.index = index
}</span>

type HandlerFunc func(c context.Context, ctx *RequestContext)

// HandlersChain defines a HandlerFunc array.
type HandlersChain []HandlerFunc

type HandlerNameOperator interface {
        SetHandlerName(handler HandlerFunc, name string)
        GetHandlerName(handler HandlerFunc) string
}

func SetHandlerNameOperator(o HandlerNameOperator) <span class="cov8" title="1">{
        inbuiltHandlerNameOperator = o
}</span>

type inbuiltHandlerNameOperatorStruct struct {
        handlerNames map[uintptr]string
}

func (o *inbuiltHandlerNameOperatorStruct) SetHandlerName(handler HandlerFunc, name string) <span class="cov8" title="1">{
        o.handlerNames[getFuncAddr(handler)] = name
}</span>

func (o *inbuiltHandlerNameOperatorStruct) GetHandlerName(handler HandlerFunc) string <span class="cov8" title="1">{
        return o.handlerNames[getFuncAddr(handler)]
}</span>

type concurrentHandlerNameOperatorStruct struct {
        handlerNames map[uintptr]string
        lock         sync.RWMutex
}

func (o *concurrentHandlerNameOperatorStruct) SetHandlerName(handler HandlerFunc, name string) <span class="cov8" title="1">{
        o.lock.Lock()
        defer o.lock.Unlock()
        o.handlerNames[getFuncAddr(handler)] = name
}</span>

func (o *concurrentHandlerNameOperatorStruct) GetHandlerName(handler HandlerFunc) string <span class="cov8" title="1">{
        o.lock.RLock()
        defer o.lock.RUnlock()
        return o.handlerNames[getFuncAddr(handler)]
}</span>

func SetConcurrentHandlerNameOperator() <span class="cov8" title="1">{
        SetHandlerNameOperator(&amp;concurrentHandlerNameOperatorStruct{handlerNames: map[uintptr]string{}})
}</span>

func init() <span class="cov8" title="1">{
        inbuiltHandlerNameOperator = &amp;inbuiltHandlerNameOperatorStruct{handlerNames: map[uintptr]string{}}
}</span>

var inbuiltHandlerNameOperator HandlerNameOperator

func SetHandlerName(handler HandlerFunc, name string) <span class="cov8" title="1">{
        inbuiltHandlerNameOperator.SetHandlerName(handler, name)
}</span>

func GetHandlerName(handler HandlerFunc) string <span class="cov8" title="1">{
        return inbuiltHandlerNameOperator.GetHandlerName(handler)
}</span>

func getFuncAddr(v interface{}) uintptr <span class="cov8" title="1">{
        return reflect.ValueOf(reflect.ValueOf(v)).Field(1).Pointer()
}</span>

// HijackHandler must process the hijacked connection c.
//
// If KeepHijackedConns is disabled, which is by default,
// the connection c is automatically closed after returning from HijackHandler.
//
// The connection c must not be used after returning from the handler, if KeepHijackedConns is disabled.
//
// When KeepHijackedConns enabled, hertz will not Close() the connection,
// you must do it when you need it. You must not use c in any way after calling Close().
//
// network.Connection provide two options of io: net.Conn and zero-copy read/write
type HijackHandler func(c network.Conn)

// Hijack registers the given handler for connection hijacking.
//
// The handler is called after returning from RequestHandler
// and sending http response. The current connection is passed
// to the handler. The connection is automatically closed after
// returning from the handler.
//
// The server skips calling the handler in the following cases:
//
//   - 'Connection: close' header exists in either request or response.
//   - Unexpected error during response writing to the connection.
//
// The server stops processing requests from hijacked connections.
//
// Server limits such as Concurrency, ReadTimeout, WriteTimeout, etc.
// aren't applied to hijacked connections.
//
// The handler must not retain references to ctx members.
//
// Arbitrary 'Connection: Upgrade' protocols may be implemented
// with HijackHandler. For instance,
//
//   - WebSocket ( https://en.wikipedia.org/wiki/WebSocket )
//   - HTTP/2.0 ( https://en.wikipedia.org/wiki/HTTP/2 )
func (ctx *RequestContext) Hijack(handler HijackHandler) <span class="cov8" title="1">{
        ctx.hijackHandler = handler
}</span>

// Last returns the last handler of the handler chain.
//
// Generally speaking, the last handler is the main handler.
func (c HandlersChain) Last() HandlerFunc <span class="cov8" title="1">{
        if length := len(c); length &gt; 0 </span><span class="cov8" title="1">{
                return c[length-1]
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (ctx *RequestContext) Finished() &lt;-chan struct{} <span class="cov8" title="1">{
        ctx.finishedMu.Lock()
        if ctx.finished == nil </span><span class="cov8" title="1">{
                ctx.finished = make(chan struct{})
        }</span>
        <span class="cov8" title="1">ch := ctx.finished
        ctx.finishedMu.Unlock()
        return ch</span>
}

// GetRequest returns a copy of Request.
func (ctx *RequestContext) GetRequest() (dst *protocol.Request) <span class="cov8" title="1">{
        dst = &amp;protocol.Request{}
        ctx.Request.CopyTo(dst)
        return
}</span>

// GetResponse returns a copy of Response.
func (ctx *RequestContext) GetResponse() (dst *protocol.Response) <span class="cov8" title="1">{
        dst = &amp;protocol.Response{}
        ctx.Response.CopyTo(dst)
        return
}</span>

// Value returns the value associated with this context for key, or nil
// if no value is associated with key. Successive calls to Value with
// the same key returns the same result.
//
// In case the Key is reset after response, Value() return nil if ctx.Key is nil.
func (ctx *RequestContext) Value(key interface{}) interface{} <span class="cov8" title="1">{
        // this ctx has been reset, return nil.
        if ctx.Keys == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if keyString, ok := key.(string); ok </span><span class="cov8" title="1">{
                val, _ := ctx.Get(keyString)
                return val
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Hijacked returns true after Hijack is called.
func (ctx *RequestContext) Hijacked() bool <span class="cov8" title="1">{
        return ctx.hijackHandler != nil
}</span>

// SetBodyStream sets response body stream and, optionally body size.
//
// bodyStream.Close() is called after finishing reading all body data
// if it implements io.Closer.
//
// If bodySize is &gt;= 0, then bodySize bytes must be provided by bodyStream
// before returning io.EOF.
//
// If bodySize &lt; 0, then bodyStream is read until io.EOF.
//
// See also SetBodyStreamWriter.
func (ctx *RequestContext) SetBodyStream(bodyStream io.Reader, bodySize int) <span class="cov8" title="1">{
        ctx.Response.SetBodyStream(bodyStream, bodySize)
}</span>

// Host returns requested host.
//
// The host is valid until returning from RequestHandler.
func (ctx *RequestContext) Host() []byte <span class="cov8" title="1">{
        return ctx.URI().Host()
}</span>

// RemoteAddr returns client address for the given request.
//
// If address is nil, it will return zeroTCPAddr.
func (ctx *RequestContext) RemoteAddr() net.Addr <span class="cov8" title="1">{
        if ctx.conn == nil </span><span class="cov8" title="1">{
                return zeroTCPAddr
        }</span>
        <span class="cov8" title="1">addr := ctx.conn.RemoteAddr()
        if addr == nil </span><span class="cov0" title="0">{
                return zeroTCPAddr
        }</span>
        <span class="cov8" title="1">return addr</span>
}

// WriteString appends s to response body.
func (ctx *RequestContext) WriteString(s string) (int, error) <span class="cov8" title="1">{
        ctx.Response.AppendBodyString(s)
        return len(s), nil
}</span>

// SetContentType sets response Content-Type.
func (ctx *RequestContext) SetContentType(contentType string) <span class="cov8" title="1">{
        ctx.Response.Header.SetContentType(contentType)
}</span>

// Path returns requested path.
//
// The path is valid until returning from RequestHandler.
func (ctx *RequestContext) Path() []byte <span class="cov8" title="1">{
        return ctx.URI().Path()
}</span>

// NotModified resets response and sets '304 Not Modified' response status code.
func (ctx *RequestContext) NotModified() <span class="cov8" title="1">{
        ctx.Response.Reset()
        ctx.SetStatusCode(consts.StatusNotModified)
}</span>

// IfModifiedSince returns true if lastModified exceeds 'If-Modified-Since'
// value from the request header.
//
// The function returns true also 'If-Modified-Since' request header is missing.
func (ctx *RequestContext) IfModifiedSince(lastModified time.Time) bool <span class="cov8" title="1">{
        ifModStr := ctx.Request.Header.PeekIfModifiedSinceBytes()
        if len(ifModStr) == 0 </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">ifMod, err := bytesconv.ParseHTTPDate(ifModStr)
        if err != nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">lastModified = lastModified.Truncate(time.Second)
        return ifMod.Before(lastModified)</span>
}

// URI returns requested uri.
//
// The uri is valid until returning from RequestHandler.
func (ctx *RequestContext) URI() *protocol.URI <span class="cov8" title="1">{
        return ctx.Request.URI()
}</span>

func (ctx *RequestContext) String(code int, format string, values ...interface{}) <span class="cov8" title="1">{
        ctx.Render(code, render.String{Format: format, Data: values})
}</span>

// FullPath returns a matched route full path. For not found routes
// returns an empty string.
//
//        router.GET("/user/:id", func(c context.Context, ctx *app.RequestContext) {
//            ctx.FullPath() == "/user/:id" // true
//        })
func (ctx *RequestContext) FullPath() string <span class="cov8" title="1">{
        return ctx.fullPath
}</span>

func (ctx *RequestContext) SetFullPath(p string) <span class="cov8" title="1">{
        ctx.fullPath = p
}</span>

// SetStatusCode sets response status code.
func (ctx *RequestContext) SetStatusCode(statusCode int) <span class="cov8" title="1">{
        ctx.Response.SetStatusCode(statusCode)
}</span>

// Write writes p into response body.
func (ctx *RequestContext) Write(p []byte) (int, error) <span class="cov8" title="1">{
        ctx.Response.AppendBody(p)
        return len(p), nil
}</span>

// File writes the specified file into the body stream in an efficient way.
func (ctx *RequestContext) File(filepath string) <span class="cov8" title="1">{
        ServeFile(ctx, filepath)
}</span>

func (ctx *RequestContext) FileFromFS(filepath string, fs *FS) <span class="cov8" title="1">{
        defer func(old string) </span><span class="cov8" title="1">{
                ctx.Request.URI().SetPath(old)
        }</span>(string(ctx.Request.URI().Path()))

        <span class="cov8" title="1">ctx.Request.URI().SetPath(filepath)

        fs.NewRequestHandler()(context.Background(), ctx)</span>
}

// FileAttachment use an efficient way to write the file to body stream.
//
// When client download the file, it will rename the file as filename
func (ctx *RequestContext) FileAttachment(filepath, filename string) <span class="cov8" title="1">{
        ctx.Response.Header.Set("content-disposition", fmt.Sprintf("attachment; filename=\"%s\"", filename))
        ServeFile(ctx, filepath)
}</span>

// SetBodyString sets response body to the given value.
func (ctx *RequestContext) SetBodyString(body string) <span class="cov8" title="1">{
        ctx.Response.SetBodyString(body)
}</span>

// SetContentTypeBytes sets response Content-Type.
//
// It is safe modifying contentType buffer after function return.
func (ctx *RequestContext) SetContentTypeBytes(contentType []byte) <span class="cov8" title="1">{
        ctx.Response.Header.SetContentTypeBytes(contentType)
}</span>

// FormFile returns the first file for the provided form key.
func (ctx *RequestContext) FormFile(name string) (*multipart.FileHeader, error) <span class="cov8" title="1">{
        return ctx.Request.FormFile(name)
}</span>

// FormValue returns form value associated with the given key.
//
// The value is searched in the following places:
//
//   - Query string.
//   - POST or PUT body.
//
// There are more fine-grained methods for obtaining form values:
//
//   - QueryArgs for obtaining values from query string.
//   - PostArgs for obtaining values from POST or PUT body.
//   - MultipartForm for obtaining values from multipart form.
//   - FormFile for obtaining uploaded files.
//
// The returned value is valid until returning from RequestHandler.
// Use engine.SetCustomFormValueFunc to change action of FormValue.
func (ctx *RequestContext) FormValue(key string) []byte <span class="cov8" title="1">{
        if ctx.formValueFunc != nil </span><span class="cov8" title="1">{
                return ctx.formValueFunc(ctx, key)
        }</span>
        <span class="cov8" title="1">return defaultFormValue(ctx, key)</span>
}

func (ctx *RequestContext) multipartFormValue(key string) (string, bool) <span class="cov8" title="1">{
        mf, err := ctx.MultipartForm()
        if err == nil &amp;&amp; mf.Value != nil </span><span class="cov8" title="1">{
                vv := mf.Value[key]
                if len(vv) &gt; 0 </span><span class="cov8" title="1">{
                        return vv[0], true
                }</span>
        }
        <span class="cov8" title="1">return "", false</span>
}

func (ctx *RequestContext) multipartFormValueArray(key string) ([]string, bool) <span class="cov8" title="1">{
        mf, err := ctx.MultipartForm()
        if err == nil &amp;&amp; mf.Value != nil </span><span class="cov8" title="1">{
                vv := mf.Value[key]
                if len(vv) &gt; 0 </span><span class="cov8" title="1">{
                        return vv, true
                }</span>
        }
        <span class="cov0" title="0">return nil, false</span>
}

func (ctx *RequestContext) RequestBodyStream() io.Reader <span class="cov8" title="1">{
        return ctx.Request.BodyStream()
}</span>

// MultipartForm returns request's multipart form.
//
// Returns errNoMultipartForm if request's content-type
// isn't 'multipart/form-data'.
//
// All uploaded temporary files are automatically deleted after
// returning from RequestHandler. Either move or copy uploaded files
// into new place if you want retaining them.
//
// Use SaveMultipartFile function for permanently saving uploaded file.
//
// The returned form is valid until returning from RequestHandler.
//
// See also FormFile and FormValue.
func (ctx *RequestContext) MultipartForm() (*multipart.Form, error) <span class="cov8" title="1">{
        return ctx.Request.MultipartForm()
}</span>

// SaveUploadedFile uploads the form file to specific dst.
func (ctx *RequestContext) SaveUploadedFile(file *multipart.FileHeader, dst string) error <span class="cov8" title="1">{
        src, err := file.Open()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer src.Close()

        out, err := os.Create(dst)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer out.Close()

        _, err = io.Copy(out, src)
        return err</span>
}

// SetConnectionClose sets 'Connection: close' response header.
func (ctx *RequestContext) SetConnectionClose() <span class="cov8" title="1">{
        ctx.Response.SetConnectionClose()
}</span>

// IsGet returns true if request method is GET.
func (ctx *RequestContext) IsGet() bool <span class="cov8" title="1">{
        return ctx.Request.Header.IsGet()
}</span>

// IsHead returns true if request method is HEAD.
func (ctx *RequestContext) IsHead() bool <span class="cov8" title="1">{
        return ctx.Request.Header.IsHead()
}</span>

// IsPost returns true if request method is POST.
func (ctx *RequestContext) IsPost() bool <span class="cov8" title="1">{
        return ctx.Request.Header.IsPost()
}</span>

// Method return request method.
//
// Returned value is valid until returning from RequestHandler.
func (ctx *RequestContext) Method() []byte <span class="cov8" title="1">{
        return ctx.Request.Header.Method()
}</span>

// NotFound resets response and sets '404 Not Found' response status code.
func (ctx *RequestContext) NotFound() <span class="cov8" title="1">{
        ctx.Response.Reset()
        ctx.SetStatusCode(consts.StatusNotFound)
        ctx.SetBodyString(consts.StatusMessage(consts.StatusNotFound))
}</span>

func (ctx *RequestContext) redirect(uri []byte, statusCode int) <span class="cov8" title="1">{
        ctx.Response.Header.SetCanonical(bytestr.StrLocation, uri)
        statusCode = getRedirectStatusCode(statusCode)
        ctx.Response.SetStatusCode(statusCode)
}</span>

func getRedirectStatusCode(statusCode int) int <span class="cov8" title="1">{
        if statusCode == consts.StatusMovedPermanently || statusCode == consts.StatusFound ||
                statusCode == consts.StatusSeeOther || statusCode == consts.StatusTemporaryRedirect ||
                statusCode == consts.StatusPermanentRedirect </span><span class="cov8" title="1">{
                return statusCode
        }</span>
        <span class="cov8" title="1">return consts.StatusFound</span>
}

// Copy returns a copy of the current context that can be safely used outside
// the request's scope.
//
// NOTE: If you want to pass requestContext to a goroutine, call this method
// to get a copy of requestContext.
func (ctx *RequestContext) Copy() *RequestContext <span class="cov8" title="1">{
        cp := &amp;RequestContext{
                conn:   ctx.conn,
                Params: ctx.Params,
        }
        ctx.Request.CopyTo(&amp;cp.Request)
        ctx.Response.CopyTo(&amp;cp.Response)
        cp.index = rConsts.AbortIndex
        cp.handlers = nil
        cp.Keys = map[string]interface{}{}
        ctx.mu.RLock()
        for k, v := range ctx.Keys </span><span class="cov8" title="1">{
                cp.Keys[k] = v
        }</span>
        <span class="cov8" title="1">ctx.mu.RUnlock()
        paramCopy := make([]param.Param, len(cp.Params))
        copy(paramCopy, cp.Params)
        cp.Params = paramCopy
        cp.fullPath = ctx.fullPath
        cp.clientIPFunc = ctx.clientIPFunc
        cp.formValueFunc = ctx.formValueFunc
        cp.binder = ctx.binder
        cp.validator = ctx.validator
        return cp</span>
}

// Next should be used only inside middleware.
// It executes the pending handlers in the chain inside the calling handler.
func (ctx *RequestContext) Next(c context.Context) <span class="cov8" title="1">{
        ctx.index++
        for ctx.index &lt; int8(len(ctx.handlers)) </span><span class="cov8" title="1">{
                ctx.handlers[ctx.index](c, ctx)
                ctx.index++
        }</span>
}

// Handler returns the main handler.
func (ctx *RequestContext) Handler() HandlerFunc <span class="cov8" title="1">{
        return ctx.handlers.Last()
}</span>

// Handlers returns the handler chain.
func (ctx *RequestContext) Handlers() HandlersChain <span class="cov8" title="1">{
        return ctx.handlers
}</span>

func (ctx *RequestContext) SetHandlers(hc HandlersChain) <span class="cov8" title="1">{
        ctx.handlers = hc
}</span>

// HandlerName returns the main handler's name.
//
// For example if the handler is "handleGetUsers()", this function will return "main.handleGetUsers".
func (ctx *RequestContext) HandlerName() string <span class="cov8" title="1">{
        return utils.NameOfFunction(ctx.handlers.Last())
}</span>

func (ctx *RequestContext) ResetWithoutConn() <span class="cov8" title="1">{
        ctx.Params = ctx.Params[0:0]
        ctx.Errors = ctx.Errors[0:0]
        ctx.handlers = nil
        ctx.index = -1
        ctx.fullPath = ""
        ctx.Keys = nil

        if ctx.finished != nil </span><span class="cov8" title="1">{
                close(ctx.finished)
                ctx.finished = nil
        }</span>

        <span class="cov8" title="1">ctx.Request.ResetWithoutConn()
        ctx.Response.Reset()
        if ctx.IsEnableTrace() </span><span class="cov0" title="0">{
                ctx.traceInfo.Reset()
        }</span>
}

// Reset resets requestContext.
//
// NOTE: It is an internal function. You should not use it.
func (ctx *RequestContext) Reset() <span class="cov8" title="1">{
        ctx.ResetWithoutConn()
        ctx.conn = nil
}</span>

// Redirect returns an HTTP redirect to the specific location.
// Note that this will not stop the current handler.
// In other words, even if Redirect() is called, the remaining handlers will still be executed and cause unexpected result.
// So it should call Abort to ensure the remaining handlers of this request will not be called.
//
//        ctx.Abort()
//        return
func (ctx *RequestContext) Redirect(statusCode int, uri []byte) <span class="cov8" title="1">{
        ctx.redirect(uri, statusCode)
}</span>

// Header is an intelligent shortcut for ctx.Response.Header.Set(key, value).
// It writes a header in the response.
// If value == "", this method removes the header `ctx.Response.Header.Del(key)`.
func (ctx *RequestContext) Header(key, value string) <span class="cov8" title="1">{
        if value == "" </span><span class="cov8" title="1">{
                ctx.Response.Header.Del(key)
                return
        }</span>
        <span class="cov8" title="1">ctx.Response.Header.Set(key, value)</span>
}

// Set is used to store a new key/value pair exclusively for this context.
// It also lazy initializes  c.Keys if it was not used previously.
func (ctx *RequestContext) Set(key string, value interface{}) <span class="cov8" title="1">{
        ctx.mu.Lock()
        if ctx.Keys == nil </span><span class="cov8" title="1">{
                ctx.Keys = make(map[string]interface{})
        }</span>

        <span class="cov8" title="1">ctx.Keys[key] = value
        ctx.mu.Unlock()</span>
}

// Get returns the value for the given key, ie: (value, true).
// If the value does not exist it returns (nil, false)
func (ctx *RequestContext) Get(key string) (value interface{}, exists bool) <span class="cov8" title="1">{
        ctx.mu.RLock()
        value, exists = ctx.Keys[key]
        ctx.mu.RUnlock()
        return
}</span>

// MustGet returns the value for the given key if it exists, otherwise it panics.
func (ctx *RequestContext) MustGet(key string) interface{} <span class="cov8" title="1">{
        if value, exists := ctx.Get(key); exists </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov8" title="1">panic("Key \"" + key + "\" does not exist")</span>
}

// GetString returns the value associated with the key as a string. Return "" when type is error.
func (ctx *RequestContext) GetString(key string) (s string) <span class="cov8" title="1">{
        if val, ok := ctx.Get(key); ok &amp;&amp; val != nil </span><span class="cov8" title="1">{
                s, _ = val.(string)
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetBool returns the value associated with the key as a boolean. Return false when type is error.
func (ctx *RequestContext) GetBool(key string) (b bool) <span class="cov8" title="1">{
        if val, ok := ctx.Get(key); ok &amp;&amp; val != nil </span><span class="cov8" title="1">{
                b, _ = val.(bool)
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetInt returns the value associated with the key as an integer. Return 0 when type is error.
func (ctx *RequestContext) GetInt(key string) (i int) <span class="cov8" title="1">{
        if val, ok := ctx.Get(key); ok &amp;&amp; val != nil </span><span class="cov8" title="1">{
                i, _ = val.(int)
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetInt32 returns the value associated with the key as an integer. Return int32(0) when type is error.
func (ctx *RequestContext) GetInt32(key string) (i32 int32) <span class="cov8" title="1">{
        if val, ok := ctx.Get(key); ok &amp;&amp; val != nil </span><span class="cov8" title="1">{
                i32, _ = val.(int32)
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetInt64 returns the value associated with the key as an integer. Return int64(0) when type is error.
func (ctx *RequestContext) GetInt64(key string) (i64 int64) <span class="cov8" title="1">{
        if val, ok := ctx.Get(key); ok &amp;&amp; val != nil </span><span class="cov8" title="1">{
                i64, _ = val.(int64)
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetUint returns the value associated with the key as an unsigned integer. Return uint(0) when type is error.
func (ctx *RequestContext) GetUint(key string) (ui uint) <span class="cov8" title="1">{
        if val, ok := ctx.Get(key); ok &amp;&amp; val != nil </span><span class="cov8" title="1">{
                ui, _ = val.(uint)
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetUint32 returns the value associated with the key as an unsigned integer. Return uint32(0) when type is error.
func (ctx *RequestContext) GetUint32(key string) (ui32 uint32) <span class="cov8" title="1">{
        if val, ok := ctx.Get(key); ok &amp;&amp; val != nil </span><span class="cov8" title="1">{
                ui32, _ = val.(uint32)
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetUint64 returns the value associated with the key as an unsigned integer. Return uint64(0) when type is error.
func (ctx *RequestContext) GetUint64(key string) (ui64 uint64) <span class="cov8" title="1">{
        if val, ok := ctx.Get(key); ok &amp;&amp; val != nil </span><span class="cov8" title="1">{
                ui64, _ = val.(uint64)
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetFloat32 returns the value associated with the key as a float32. Return float32(0.0) when type is error.
func (ctx *RequestContext) GetFloat32(key string) (f32 float32) <span class="cov8" title="1">{
        if val, ok := ctx.Get(key); ok &amp;&amp; val != nil </span><span class="cov8" title="1">{
                f32, _ = val.(float32)
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetFloat64 returns the value associated with the key as a float64. Return 0.0 when type is error.
func (ctx *RequestContext) GetFloat64(key string) (f64 float64) <span class="cov8" title="1">{
        if val, ok := ctx.Get(key); ok &amp;&amp; val != nil </span><span class="cov8" title="1">{
                f64, _ = val.(float64)
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetTime returns the value associated with the key as time. Return time.Time{} when type is error.
func (ctx *RequestContext) GetTime(key string) (t time.Time) <span class="cov8" title="1">{
        if val, ok := ctx.Get(key); ok &amp;&amp; val != nil </span><span class="cov8" title="1">{
                t, _ = val.(time.Time)
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetDuration returns the value associated with the key as a duration. Return time.Duration(0) when type is error.
func (ctx *RequestContext) GetDuration(key string) (d time.Duration) <span class="cov8" title="1">{
        if val, ok := ctx.Get(key); ok &amp;&amp; val != nil </span><span class="cov8" title="1">{
                d, _ = val.(time.Duration)
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetStringSlice returns the value associated with the key as a slice of strings.
//
// Return []string(nil) when type is error.
func (ctx *RequestContext) GetStringSlice(key string) (ss []string) <span class="cov8" title="1">{
        if val, ok := ctx.Get(key); ok &amp;&amp; val != nil </span><span class="cov8" title="1">{
                ss, _ = val.([]string)
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetStringMap returns the value associated with the key as a map of interfaces.
//
// Return map[string]interface{}(nil) when type is error.
func (ctx *RequestContext) GetStringMap(key string) (sm map[string]interface{}) <span class="cov8" title="1">{
        if val, ok := ctx.Get(key); ok &amp;&amp; val != nil </span><span class="cov8" title="1">{
                sm, _ = val.(map[string]interface{})
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetStringMapString returns the value associated with the key as a map of strings.
//
// Return map[string]string(nil) when type is error.
func (ctx *RequestContext) GetStringMapString(key string) (sms map[string]string) <span class="cov8" title="1">{
        if val, ok := ctx.Get(key); ok &amp;&amp; val != nil </span><span class="cov8" title="1">{
                sms, _ = val.(map[string]string)
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetStringMapStringSlice returns the value associated with the key as a map to a slice of strings.
//
// Return map[string][]string(nil) when type is error.
func (ctx *RequestContext) GetStringMapStringSlice(key string) (smss map[string][]string) <span class="cov8" title="1">{
        if val, ok := ctx.Get(key); ok &amp;&amp; val != nil </span><span class="cov8" title="1">{
                smss, _ = val.(map[string][]string)
        }</span>
        <span class="cov8" title="1">return</span>
}

// Param returns the value of the URL param.
// It is a shortcut for c.Params.ByName(key)
//
//        router.GET("/user/:id", func(c context.Context, ctx *app.RequestContext) {
//            // a GET request to /user/john
//            id := ctx.Param("id") // id == "john"
//        })
func (ctx *RequestContext) Param(key string) string <span class="cov0" title="0">{
        return ctx.Params.ByName(key)
}</span>

// Abort prevents pending handlers from being called.
//
// Note that this will not stop the current handler.
// Let's say you have an authorization middleware that validates that the current request is authorized.
// If the authorization fails (ex: the password does not match), call Abort to ensure the remaining handlers
// for this request are not called.
func (ctx *RequestContext) Abort() <span class="cov8" title="1">{
        ctx.index = rConsts.AbortIndex
}</span>

// AbortWithStatus calls `Abort()` and writes the headers with the specified status code.
//
// For example, a failed attempt to authenticate a request could use: context.AbortWithStatus(401).
func (ctx *RequestContext) AbortWithStatus(code int) <span class="cov8" title="1">{
        ctx.SetStatusCode(code)
        ctx.Abort()
}</span>

// AbortWithMsg sets response status code to the given value and sets response body
// to the given message.
//
// Warning: this will reset the response headers and body already set!
func (ctx *RequestContext) AbortWithMsg(msg string, statusCode int) <span class="cov8" title="1">{
        ctx.Response.Reset()
        ctx.SetStatusCode(statusCode)
        ctx.SetContentTypeBytes(bytestr.DefaultContentType)
        ctx.SetBodyString(msg)
        ctx.Abort()
}</span>

// AbortWithStatusJSON calls `Abort()` and then `JSON` internally.
//
// This method stops the chain, writes the status code and return a JSON body.
// It also sets the Content-Type as "application/json".
func (ctx *RequestContext) AbortWithStatusJSON(code int, jsonObj interface{}) <span class="cov8" title="1">{
        ctx.Abort()
        ctx.JSON(code, jsonObj)
}</span>

// Render writes the response headers and calls render.Render to render data.
func (ctx *RequestContext) Render(code int, r render.Render) <span class="cov8" title="1">{
        ctx.SetStatusCode(code)

        if !bodyAllowedForStatus(code) </span><span class="cov8" title="1">{
                r.WriteContentType(&amp;ctx.Response)
                return
        }</span>

        <span class="cov8" title="1">if err := r.Render(&amp;ctx.Response); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// ProtoBuf serializes the given struct as ProtoBuf into the response body.
func (ctx *RequestContext) ProtoBuf(code int, obj interface{}) <span class="cov8" title="1">{
        ctx.Render(code, render.ProtoBuf{Data: obj})
}</span>

// JSON serializes the given struct as JSON into the response body.
//
// It also sets the Content-Type as "application/json".
func (ctx *RequestContext) JSON(code int, obj interface{}) <span class="cov8" title="1">{
        ctx.Render(code, render.JSONRender{Data: obj})
}</span>

// PureJSON serializes the given struct as JSON into the response body.
// PureJSON, unlike JSON, does not replace special html characters with their unicode entities.
func (ctx *RequestContext) PureJSON(code int, obj interface{}) <span class="cov8" title="1">{
        ctx.Render(code, render.PureJSON{Data: obj})
}</span>

// IndentedJSON serializes the given struct as pretty JSON (indented + endlines) into the response body.
// It also sets the Content-Type as "application/json".
func (ctx *RequestContext) IndentedJSON(code int, obj interface{}) <span class="cov8" title="1">{
        ctx.Render(code, render.IndentedJSON{Data: obj})
}</span>

// HTML renders the HTTP template specified by its file name.
//
// It also updates the HTTP code and sets the Content-Type as "text/html".
// See http://golang.org/doc/articles/wiki/
func (ctx *RequestContext) HTML(code int, name string, obj interface{}) <span class="cov8" title="1">{
        instance := ctx.HTMLRender.Instance(name, obj)
        ctx.Render(code, instance)
}</span>

// Data writes some data into the body stream and updates the HTTP code.
func (ctx *RequestContext) Data(code int, contentType string, data []byte) <span class="cov8" title="1">{
        ctx.Render(code, render.Data{
                ContentType: contentType,
                Data:        data,
        })
}</span>

// XML serializes the given struct as XML into the response body.
//
// It also sets the Content-Type as "application/xml".
func (ctx *RequestContext) XML(code int, obj interface{}) <span class="cov8" title="1">{
        ctx.Render(code, render.XML{Data: obj})
}</span>

// AbortWithError calls `AbortWithStatus()` and `Error()` internally.
//
// This method stops the chain, writes the status code and pushes the specified error to `c.Errors`.
// See RequestContext.Error() for more details.
func (ctx *RequestContext) AbortWithError(code int, err error) *errors.Error <span class="cov8" title="1">{
        ctx.AbortWithStatus(code)
        return ctx.Error(err)
}</span>

// IsAborted returns true if the current context has aborted.
func (ctx *RequestContext) IsAborted() bool <span class="cov8" title="1">{
        return ctx.index &gt;= rConsts.AbortIndex
}</span>

// Error attaches an error to the current context. The error is pushed to a list of errors.
//
// It's a good idea to call Error for each error that occurred during the resolution of a request.
// A middleware can be used to collect all the errors and push them to a database together,
// print a log, or append it in the HTTP response.
// Error will panic if err is nil.
func (ctx *RequestContext) Error(err error) *errors.Error <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                panic("err is nil")</span>
        }

        <span class="cov8" title="1">parsedError, ok := err.(*errors.Error)
        if !ok </span><span class="cov8" title="1">{
                parsedError = &amp;errors.Error{
                        Err:  err,
                        Type: errors.ErrorTypePrivate,
                }
        }</span>

        <span class="cov8" title="1">ctx.Errors = append(ctx.Errors, parsedError)
        return parsedError</span>
}

// ContentType returns the Content-Type header of the request.
func (ctx *RequestContext) ContentType() []byte <span class="cov8" title="1">{
        return ctx.Request.Header.ContentType()
}</span>

// Cookie returns the value of the request cookie key.
func (ctx *RequestContext) Cookie(key string) []byte <span class="cov8" title="1">{
        return ctx.Request.Header.Cookie(key)
}</span>

// SetCookie adds a Set-Cookie header to the Response's headers.
//
//        Parameter introduce:
//        name and value is used to set cookie's name and value, eg. Set-Cookie: name=value
//        maxAge is use to set cookie's expiry date, eg. Set-Cookie: name=value; max-age=1
//        path and domain is used to set the scope of a cookie, eg. Set-Cookie: name=value;domain=localhost; path=/;
//        secure and httpOnly is used to sent cookies securely; eg. Set-Cookie: name=value;HttpOnly; secure;
//        sameSite let servers specify whether/when cookies are sent with cross-site requests; eg. Set-Cookie: name=value;HttpOnly; secure; SameSite=Lax;
//
//        For example:
//        1. ctx.SetCookie("user", "hertz", 1, "/", "localhost",protocol.CookieSameSiteLaxMode, true, true)
//        add response header ---&gt;  Set-Cookie: user=hertz; max-age=1; domain=localhost; path=/; HttpOnly; secure; SameSite=Lax;
//        2. ctx.SetCookie("user", "hertz", 10, "/", "localhost",protocol.CookieSameSiteLaxMode, false, false)
//        add response header ---&gt;  Set-Cookie: user=hertz; max-age=10; domain=localhost; path=/; SameSite=Lax;
//        3. ctx.SetCookie("", "hertz", 10, "/", "localhost",protocol.CookieSameSiteLaxMode, false, false)
//        add response header ---&gt;  Set-Cookie: hertz; max-age=10; domain=localhost; path=/; SameSite=Lax;
//        4. ctx.SetCookie("user", "", 10, "/", "localhost",protocol.CookieSameSiteLaxMode, false, false)
//        add response header ---&gt;  Set-Cookie: user=; max-age=10; domain=localhost; path=/; SameSite=Lax;
func (ctx *RequestContext) SetCookie(name, value string, maxAge int, path, domain string, sameSite protocol.CookieSameSite, secure, httpOnly bool) <span class="cov8" title="1">{
        ctx.setCookie(name, value, maxAge, path, domain, sameSite, secure, httpOnly, false)
}</span>

func (ctx *RequestContext) setCookie(name, value string, maxAge int, path, domain string, sameSite protocol.CookieSameSite, secure, httpOnly, partitioned bool) <span class="cov8" title="1">{
        if path == "" </span><span class="cov8" title="1">{
                path = "/"
        }</span>
        <span class="cov8" title="1">cookie := protocol.AcquireCookie()
        defer protocol.ReleaseCookie(cookie)
        cookie.SetKey(name)
        cookie.SetValue(url.QueryEscape(value))
        cookie.SetMaxAge(maxAge)
        cookie.SetPath(path)
        cookie.SetDomain(domain)
        cookie.SetSecure(secure)
        cookie.SetHTTPOnly(httpOnly)
        cookie.SetSameSite(sameSite)
        cookie.SetPartitioned(partitioned)
        ctx.Response.Header.SetCookie(cookie)</span>
}

// SetPartitionedCookie adds a partitioned cookie to the Response's headers.
// Use protocol.CookieSameSiteNoneMode for cross-site cookies to work.
//
// Usage: ctx.SetPartitionedCookie("user", "name", 10, "/", "localhost", protocol.CookieSameSiteNoneMode, true, true)
//
// This adds the response header: Set-Cookie: user=name; Max-Age=10; Domain=localhost; Path=/; HttpOnly; Secure; SameSite=None; Partitioned
func (ctx *RequestContext) SetPartitionedCookie(name, value string, maxAge int, path, domain string, sameSite protocol.CookieSameSite, secure, httpOnly bool) <span class="cov8" title="1">{
        ctx.setCookie(name, value, maxAge, path, domain, sameSite, secure, httpOnly, true)
}</span>

// UserAgent returns the value of the request user_agent.
func (ctx *RequestContext) UserAgent() []byte <span class="cov8" title="1">{
        return ctx.Request.Header.UserAgent()
}</span>

// Status sets the HTTP response code.
func (ctx *RequestContext) Status(code int) <span class="cov8" title="1">{
        ctx.SetStatusCode(code)
}</span>

// GetHeader returns value from request headers.
func (ctx *RequestContext) GetHeader(key string) []byte <span class="cov8" title="1">{
        return ctx.Request.Header.Peek(key)
}</span>

// GetRawData returns body data.
func (ctx *RequestContext) GetRawData() []byte <span class="cov8" title="1">{
        return ctx.Request.Body()
}</span>

// Body returns body data
func (ctx *RequestContext) Body() ([]byte, error) <span class="cov8" title="1">{
        return ctx.Request.BodyE()
}</span>

// ClientIP tries to parse the headers in [X-Real-Ip, X-Forwarded-For].
// It calls RemoteIP() under the hood. If it cannot satisfy the requirements,
// use engine.SetClientIPFunc to inject your own implementation.
func (ctx *RequestContext) ClientIP() string <span class="cov8" title="1">{
        if ctx.clientIPFunc != nil </span><span class="cov8" title="1">{
                return ctx.clientIPFunc(ctx)
        }</span>
        <span class="cov8" title="1">return defaultClientIP(ctx)</span>
}

// QueryArgs returns query arguments from RequestURI.
//
// It doesn't return POST'ed arguments - use PostArgs() for this.
// Returned arguments are valid until returning from RequestHandler.
// See also PostArgs, FormValue and FormFile.
func (ctx *RequestContext) QueryArgs() *protocol.Args <span class="cov8" title="1">{
        return ctx.URI().QueryArgs()
}</span>

// PostArgs returns POST arguments.
//
// It doesn't return query arguments from RequestURI - use QueryArgs for this.
// Returned arguments are valid until returning from RequestHandler.
// See also QueryArgs, FormValue and FormFile.
func (ctx *RequestContext) PostArgs() *protocol.Args <span class="cov8" title="1">{
        return ctx.Request.PostArgs()
}</span>

// Query returns the keyed url query value if it exists, otherwise it returns an empty string `("")`.
//
// For example:
//
//            GET /path?id=1234&amp;name=Manu&amp;value=
//                   c.Query("id") == "1234"
//                   c.Query("name") == "Manu"
//                   c.Query("value") == ""
//                   c.Query("wtf") == ""
func (ctx *RequestContext) Query(key string) string <span class="cov8" title="1">{
        value, _ := ctx.GetQuery(key)
        return value
}</span>

// DefaultQuery returns the keyed url query value if it exists,
// otherwise it returns the specified defaultValue string.
func (ctx *RequestContext) DefaultQuery(key, defaultValue string) string <span class="cov8" title="1">{
        if value, ok := ctx.GetQuery(key); ok </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov8" title="1">return defaultValue</span>
}

// GetQuery returns the keyed url query value
//
// if it exists `(value, true)` (even when the value is an empty string) will be returned,
// otherwise it returns `("", false)`.
// For example:
//
//        GET /?name=Manu&amp;lastname=
//        ("Manu", true) == c.GetQuery("name")
//        ("", false) == c.GetQuery("id")
//        ("", true) == c.GetQuery("lastname")
func (ctx *RequestContext) GetQuery(key string) (string, bool) <span class="cov8" title="1">{
        return ctx.QueryArgs().PeekExists(key)
}</span>

// PostForm returns the specified key from a POST urlencoded form or multipart form
// when it exists, otherwise it returns an empty string `("")`.
func (ctx *RequestContext) PostForm(key string) string <span class="cov8" title="1">{
        value, _ := ctx.GetPostForm(key)
        return value
}</span>

// PostFormArray returns the specified key from a POST urlencoded form or multipart form
// when it exists, otherwise it returns an empty array `([])`.
func (ctx *RequestContext) PostFormArray(key string) []string <span class="cov8" title="1">{
        values, _ := ctx.GetPostFormArray(key)
        return values
}</span>

// DefaultPostForm returns the specified key from a POST urlencoded form or multipart form
// when it exists, otherwise it returns the specified defaultValue string.
//
// See: PostForm() and GetPostForm() for further information.
func (ctx *RequestContext) DefaultPostForm(key, defaultValue string) string <span class="cov8" title="1">{
        if value, ok := ctx.GetPostForm(key); ok </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov8" title="1">return defaultValue</span>
}

// GetPostForm is like PostForm(key). It returns the specified key from a POST urlencoded
// form or multipart form when it exists `(value, true)` (even when the value is an empty string),
// otherwise it returns ("", false).
//
// For example, during a PATCH request to update the user's email:
//
//            email=mail@example.com  --&gt;  ("mail@example.com", true) := GetPostForm("email") // set email to "mail@example.com"
//                   email=                  --&gt;  ("", true) := GetPostForm("email") // set email to ""
//                                    --&gt;  ("", false) := GetPostForm("email") // do nothing with email
func (ctx *RequestContext) GetPostForm(key string) (string, bool) <span class="cov8" title="1">{
        if v, exists := ctx.PostArgs().PeekExists(key); exists </span><span class="cov8" title="1">{
                return v, exists
        }</span>
        <span class="cov8" title="1">return ctx.multipartFormValue(key)</span>
}

// GetPostFormArray is like PostFormArray(key). It returns the specified key from a POST urlencoded
// form or multipart form when it exists `([]string, true)` (even when the value is an empty string),
// otherwise it returns ([]string(nil), false).
//
// For example, during a PATCH request to update the item's tags:
//
//            tag=tag1 tag=tag2 tag=tag3  --&gt;  (["tag1", "tag2", "tag3"], true) := GetPostFormArray("tags") // set tags to ["tag1", "tag2", "tag3"]
//                   tags=                  --&gt;  (nil, true) := GetPostFormArray("tags") // set tags to nil
//                                    --&gt;  (nil, false) := GetPostFormArray("tags") // do nothing with tags
func (ctx *RequestContext) GetPostFormArray(key string) ([]string, bool) <span class="cov8" title="1">{
        vs := ctx.PostArgs().PeekAll(key)
        values := make([]string, len(vs))
        for i, v := range vs </span><span class="cov8" title="1">{
                values[i] = string(v)
        }</span>
        <span class="cov8" title="1">if len(values) == 0 </span><span class="cov8" title="1">{
                return ctx.multipartFormValueArray(key)
        }</span> else<span class="cov8" title="1"> {
                return values, true
        }</span>
}

// bodyAllowedForStatus is a copy of http.bodyAllowedForStatus non-exported function.
func bodyAllowedForStatus(status int) bool <span class="cov8" title="1">{
        switch </span>{
        case status &gt;= 100 &amp;&amp; status &lt;= 199:<span class="cov8" title="1">
                return false</span>
        case status == consts.StatusNoContent:<span class="cov8" title="1">
                return false</span>
        case status == consts.StatusNotModified:<span class="cov8" title="1">
                return false</span>
        }
        <span class="cov8" title="1">return true</span>
}

func (ctx *RequestContext) getBinder() binding.Binder <span class="cov8" title="1">{
        if ctx.binder != nil </span><span class="cov8" title="1">{
                return ctx.binder
        }</span>
        <span class="cov8" title="1">return binding.DefaultBinder()</span>
}

func (ctx *RequestContext) getValidator() binding.StructValidator <span class="cov8" title="1">{
        if ctx.validator != nil </span><span class="cov8" title="1">{
                return ctx.validator
        }</span>
        <span class="cov8" title="1">return binding.DefaultValidator()</span>
}

// BindAndValidate binds data from *RequestContext to obj and validates them if needed.
// NOTE: obj should be a pointer.
func (ctx *RequestContext) BindAndValidate(obj interface{}) error <span class="cov8" title="1">{
        return ctx.getBinder().BindAndValidate(&amp;ctx.Request, obj, ctx.Params)
}</span>

// Bind binds data from *RequestContext to obj.
// NOTE: obj should be a pointer.
func (ctx *RequestContext) Bind(obj interface{}) error <span class="cov8" title="1">{
        return ctx.getBinder().Bind(&amp;ctx.Request, obj, ctx.Params)
}</span>

// Validate validates obj with "vd" tag
// NOTE: obj should be a pointer.
func (ctx *RequestContext) Validate(obj interface{}) error <span class="cov8" title="1">{
        return ctx.getValidator().ValidateStruct(obj)
}</span>

// BindQuery binds query parameters from *RequestContext to obj with 'query' tag. It will only use 'query' tag for binding.
// NOTE: obj should be a pointer.
func (ctx *RequestContext) BindQuery(obj interface{}) error <span class="cov8" title="1">{
        return ctx.getBinder().BindQuery(&amp;ctx.Request, obj)
}</span>

// BindHeader binds header parameters from *RequestContext to obj with 'header' tag. It will only use 'header' tag for binding.
// NOTE: obj should be a pointer.
func (ctx *RequestContext) BindHeader(obj interface{}) error <span class="cov8" title="1">{
        return ctx.getBinder().BindHeader(&amp;ctx.Request, obj)
}</span>

// BindPath binds router parameters from *RequestContext to obj with 'path' tag. It will only use 'path' tag for binding.
// NOTE: obj should be a pointer.
func (ctx *RequestContext) BindPath(obj interface{}) error <span class="cov8" title="1">{
        return ctx.getBinder().BindPath(&amp;ctx.Request, obj, ctx.Params)
}</span>

// BindForm binds form parameters from *RequestContext to obj with 'form' tag. It will only use 'form' tag for binding.
// NOTE: obj should be a pointer.
func (ctx *RequestContext) BindForm(obj interface{}) error <span class="cov8" title="1">{
        if len(ctx.Request.Body()) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("missing form body")
        }</span>
        <span class="cov8" title="1">return ctx.getBinder().BindForm(&amp;ctx.Request, obj)</span>
}

// BindJSON binds JSON body from *RequestContext.
// NOTE: obj should be a pointer.
func (ctx *RequestContext) BindJSON(obj interface{}) error <span class="cov8" title="1">{
        return ctx.getBinder().BindJSON(&amp;ctx.Request, obj)
}</span>

// BindProtobuf binds protobuf body from *RequestContext.
// NOTE: obj should be a pointer.
func (ctx *RequestContext) BindProtobuf(obj interface{}) error <span class="cov8" title="1">{
        return ctx.getBinder().BindProtobuf(&amp;ctx.Request, obj)
}</span>

// BindByContentType will select the binding type on the ContentType automatically.
// NOTE: obj should be a pointer.
func (ctx *RequestContext) BindByContentType(obj interface{}) error <span class="cov0" title="0">{
        if ctx.Request.Header.IsGet() </span><span class="cov0" title="0">{
                return ctx.BindQuery(obj)
        }</span>
        <span class="cov0" title="0">ct := utils.FilterContentType(bytesconv.B2s(ctx.Request.Header.ContentType()))
        switch strings.ToLower(ct) </span>{
        case consts.MIMEApplicationJSON:<span class="cov0" title="0">
                return ctx.BindJSON(obj)</span>
        case consts.MIMEPROTOBUF:<span class="cov0" title="0">
                return ctx.BindProtobuf(obj)</span>
        case consts.MIMEApplicationHTMLForm, consts.MIMEMultipartPOSTForm:<span class="cov0" title="0">
                return ctx.BindForm(obj)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported bind content-type for '%s'", ct)</span>
        }
}

// VisitAllQueryArgs calls f for each existing query arg.
//
// f must not retain references to key and value after returning.
// Make key and/or value copies if you need storing them after returning.
func (ctx *RequestContext) VisitAllQueryArgs(f func(key, value []byte)) <span class="cov8" title="1">{
        ctx.QueryArgs().VisitAll(f)
}</span>

// VisitAllPostArgs calls f for each existing post arg.
//
// f must not retain references to key and value after returning.
// Make key and/or value copies if you need storing them after returning.
func (ctx *RequestContext) VisitAllPostArgs(f func(key, value []byte)) <span class="cov8" title="1">{
        ctx.Request.PostArgs().VisitAll(f)
}</span>

// VisitAllHeaders calls f for each request header.
//
// f must not retain references to key and/or value after returning.
// Copy key and/or value contents before returning if you need retaining them.
//
// To get the headers in order they were received use VisitAllInOrder.
func (ctx *RequestContext) VisitAllHeaders(f func(key, value []byte)) <span class="cov8" title="1">{
        ctx.Request.Header.VisitAll(f)
}</span>

// VisitAllCookie calls f for each request cookie.
//
// f must not retain references to key and/or value after returning.
func (ctx *RequestContext) VisitAllCookie(f func(key, value []byte)) <span class="cov8" title="1">{
        ctx.Request.Header.VisitAllCookie(f)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015-present Aliaksandr Valialkin, VertaMedia, Kirill Danshin, Erik Dubbelboer, FastHTTP Authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This file may have been modified by CloudWeGo authors. All CloudWeGo
 * Modifications are Copyright 2022 CloudWeGo Authors.
 */

package app

import (
        "bytes"
        "compress/gzip"
        "context"
        "fmt"
        "html"
        "io"
        "io/ioutil"
        "mime"
        "net/http"
        "os"
        "path/filepath"
        "sort"
        "strings"
        "sync"
        "time"

        "github.com/cloudwego/hertz/internal/bytesconv"
        "github.com/cloudwego/hertz/internal/bytestr"
        "github.com/cloudwego/hertz/internal/nocopy"
        "github.com/cloudwego/hertz/pkg/common/bytebufferpool"
        "github.com/cloudwego/hertz/pkg/common/compress"
        "github.com/cloudwego/hertz/pkg/common/errors"
        "github.com/cloudwego/hertz/pkg/common/hlog"
        "github.com/cloudwego/hertz/pkg/common/utils"
        "github.com/cloudwego/hertz/pkg/network"
        "github.com/cloudwego/hertz/pkg/protocol"
        "github.com/cloudwego/hertz/pkg/protocol/consts"
)

var (
        errDirIndexRequired   = errors.NewPublic("directory index required")
        errNoCreatePermission = errors.NewPublic("no 'create file' permissions")

        rootFSOnce sync.Once
        rootFS     = &amp;FS{
                Root:               "/",
                GenerateIndexPages: true,
                Compress:           true,
                AcceptByteRange:    true,
        }
        rootFSHandler  HandlerFunc
        strInvalidHost = []byte("invalid-host")
)

// PathRewriteFunc must return new request path based on arbitrary ctx
// info such as ctx.Path().
//
// Path rewriter is used in FS for translating the current request
// to the local filesystem path relative to FS.Root.
//
// The returned path must not contain '/../' substrings due to security reasons,
// since such paths may refer files outside FS.Root.
//
// The returned path may refer to ctx members. For example, ctx.Path().
type PathRewriteFunc func(ctx *RequestContext) []byte

// FS represents settings for request handler serving static files
// from the local filesystem.
//
// It is prohibited copying FS values. Create new values instead.
type FS struct {
        noCopy nocopy.NoCopy //lint:ignore U1000 until noCopy is used

        // Path to the root directory to serve files from.
        Root string

        // List of index file names to try opening during directory access.
        //
        // For example:
        //
        //     * index.html
        //     * index.htm
        //     * my-super-index.xml
        //
        // By default the list is empty.
        IndexNames []string

        // Index pages for directories without files matching IndexNames
        // are automatically generated if set.
        //
        // Directory index generation may be quite slow for directories
        // with many files (more than 1K), so it is discouraged enabling
        // index pages' generation for such directories.
        //
        // By default index pages aren't generated.
        GenerateIndexPages bool

        // Transparently compresses responses if set to true.
        //
        // The server tries minimizing CPU usage by caching compressed files.
        // It adds CompressedFileSuffix suffix to the original file name and
        // tries saving the resulting compressed file under the new file name.
        // So it is advisable to give the server write access to Root
        // and to all inner folders in order to minimize CPU usage when serving
        // compressed responses.
        //
        // Transparent compression is disabled by default.
        Compress bool

        // Enables byte range requests if set to true.
        //
        // Byte range requests are disabled by default.
        AcceptByteRange bool

        // Path rewriting function.
        //
        // By default request path is not modified.
        PathRewrite PathRewriteFunc

        // PathNotFound fires when file is not found in filesystem
        // this functions tries to replace "Cannot open requested path"
        // server response giving to the programmer the control of server flow.
        //
        // By default PathNotFound returns
        // "Cannot open requested path"
        PathNotFound HandlerFunc

        // Expiration duration for inactive file handlers.
        //
        // FSHandlerCacheDuration is used by default.
        CacheDuration time.Duration

        // Suffix to add to the name of cached compressed file.
        //
        // This value has sense only if Compress is set.
        //
        // FSCompressedFileSuffix is used by default.
        CompressedFileSuffix string

        once sync.Once
        h    HandlerFunc
}

type byteRangeUpdater interface {
        UpdateByteRange(startPos, endPos int) error
}

type fsSmallFileReader struct {
        ff       *fsFile
        startPos int
        endPos   int
}

func (r *fsSmallFileReader) Close() error <span class="cov8" title="1">{
        ff := r.ff
        ff.decReadersCount()
        r.ff = nil
        r.startPos = 0
        r.endPos = 0
        ff.h.smallFileReaderPool.Put(r)
        return nil
}</span>

func (r *fsSmallFileReader) UpdateByteRange(startPos, endPos int) error <span class="cov8" title="1">{
        r.startPos = startPos
        r.endPos = endPos + 1
        return nil
}</span>

func (r *fsSmallFileReader) Read(p []byte) (int, error) <span class="cov8" title="1">{
        tailLen := r.endPos - r.startPos
        if tailLen &lt;= 0 </span><span class="cov8" title="1">{
                return 0, io.EOF
        }</span>
        <span class="cov8" title="1">if len(p) &gt; tailLen </span><span class="cov8" title="1">{
                p = p[:tailLen]
        }</span>

        <span class="cov8" title="1">ff := r.ff
        if ff.f != nil </span><span class="cov8" title="1">{
                n, err := ff.f.ReadAt(p, int64(r.startPos))
                r.startPos += n
                return n, err
        }</span>

        <span class="cov8" title="1">n := copy(p, ff.dirIndex[r.startPos:])
        r.startPos += n
        return n, nil</span>
}

func (r *fsSmallFileReader) WriteTo(w io.Writer) (int64, error) <span class="cov8" title="1">{
        ff := r.ff

        var n int
        var err error
        if ff.f == nil </span><span class="cov8" title="1">{
                n, err = w.Write(ff.dirIndex[r.startPos:r.endPos])
                return int64(n), err
        }</span>

        <span class="cov8" title="1">if rf, ok := w.(io.ReaderFrom); ok </span><span class="cov0" title="0">{
                return rf.ReadFrom(r)
        }</span>

        <span class="cov8" title="1">curPos := r.startPos
        bufv := utils.CopyBufPool.Get()
        buf := bufv.([]byte)
        for err == nil </span><span class="cov8" title="1">{
                tailLen := r.endPos - curPos
                if tailLen &lt;= 0 </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">if len(buf) &gt; tailLen </span><span class="cov8" title="1">{
                        buf = buf[:tailLen]
                }</span>
                <span class="cov8" title="1">n, err = ff.f.ReadAt(buf, int64(curPos))
                nw, errw := w.Write(buf[:n])
                curPos += nw
                if errw == nil &amp;&amp; nw != n </span><span class="cov0" title="0">{
                        panic("BUG: Write(p) returned (n, nil), where n != len(p)")</span>
                }
                <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                        err = errw
                }</span>
        }
        <span class="cov8" title="1">utils.CopyBufPool.Put(bufv)

        if err == io.EOF </span><span class="cov0" title="0">{
                err = nil
        }</span>
        <span class="cov8" title="1">return int64(curPos - r.startPos), err</span>
}

// ServeFile returns HTTP response containing compressed file contents
// from the given path.
//
// HTTP response may contain uncompressed file contents in the following cases:
//
//   - Missing 'Accept-Encoding: gzip' request header.
//   - No write access to directory containing the file.
//
// Directory contents is returned if path points to directory.
//
// Use ServeFileUncompressed is you don't need serving compressed file contents.
func ServeFile(ctx *RequestContext, path string) <span class="cov8" title="1">{
        rootFSOnce.Do(func() </span><span class="cov8" title="1">{
                rootFSHandler = rootFS.NewRequestHandler()
        }</span>)
        <span class="cov8" title="1">if len(path) == 0 || path[0] != '/' </span><span class="cov8" title="1">{
                // extend relative path to absolute path
                var err error
                if path, err = filepath.Abs(path); err != nil </span><span class="cov0" title="0">{
                        hlog.SystemLogger().Errorf("Cannot resolve path=%q to absolute file error=%s", path, err)
                        ctx.AbortWithMsg("Internal Server Error", consts.StatusInternalServerError)
                        return
                }</span>
        }
        <span class="cov8" title="1">ctx.Request.SetRequestURI(path)
        rootFSHandler(context.Background(), ctx)</span>
}

// NewRequestHandler returns new request handler with the given FS settings.
//
// The returned handler caches requested file handles
// for FS.CacheDuration.
// Make sure your program has enough 'max open files' limit aka
// 'ulimit -n' if FS.Root folder contains many files.
//
// Do not create multiple request handlers from a single FS instance -
// just reuse a single request handler.
func (fs *FS) NewRequestHandler() HandlerFunc <span class="cov8" title="1">{
        fs.once.Do(fs.initRequestHandler)
        return fs.h
}</span>

func (fs *FS) initRequestHandler() <span class="cov8" title="1">{
        root := fs.Root

        // serve files from the current working directory if root is empty
        if len(root) == 0 </span><span class="cov0" title="0">{
                root = "."
        }</span>

        // strip trailing slashes from the root path
        <span class="cov8" title="1">for len(root) &gt; 0 &amp;&amp; root[len(root)-1] == '/' </span><span class="cov8" title="1">{
                root = root[:len(root)-1]
        }</span>

        <span class="cov8" title="1">cacheDuration := fs.CacheDuration
        if cacheDuration &lt;= 0 </span><span class="cov8" title="1">{
                cacheDuration = consts.FSHandlerCacheDuration
        }</span>
        <span class="cov8" title="1">compressedFileSuffix := fs.CompressedFileSuffix
        if len(compressedFileSuffix) == 0 </span><span class="cov8" title="1">{
                compressedFileSuffix = consts.FSCompressedFileSuffix
        }</span>

        <span class="cov8" title="1">h := &amp;fsHandler{
                root:                 root,
                indexNames:           fs.IndexNames,
                pathRewrite:          fs.PathRewrite,
                generateIndexPages:   fs.GenerateIndexPages,
                compress:             fs.Compress,
                pathNotFound:         fs.PathNotFound,
                acceptByteRange:      fs.AcceptByteRange,
                cacheDuration:        cacheDuration,
                compressedFileSuffix: compressedFileSuffix,
                cache:                make(map[string]*fsFile),
                compressedCache:      make(map[string]*fsFile),
        }

        go func() </span><span class="cov8" title="1">{
                var pendingFiles []*fsFile
                for </span><span class="cov8" title="1">{
                        time.Sleep(cacheDuration / 2)
                        pendingFiles = h.cleanCache(pendingFiles)
                }</span>
        }()

        <span class="cov8" title="1">fs.h = h.handleRequest</span>
}

type fsHandler struct {
        root                 string
        indexNames           []string
        pathRewrite          PathRewriteFunc
        pathNotFound         HandlerFunc
        generateIndexPages   bool
        compress             bool
        acceptByteRange      bool
        cacheDuration        time.Duration
        compressedFileSuffix string

        cache           map[string]*fsFile
        compressedCache map[string]*fsFile
        cacheLock       sync.Mutex

        smallFileReaderPool sync.Pool
}

// bigFileReader attempts to trigger sendfile
// for sending big files over the wire.
type bigFileReader struct {
        f  *os.File
        ff *fsFile
        r  io.Reader
        lr io.LimitedReader
}

func (r *bigFileReader) UpdateByteRange(startPos, endPos int) error <span class="cov8" title="1">{
        if _, err := r.f.Seek(int64(startPos), 0); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">r.r = &amp;r.lr
        r.lr.R = r.f
        r.lr.N = int64(endPos - startPos + 1)
        return nil</span>
}

func (r *bigFileReader) Read(p []byte) (int, error) <span class="cov8" title="1">{
        return r.r.Read(p)
}</span>

func (r *bigFileReader) WriteTo(w io.Writer) (int64, error) <span class="cov0" title="0">{
        if rf, ok := w.(io.ReaderFrom); ok </span><span class="cov0" title="0">{
                // fast path. Sendfile must be triggered
                return rf.ReadFrom(r.r)
        }</span>
        <span class="cov0" title="0">zw := network.NewWriter(w)
        // slow pathw
        return utils.CopyZeroAlloc(zw, r.r)</span>
}

func (r *bigFileReader) Close() error <span class="cov8" title="1">{
        r.r = r.f
        n, err := r.f.Seek(0, 0)
        if err == nil </span><span class="cov8" title="1">{
                if n != 0 </span><span class="cov0" title="0">{
                        panic("BUG: File.Seek(0,0) returned (non-zero, nil)")</span>
                }

                <span class="cov8" title="1">ff := r.ff
                ff.bigFilesLock.Lock()
                ff.bigFiles = append(ff.bigFiles, r)
                ff.bigFilesLock.Unlock()</span>
        } else<span class="cov0" title="0"> {
                r.f.Close()
        }</span>
        <span class="cov8" title="1">r.ff.decReadersCount()
        return err</span>
}

func (h *fsHandler) cleanCache(pendingFiles []*fsFile) []*fsFile <span class="cov0" title="0">{
        var filesToRelease []*fsFile

        h.cacheLock.Lock()

        // Close files which couldn't be closed before due to non-zero
        // readers count on the previous run.
        var remainingFiles []*fsFile
        for _, ff := range pendingFiles </span><span class="cov0" title="0">{
                if ff.readersCount &gt; 0 </span><span class="cov0" title="0">{
                        remainingFiles = append(remainingFiles, ff)
                }</span> else<span class="cov0" title="0"> {
                        filesToRelease = append(filesToRelease, ff)
                }</span>
        }
        <span class="cov0" title="0">pendingFiles = remainingFiles

        pendingFiles, filesToRelease = cleanCacheNolock(h.cache, pendingFiles, filesToRelease, h.cacheDuration)
        pendingFiles, filesToRelease = cleanCacheNolock(h.compressedCache, pendingFiles, filesToRelease, h.cacheDuration)

        h.cacheLock.Unlock()

        for _, ff := range filesToRelease </span><span class="cov0" title="0">{
                ff.Release()
        }</span>

        <span class="cov0" title="0">return pendingFiles</span>
}

func (h *fsHandler) compressAndOpenFSFile(filePath string) (*fsFile, error) <span class="cov8" title="1">{
        f, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">fileInfo, err := f.Stat()
        if err != nil </span><span class="cov0" title="0">{
                f.Close()
                return nil, fmt.Errorf("cannot obtain info for file %q: %s", filePath, err)
        }</span>

        <span class="cov8" title="1">if fileInfo.IsDir() </span><span class="cov8" title="1">{
                f.Close()
                return nil, errDirIndexRequired
        }</span>

        <span class="cov0" title="0">if strings.HasSuffix(filePath, h.compressedFileSuffix) ||
                fileInfo.Size() &gt; consts.FsMaxCompressibleFileSize ||
                !isFileCompressible(f, consts.FsMinCompressRatio) </span><span class="cov0" title="0">{
                return h.newFSFile(f, fileInfo, false)
        }</span>

        <span class="cov0" title="0">compressedFilePath := filePath + h.compressedFileSuffix
        absPath, err := filepath.Abs(compressedFilePath)
        if err != nil </span><span class="cov0" title="0">{
                f.Close()
                return nil, fmt.Errorf("cannot determine absolute path for %q: %s", compressedFilePath, err)
        }</span>

        <span class="cov0" title="0">flock := getFileLock(absPath)
        flock.Lock()
        ff, err := h.compressFileNolock(f, fileInfo, filePath, compressedFilePath)
        flock.Unlock()

        return ff, err</span>
}

func (h *fsHandler) newCompressedFSFile(filePath string) (*fsFile, error) <span class="cov0" title="0">{
        f, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot open compressed file %q: %s", filePath, err)
        }</span>
        <span class="cov0" title="0">fileInfo, err := f.Stat()
        if err != nil </span><span class="cov0" title="0">{
                f.Close()
                return nil, fmt.Errorf("cannot obtain info for compressed file %q: %s", filePath, err)
        }</span>
        <span class="cov0" title="0">return h.newFSFile(f, fileInfo, true)</span>
}

func (h *fsHandler) compressFileNolock(f *os.File, fileInfo os.FileInfo, filePath, compressedFilePath string) (*fsFile, error) <span class="cov0" title="0">{
        // Attempt to open compressed file created by another concurrent
        // goroutine.
        // It is safe opening such a file, since the file creation
        // is guarded by file mutex - see getFileLock call.
        if _, err := os.Stat(compressedFilePath); err == nil </span><span class="cov0" title="0">{
                f.Close()
                return h.newCompressedFSFile(compressedFilePath)
        }</span>

        // Create temporary file, so concurrent goroutines don't use
        // it until it is created.
        <span class="cov0" title="0">tmpFilePath := compressedFilePath + ".tmp"
        zf, err := os.Create(tmpFilePath)
        if err != nil </span><span class="cov0" title="0">{
                f.Close()
                if !os.IsPermission(err) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cannot create temporary file %q: %s", tmpFilePath, err)
                }</span>
                <span class="cov0" title="0">return nil, errNoCreatePermission</span>
        }

        <span class="cov0" title="0">zw := compress.AcquireStacklessGzipWriter(zf, compress.CompressDefaultCompression)
        zrw := network.NewWriter(zw)
        _, err = utils.CopyZeroAlloc(zrw, f)
        if err1 := zw.Flush(); err == nil </span><span class="cov0" title="0">{
                err = err1
        }</span>
        <span class="cov0" title="0">compress.ReleaseStacklessGzipWriter(zw, compress.CompressDefaultCompression)
        zf.Close()
        f.Close()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error when compressing file %q to %q: %s", filePath, tmpFilePath, err)
        }</span>
        <span class="cov0" title="0">if err = os.Chtimes(tmpFilePath, time.Now(), fileInfo.ModTime()); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot change modification time to %s for tmp file %q: %s",
                        fileInfo.ModTime(), tmpFilePath, err)
        }</span>
        <span class="cov0" title="0">if err = os.Rename(tmpFilePath, compressedFilePath); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot move compressed file from %q to %q: %s", tmpFilePath, compressedFilePath, err)
        }</span>
        <span class="cov0" title="0">return h.newCompressedFSFile(compressedFilePath)</span>
}

func (h *fsHandler) openFSFile(filePath string, mustCompress bool) (*fsFile, error) <span class="cov8" title="1">{
        filePathOriginal := filePath
        if mustCompress </span><span class="cov8" title="1">{
                filePath += h.compressedFileSuffix
        }</span>

        <span class="cov8" title="1">f, err := os.Open(filePath)
        if err != nil </span><span class="cov8" title="1">{
                if mustCompress &amp;&amp; os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return h.compressAndOpenFSFile(filePathOriginal)
                }</span>
                <span class="cov8" title="1">return nil, err</span>
        }

        <span class="cov8" title="1">fileInfo, err := f.Stat()
        if err != nil </span><span class="cov0" title="0">{
                f.Close()
                return nil, fmt.Errorf("cannot obtain info for file %q: %s", filePath, err)
        }</span>

        <span class="cov8" title="1">if fileInfo.IsDir() </span><span class="cov8" title="1">{
                f.Close()
                if mustCompress </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("directory with unexpected suffix found: %q. Suffix: %q",
                                filePath, h.compressedFileSuffix)
                }</span>
                <span class="cov8" title="1">return nil, errDirIndexRequired</span>
        }

        <span class="cov8" title="1">if mustCompress </span><span class="cov8" title="1">{
                fileInfoOriginal, err := os.Stat(filePathOriginal)
                if err != nil </span><span class="cov0" title="0">{
                        f.Close()
                        return nil, fmt.Errorf("cannot obtain info for original file %q: %s", filePathOriginal, err)
                }</span>

                <span class="cov8" title="1">if fileInfoOriginal.ModTime() != fileInfo.ModTime() </span><span class="cov0" title="0">{
                        // The compressed file became stale. Re-create it.
                        f.Close()
                        os.Remove(filePath)
                        return h.compressAndOpenFSFile(filePathOriginal)
                }</span>
        }

        <span class="cov8" title="1">return h.newFSFile(f, fileInfo, mustCompress)</span>
}

func (h *fsHandler) newFSFile(f *os.File, fileInfo os.FileInfo, compressed bool) (*fsFile, error) <span class="cov8" title="1">{
        n := fileInfo.Size()
        contentLength := int(n)
        if n != int64(contentLength) </span><span class="cov0" title="0">{
                f.Close()
                return nil, fmt.Errorf("too big file: %d bytes", n)
        }</span>

        // detect content-type
        <span class="cov8" title="1">ext := fileExtension(fileInfo.Name(), compressed, h.compressedFileSuffix)
        contentType := mime.TypeByExtension(ext)
        if len(contentType) == 0 </span><span class="cov8" title="1">{
                data, err := readFileHeader(f, compressed)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cannot read header of the file %q: %s", f.Name(), err)
                }</span>
                <span class="cov8" title="1">contentType = http.DetectContentType(data)</span>
        }

        <span class="cov8" title="1">lastModified := fileInfo.ModTime()
        ff := &amp;fsFile{
                h:               h,
                f:               f,
                contentType:     contentType,
                contentLength:   contentLength,
                compressed:      compressed,
                lastModified:    lastModified,
                lastModifiedStr: bytesconv.AppendHTTPDate(make([]byte, 0, len(http.TimeFormat)), lastModified),

                t: time.Now(),
        }
        return ff, nil</span>
}

func (h *fsHandler) createDirIndex(base *protocol.URI, dirPath string, mustCompress bool) (*fsFile, error) <span class="cov8" title="1">{
        w := &amp;bytebufferpool.ByteBuffer{}

        basePathEscaped := html.EscapeString(string(base.Path()))
        fmt.Fprintf(w, "&lt;html&gt;&lt;head&gt;&lt;title&gt;%s&lt;/title&gt;&lt;style&gt;.dir { font-weight: bold }&lt;/style&gt;&lt;/head&gt;&lt;body&gt;", basePathEscaped)
        fmt.Fprintf(w, "&lt;h1&gt;%s&lt;/h1&gt;", basePathEscaped)
        fmt.Fprintf(w, "&lt;ul&gt;")

        if len(basePathEscaped) &gt; 1 </span><span class="cov0" title="0">{
                var parentURI protocol.URI
                base.CopyTo(&amp;parentURI)
                parentURI.Update(string(base.Path()) + "/..")
                parentPathEscaped := html.EscapeString(string(parentURI.Path()))
                fmt.Fprintf(w, `&lt;li&gt;&lt;a href="%s" class="dir"&gt;..&lt;/a&gt;&lt;/li&gt;`, parentPathEscaped)
        }</span>

        <span class="cov8" title="1">f, err := os.Open(dirPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">fileinfos, err := f.Readdir(0)
        f.Close()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">fm := make(map[string]os.FileInfo, len(fileinfos))
        filenames := make([]string, 0, len(fileinfos))
        for _, fi := range fileinfos </span><span class="cov8" title="1">{
                name := fi.Name()
                if strings.HasSuffix(name, h.compressedFileSuffix) </span><span class="cov8" title="1">{
                        // Do not show compressed files on index page.
                        continue</span>
                }
                <span class="cov8" title="1">fm[name] = fi
                filenames = append(filenames, name)</span>
        }

        <span class="cov8" title="1">var u protocol.URI
        base.CopyTo(&amp;u)
        u.Update(string(u.Path()) + "/")

        sort.Strings(filenames)
        for _, name := range filenames </span><span class="cov8" title="1">{
                u.Update(name)
                pathEscaped := html.EscapeString(string(u.Path()))
                fi := fm[name]
                auxStr := "dir"
                className := "dir"
                if !fi.IsDir() </span><span class="cov8" title="1">{
                        auxStr = fmt.Sprintf("file, %d bytes", fi.Size())
                        className = "file"
                }</span>
                <span class="cov8" title="1">fmt.Fprintf(w, `&lt;li&gt;&lt;a href="%s" class="%s"&gt;%s&lt;/a&gt;, %s, last modified %s&lt;/li&gt;`,
                        pathEscaped, className, html.EscapeString(name), auxStr, fsModTime(fi.ModTime()))</span>
        }

        <span class="cov8" title="1">fmt.Fprintf(w, "&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;")
        if mustCompress </span><span class="cov8" title="1">{
                var zbuf bytebufferpool.ByteBuffer
                zbuf.B = compress.AppendGzipBytesLevel(zbuf.B, w.B, compress.CompressDefaultCompression)
                w = &amp;zbuf
        }</span>

        <span class="cov8" title="1">dirIndex := w.B
        lastModified := time.Now()
        ff := &amp;fsFile{
                h:               h,
                dirIndex:        dirIndex,
                contentType:     "text/html; charset=utf-8",
                contentLength:   len(dirIndex),
                compressed:      mustCompress,
                lastModified:    lastModified,
                lastModifiedStr: bytesconv.AppendHTTPDate(make([]byte, 0, len(http.TimeFormat)), lastModified),

                t: lastModified,
        }
        return ff, nil</span>
}

func (h *fsHandler) openIndexFile(ctx *RequestContext, dirPath string, mustCompress bool) (*fsFile, error) <span class="cov8" title="1">{
        for _, indexName := range h.indexNames </span><span class="cov0" title="0">{
                indexFilePath := dirPath + "/" + indexName
                ff, err := h.openFSFile(indexFilePath, mustCompress)
                if err == nil </span><span class="cov0" title="0">{
                        return ff, nil
                }</span>
                <span class="cov0" title="0">if !os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cannot open file %q: %s", indexFilePath, err)
                }</span>
        }

        <span class="cov8" title="1">if !h.generateIndexPages </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot access directory without index page. Directory %q", dirPath)
        }</span>

        <span class="cov8" title="1">return h.createDirIndex(ctx.URI(), dirPath, mustCompress)</span>
}

func (ff *fsFile) decReadersCount() <span class="cov8" title="1">{
        ff.h.cacheLock.Lock()
        defer ff.h.cacheLock.Unlock()
        ff.readersCount--
        if ff.readersCount &lt; 0 </span><span class="cov0" title="0">{
                panic("BUG: negative fsFile.readersCount!")</span>
        }
}

func (ff *fsFile) bigFileReader() (io.Reader, error) <span class="cov8" title="1">{
        if ff.f == nil </span><span class="cov0" title="0">{
                panic("BUG: ff.f must be non-nil in bigFileReader")</span>
        }

        <span class="cov8" title="1">var r io.Reader

        ff.bigFilesLock.Lock()
        n := len(ff.bigFiles)
        if n &gt; 0 </span><span class="cov8" title="1">{
                r = ff.bigFiles[n-1]
                ff.bigFiles = ff.bigFiles[:n-1]
        }</span>
        <span class="cov8" title="1">ff.bigFilesLock.Unlock()

        if r != nil </span><span class="cov8" title="1">{
                return r, nil
        }</span>

        <span class="cov8" title="1">f, err := os.Open(ff.f.Name())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot open already opened file: %s", err)
        }</span>
        <span class="cov8" title="1">return &amp;bigFileReader{
                f:  f,
                ff: ff,
                r:  f,
        }, nil</span>
}

func (ff *fsFile) NewReader() (io.Reader, error) <span class="cov8" title="1">{
        if ff.isBig() </span><span class="cov8" title="1">{
                r, err := ff.bigFileReader()
                if err != nil </span><span class="cov0" title="0">{
                        ff.decReadersCount()
                }</span>
                <span class="cov8" title="1">return r, err</span>
        }
        <span class="cov8" title="1">return ff.smallFileReader(), nil</span>
}

func (ff *fsFile) smallFileReader() io.Reader <span class="cov8" title="1">{
        v := ff.h.smallFileReaderPool.Get()
        if v == nil </span><span class="cov8" title="1">{
                v = &amp;fsSmallFileReader{}
        }</span>
        <span class="cov8" title="1">r := v.(*fsSmallFileReader)
        r.ff = ff
        r.endPos = ff.contentLength
        if r.startPos &gt; 0 </span><span class="cov0" title="0">{
                panic("BUG: fsSmallFileReader with non-nil startPos found in the pool")</span>
        }
        <span class="cov8" title="1">return r</span>
}

func (h *fsHandler) handleRequest(c context.Context, ctx *RequestContext) <span class="cov8" title="1">{
        var path []byte
        if h.pathRewrite != nil </span><span class="cov0" title="0">{
                path = h.pathRewrite(ctx)
        }</span> else<span class="cov8" title="1"> {
                path = ctx.Path()
        }</span>
        <span class="cov8" title="1">path = stripTrailingSlashes(path)

        if n := bytes.IndexByte(path, 0); n &gt;= 0 </span><span class="cov0" title="0">{
                hlog.SystemLogger().Errorf("Cannot serve path with nil byte at position=%d, path=%q", n, path)
                ctx.AbortWithMsg("Are you a hacker?", consts.StatusBadRequest)
                return
        }</span>
        <span class="cov8" title="1">if h.pathRewrite != nil </span><span class="cov0" title="0">{
                // There is no need to check for '/../' if path = ctx.Path(),
                // since ctx.Path must normalize and sanitize the path.

                if n := bytes.Index(path, bytestr.StrSlashDotDotSlash); n &gt;= 0 </span><span class="cov0" title="0">{
                        hlog.SystemLogger().Errorf("Cannot serve path with '/../' at position=%d due to security reasons, path=%q", n, path)
                        ctx.AbortWithMsg("Internal Server Error", consts.StatusInternalServerError)
                        return
                }</span>
        }

        <span class="cov8" title="1">mustCompress := false
        fileCache := h.cache
        byteRange := ctx.Request.Header.PeekRange()
        if len(byteRange) == 0 &amp;&amp; h.compress &amp;&amp; ctx.Request.Header.HasAcceptEncodingBytes(bytestr.StrGzip) </span><span class="cov8" title="1">{
                mustCompress = true
                fileCache = h.compressedCache
        }</span>

        <span class="cov8" title="1">h.cacheLock.Lock()
        ff, ok := fileCache[string(path)]
        if ok </span><span class="cov8" title="1">{
                ff.readersCount++
        }</span>
        <span class="cov8" title="1">h.cacheLock.Unlock()

        if !ok </span><span class="cov8" title="1">{
                pathStr := string(path)
                filePath := h.root + pathStr
                var err error
                ff, err = h.openFSFile(filePath, mustCompress)

                if mustCompress &amp;&amp; err == errNoCreatePermission </span><span class="cov0" title="0">{
                        hlog.SystemLogger().Errorf("Insufficient permissions for saving compressed file for path=%q. Serving uncompressed file. "+
                                "Allow write access to the directory with this file in order to improve hertz performance", filePath)
                        mustCompress = false
                        ff, err = h.openFSFile(filePath, mustCompress)
                }</span>
                <span class="cov8" title="1">if err == errDirIndexRequired </span><span class="cov8" title="1">{
                        ff, err = h.openIndexFile(ctx, filePath, mustCompress)
                        if err != nil </span><span class="cov0" title="0">{
                                hlog.SystemLogger().Errorf("Cannot open dir index, path=%q, error=%s", filePath, err)
                                ctx.AbortWithMsg("Directory index is forbidden", consts.StatusForbidden)
                                return
                        }</span>
                } else<span class="cov8" title="1"> if err != nil </span><span class="cov8" title="1">{
                        hlog.SystemLogger().Errorf("Cannot open file=%q, error=%s", filePath, err)
                        if h.pathNotFound == nil </span><span class="cov8" title="1">{
                                ctx.AbortWithMsg("Cannot open requested path", consts.StatusNotFound)
                        }</span> else<span class="cov8" title="1"> {
                                ctx.SetStatusCode(consts.StatusNotFound)
                                h.pathNotFound(c, ctx)
                        }</span>
                        <span class="cov8" title="1">return</span>
                }

                <span class="cov8" title="1">h.cacheLock.Lock()
                ff1, ok := fileCache[pathStr]
                if !ok </span><span class="cov8" title="1">{
                        fileCache[pathStr] = ff
                        ff.readersCount++
                }</span> else<span class="cov8" title="1"> {
                        ff1.readersCount++
                }</span>
                <span class="cov8" title="1">h.cacheLock.Unlock()

                if ok </span><span class="cov8" title="1">{
                        // The file has been already opened by another
                        // goroutine, so close the current file and use
                        // the file opened by another goroutine instead.
                        ff.Release()
                        ff = ff1
                }</span>
        }

        <span class="cov8" title="1">if !ctx.IfModifiedSince(ff.lastModified) </span><span class="cov0" title="0">{
                ff.decReadersCount()
                ctx.NotModified()
                return
        }</span>

        <span class="cov8" title="1">r, err := ff.NewReader()
        if err != nil </span><span class="cov0" title="0">{
                hlog.SystemLogger().Errorf("Cannot obtain file reader for path=%q, error=%s", path, err)
                ctx.AbortWithMsg("Internal Server Error", consts.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">hdr := &amp;ctx.Response.Header
        if ff.compressed </span><span class="cov8" title="1">{
                hdr.SetContentEncodingBytes(bytestr.StrGzip)
        }</span>

        <span class="cov8" title="1">statusCode := consts.StatusOK
        contentLength := ff.contentLength
        if h.acceptByteRange </span><span class="cov8" title="1">{
                hdr.SetCanonical(bytestr.StrAcceptRanges, bytestr.StrBytes)
                if len(byteRange) &gt; 0 </span><span class="cov8" title="1">{
                        startPos, endPos, err := ParseByteRange(byteRange, contentLength)
                        if err != nil </span><span class="cov0" title="0">{
                                r.(io.Closer).Close()
                                hlog.SystemLogger().Errorf("Cannot parse byte range %q for path=%q,error=%s", byteRange, path, err)
                                ctx.AbortWithMsg("Range Not Satisfiable", consts.StatusRequestedRangeNotSatisfiable)
                                return
                        }</span>

                        <span class="cov8" title="1">if err = r.(byteRangeUpdater).UpdateByteRange(startPos, endPos); err != nil </span><span class="cov0" title="0">{
                                r.(io.Closer).Close()
                                hlog.SystemLogger().Errorf("Cannot seek byte range %q for path=%q, error=%s", byteRange, path, err)
                                ctx.AbortWithMsg("Internal Server Error", consts.StatusInternalServerError)
                                return
                        }</span>

                        <span class="cov8" title="1">hdr.SetContentRange(startPos, endPos, contentLength)
                        contentLength = endPos - startPos + 1
                        statusCode = consts.StatusPartialContent</span>
                }
        }

        <span class="cov8" title="1">hdr.SetCanonical(bytestr.StrLastModified, ff.lastModifiedStr)
        if !ctx.IsHead() </span><span class="cov8" title="1">{
                ctx.SetBodyStream(r, contentLength)
        }</span> else<span class="cov8" title="1"> {
                ctx.Response.ResetBody()
                ctx.Response.SkipBody = true
                ctx.Response.Header.SetContentLength(contentLength)
                if rc, ok := r.(io.Closer); ok </span><span class="cov8" title="1">{
                        if err := rc.Close(); err != nil </span><span class="cov0" title="0">{
                                hlog.SystemLogger().Errorf("Cannot close file reader: error=%s", err)
                                ctx.AbortWithMsg("Internal Server Error", consts.StatusInternalServerError)
                                return
                        }</span>
                }
        }
        <span class="cov8" title="1">hdr.SetNoDefaultContentType(true)
        if len(hdr.ContentType()) == 0 </span><span class="cov8" title="1">{
                ctx.SetContentType(ff.contentType)
        }</span>
        <span class="cov8" title="1">ctx.SetStatusCode(statusCode)</span>
}

type fsFile struct {
        h             *fsHandler
        f             *os.File
        dirIndex      []byte
        contentType   string
        contentLength int
        compressed    bool

        lastModified    time.Time
        lastModifiedStr []byte

        t            time.Time
        readersCount int

        bigFiles     []*bigFileReader
        bigFilesLock sync.Mutex
}

func (ff *fsFile) Release() <span class="cov8" title="1">{
        if ff.f != nil </span><span class="cov8" title="1">{
                ff.f.Close()

                if ff.isBig() </span><span class="cov8" title="1">{
                        ff.bigFilesLock.Lock()
                        for _, r := range ff.bigFiles </span><span class="cov0" title="0">{
                                r.f.Close()
                        }</span>
                        <span class="cov8" title="1">ff.bigFilesLock.Unlock()</span>
                }
        }
}

func (ff *fsFile) isBig() bool <span class="cov8" title="1">{
        return ff.contentLength &gt; consts.MaxSmallFileSize &amp;&amp; len(ff.dirIndex) == 0
}</span>

func cleanCacheNolock(cache map[string]*fsFile, pendingFiles, filesToRelease []*fsFile, cacheDuration time.Duration) ([]*fsFile, []*fsFile) <span class="cov0" title="0">{
        t := time.Now()
        for k, ff := range cache </span><span class="cov0" title="0">{
                if t.Sub(ff.t) &gt; cacheDuration </span><span class="cov0" title="0">{
                        if ff.readersCount &gt; 0 </span><span class="cov0" title="0">{
                                // There are pending readers on stale file handle,
                                // so we cannot close it. Put it into pendingFiles
                                // so it will be closed later.
                                pendingFiles = append(pendingFiles, ff)
                        }</span> else<span class="cov0" title="0"> {
                                filesToRelease = append(filesToRelease, ff)
                        }</span>
                        <span class="cov0" title="0">delete(cache, k)</span>
                }
        }
        <span class="cov0" title="0">return pendingFiles, filesToRelease</span>
}

func stripTrailingSlashes(path []byte) []byte <span class="cov8" title="1">{
        for len(path) &gt; 0 &amp;&amp; path[len(path)-1] == '/' </span><span class="cov8" title="1">{
                path = path[:len(path)-1]
        }</span>
        <span class="cov8" title="1">return path</span>
}

func isFileCompressible(f *os.File, minCompressRatio float64) bool <span class="cov0" title="0">{
        // Try compressing the first 4kb of the file
        // and see if it can be compressed by more than
        // the given minCompressRatio.
        b := bytebufferpool.Get()
        zw := compress.AcquireStacklessGzipWriter(b, compress.CompressDefaultCompression)
        lr := &amp;io.LimitedReader{
                R: f,
                N: 4096,
        }
        zrw := network.NewWriter(zw)
        _, err := utils.CopyZeroAlloc(zrw, lr)
        compress.ReleaseStacklessGzipWriter(zw, compress.CompressDefaultCompression)
        f.Seek(0, 0) //nolint:errcheck
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">n := 4096 - lr.N
        zn := len(b.B)
        bytebufferpool.Put(b)
        return float64(zn) &lt; float64(n)*minCompressRatio</span>
}

var (
        filesLockMap     = make(map[string]*sync.Mutex)
        filesLockMapLock sync.Mutex
)

func getFileLock(absPath string) *sync.Mutex <span class="cov8" title="1">{
        filesLockMapLock.Lock()
        flock := filesLockMap[absPath]
        if flock == nil </span><span class="cov8" title="1">{
                flock = &amp;sync.Mutex{}
                filesLockMap[absPath] = flock
        }</span>
        <span class="cov8" title="1">filesLockMapLock.Unlock()
        return flock</span>
}

func fileExtension(path string, compressed bool, compressedFileSuffix string) string <span class="cov8" title="1">{
        if compressed &amp;&amp; strings.HasSuffix(path, compressedFileSuffix) </span><span class="cov8" title="1">{
                path = path[:len(path)-len(compressedFileSuffix)]
        }</span>
        <span class="cov8" title="1">n := strings.LastIndexByte(path, '.')
        if n &lt; 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return path[n:]</span>
}

func readFileHeader(f *os.File, compressed bool) ([]byte, error) <span class="cov8" title="1">{
        r := io.Reader(f)
        var zr *gzip.Reader
        if compressed </span><span class="cov0" title="0">{
                var err error
                if zr, err = compress.AcquireGzipReader(f); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">r = zr</span>
        }

        <span class="cov8" title="1">lr := &amp;io.LimitedReader{
                R: r,
                N: 512,
        }
        data, err := ioutil.ReadAll(lr)
        if _, err := f.Seek(0, 0); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if zr != nil </span><span class="cov0" title="0">{
                compress.ReleaseGzipReader(zr)
        }</span>

        <span class="cov8" title="1">return data, err</span>
}

func fsModTime(t time.Time) time.Time <span class="cov8" title="1">{
        return t.In(time.UTC).Truncate(time.Second)
}</span>

// ParseByteRange parses 'Range: bytes=...' header value.
//
// It follows https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35 .
func ParseByteRange(byteRange []byte, contentLength int) (startPos, endPos int, err error) <span class="cov8" title="1">{
        b := byteRange
        if !bytes.HasPrefix(b, bytestr.StrBytes) </span><span class="cov8" title="1">{
                return 0, 0, fmt.Errorf("unsupported range units: %q. Expecting %q", byteRange, bytestr.StrBytes)
        }</span>

        <span class="cov8" title="1">b = b[len(bytestr.StrBytes):]
        if len(b) == 0 || b[0] != '=' </span><span class="cov0" title="0">{
                return 0, 0, fmt.Errorf("missing byte range in %q", byteRange)
        }</span>
        <span class="cov8" title="1">b = b[1:]

        n := bytes.IndexByte(b, '-')
        if n &lt; 0 </span><span class="cov8" title="1">{
                return 0, 0, fmt.Errorf("missing the end position of byte range in %q", byteRange)
        }</span>

        <span class="cov8" title="1">if n == 0 </span><span class="cov8" title="1">{
                v, err := bytesconv.ParseUint(b[n+1:])
                if err != nil </span><span class="cov0" title="0">{
                        return 0, 0, err
                }</span>
                <span class="cov8" title="1">startPos := contentLength - v
                if startPos &lt; 0 </span><span class="cov8" title="1">{
                        startPos = 0
                }</span>
                <span class="cov8" title="1">return startPos, contentLength - 1, nil</span>
        }

        <span class="cov8" title="1">if startPos, err = bytesconv.ParseUint(b[:n]); err != nil </span><span class="cov8" title="1">{
                return 0, 0, err
        }</span>
        <span class="cov8" title="1">if startPos &gt;= contentLength </span><span class="cov8" title="1">{
                return 0, 0, fmt.Errorf("the start position of byte range cannot exceed %d. byte range %q", contentLength-1, byteRange)
        }</span>

        <span class="cov8" title="1">b = b[n+1:]
        if len(b) == 0 </span><span class="cov8" title="1">{
                return startPos, contentLength - 1, nil
        }</span>

        <span class="cov8" title="1">if endPos, err = bytesconv.ParseUint(b); err != nil </span><span class="cov8" title="1">{
                return 0, 0, err
        }</span>
        <span class="cov8" title="1">if endPos &gt;= contentLength </span><span class="cov8" title="1">{
                endPos = contentLength - 1
        }</span>
        <span class="cov8" title="1">if endPos &lt; startPos </span><span class="cov8" title="1">{
                return 0, 0, fmt.Errorf("the start position of byte range cannot exceed the end position. byte range %q", byteRange)
        }</span>
        <span class="cov8" title="1">return startPos, endPos, nil</span>
}

// NewVHostPathRewriter returns path rewriter, which strips slashesCount
// leading slashes from the path and prepends the path with request's host,
// thus simplifying virtual hosting for static files.
//
// Examples:
//
//   - host=foobar.com, slashesCount=0, original path="/foo/bar".
//     Resulting path: "/foobar.com/foo/bar"
//
//   - host=img.aaa.com, slashesCount=1, original path="/images/123/456.jpg"
//     Resulting path: "/img.aaa.com/123/456.jpg"
func NewVHostPathRewriter(slashesCount int) PathRewriteFunc <span class="cov8" title="1">{
        return func(ctx *RequestContext) []byte </span><span class="cov8" title="1">{
                path := stripLeadingSlashes(ctx.Path(), slashesCount)
                host := ctx.Host()
                if n := bytes.IndexByte(host, '/'); n &gt;= 0 </span><span class="cov8" title="1">{
                        host = nil
                }</span>
                <span class="cov8" title="1">if len(host) == 0 </span><span class="cov8" title="1">{
                        host = strInvalidHost
                }</span>
                <span class="cov8" title="1">b := bytebufferpool.Get()
                b.B = append(b.B, '/')
                b.B = append(b.B, host...)
                b.B = append(b.B, path...)
                ctx.URI().SetPathBytes(b.B)
                bytebufferpool.Put(b)

                return ctx.Path()</span>
        }
}

func stripLeadingSlashes(path []byte, stripSlashes int) []byte <span class="cov8" title="1">{
        for stripSlashes &gt; 0 &amp;&amp; len(path) &gt; 0 </span><span class="cov8" title="1">{
                if path[0] != '/' </span><span class="cov0" title="0">{
                        panic("BUG: path must start with slash")</span>
                }
                <span class="cov8" title="1">n := bytes.IndexByte(path[1:], '/')
                if n &lt; 0 </span><span class="cov8" title="1">{
                        path = path[:0]
                        break</span>
                }
                <span class="cov8" title="1">path = path[n+1:]
                stripSlashes--</span>
        }
        <span class="cov8" title="1">return path</span>
}

// ServeFileUncompressed returns HTTP response containing file contents
// from the given path.
//
// Directory contents is returned if path points to directory.
//
// ServeFile may be used for saving network traffic when serving files
// with good compression ratio.
func ServeFileUncompressed(ctx *RequestContext, path string) <span class="cov8" title="1">{
        ctx.Request.Header.DelBytes(bytestr.StrAcceptEncoding)
        ServeFile(ctx, path)
}</span>

// NewPathSlashesStripper returns path rewriter, which strips slashesCount
// leading slashes from the path.
//
// Examples:
//
//   - slashesCount = 0, original path: "/foo/bar", result: "/foo/bar"
//   - slashesCount = 1, original path: "/foo/bar", result: "/bar"
//   - slashesCount = 2, original path: "/foo/bar", result: ""
//
// The returned path rewriter may be used as FS.PathRewrite .
func NewPathSlashesStripper(slashesCount int) PathRewriteFunc <span class="cov0" title="0">{
        return func(ctx *RequestContext) []byte </span><span class="cov0" title="0">{
                return stripLeadingSlashes(ctx.Path(), slashesCount)
        }</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package sd

import (
        "context"

        "github.com/cloudwego/hertz/pkg/app/client"
        "github.com/cloudwego/hertz/pkg/app/client/discovery"
        "github.com/cloudwego/hertz/pkg/app/client/loadbalance"
        "github.com/cloudwego/hertz/pkg/protocol"
)

// Discovery will construct a middleware with BalancerFactory.
func Discovery(resolver discovery.Resolver, opts ...ServiceDiscoveryOption) client.Middleware <span class="cov8" title="1">{
        options := &amp;ServiceDiscoveryOptions{
                Balancer: loadbalance.NewWeightedBalancer(),
                LbOpts:   loadbalance.DefaultLbOpts,
                Resolver: resolver,
        }
        options.Apply(opts)

        lbConfig := loadbalance.Config{
                Resolver: options.Resolver,
                Balancer: options.Balancer,
                LbOpts:   options.LbOpts,
        }

        f := loadbalance.NewBalancerFactory(lbConfig)
        return func(next client.Endpoint) client.Endpoint </span><span class="cov8" title="1">{
                return func(ctx context.Context, req *protocol.Request, resp *protocol.Response) (err error) </span><span class="cov8" title="1">{
                        if req.Options() != nil &amp;&amp; req.Options().IsSD() </span><span class="cov8" title="1">{
                                ins, err := f.GetInstance(ctx, req)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">req.SetHost(ins.Address().String())</span>
                        }
                        <span class="cov8" title="1">return next(ctx, req, resp)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file15" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package sd

import (
        "context"
        "fmt"
        "net"
        "strings"

        "github.com/cloudwego/hertz/pkg/app/client/discovery"
        "github.com/cloudwego/hertz/pkg/app/client/loadbalance"
        "github.com/cloudwego/hertz/pkg/app/server/registry"
)

// ServiceDiscoveryOptions service discovery option for client
type ServiceDiscoveryOptions struct {
        // Resolver is used to client discovery
        Resolver discovery.Resolver

        // Balancer is used to client load balance
        Balancer loadbalance.Loadbalancer

        // LbOpts LoadBalance option
        LbOpts loadbalance.Options
}

func (o *ServiceDiscoveryOptions) Apply(opts []ServiceDiscoveryOption) <span class="cov8" title="1">{
        for _, op := range opts </span><span class="cov8" title="1">{
                op.F(o)
        }</span>
}

type ServiceDiscoveryOption struct {
        F func(o *ServiceDiscoveryOptions)
}

// WithCustomizedAddrs specifies the target instance addresses when doing service discovery.
// It overwrites the results from the Resolver
func WithCustomizedAddrs(addrs ...string) ServiceDiscoveryOption <span class="cov8" title="1">{
        return ServiceDiscoveryOption{
                F: func(o *ServiceDiscoveryOptions) </span><span class="cov8" title="1">{
                        var ins []discovery.Instance
                        for _, addr := range addrs </span><span class="cov8" title="1">{
                                if _, err := net.ResolveTCPAddr("tcp", addr); err == nil </span><span class="cov8" title="1">{
                                        ins = append(ins, discovery.NewInstance("tcp", addr, registry.DefaultWeight, nil))
                                        continue</span>
                                }
                                <span class="cov8" title="1">if _, err := net.ResolveUnixAddr("unix", addr); err == nil </span><span class="cov8" title="1">{
                                        ins = append(ins, discovery.NewInstance("unix", addr, registry.DefaultWeight, nil))
                                        continue</span>
                                }
                                <span class="cov0" title="0">panic(fmt.Errorf("WithCustomizedAddrs: invalid '%s'", addr))</span>
                        }
                        <span class="cov8" title="1">if len(ins) == 0 </span><span class="cov0" title="0">{
                                panic("WithCustomizedAddrs() requires at least one argument")</span>
                        }

                        <span class="cov8" title="1">targets := strings.Join(addrs, ",")
                        o.Resolver = &amp;discovery.SynthesizedResolver{
                                ResolveFunc: func(ctx context.Context, key string) (discovery.Result, error) </span><span class="cov8" title="1">{
                                        return discovery.Result{
                                                CacheKey:  "fixed",
                                                Instances: ins,
                                        }, nil
                                }</span>,
                                NameFunc: func() string <span class="cov8" title="1">{ return targets }</span>,
                                TargetFunc: func(ctx context.Context, target *discovery.TargetInfo) string <span class="cov0" title="0">{
                                        return targets
                                }</span>,
                        }
                },
        }
}

// WithLoadBalanceOptions  sets Loadbalancer and loadbalance options for hertz client
func WithLoadBalanceOptions(lb loadbalance.Loadbalancer, options loadbalance.Options) ServiceDiscoveryOption <span class="cov8" title="1">{
        return ServiceDiscoveryOption{F: func(o *ServiceDiscoveryOptions) </span><span class="cov8" title="1">{
                o.LbOpts = options
                o.Balancer = lb
        }</span>}
}
</pre>
		
		<pre class="file" id="file16" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Manuel MartÃ­nez-Almeida
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This file may have been modified by CloudWeGo authors. All CloudWeGo
 * Modifications are Copyright 2022 CloudWeGo Authors
 */

package basic_auth

import (
        "context"
        "encoding/base64"
        "net/http"
        "strconv"

        "github.com/cloudwego/hertz/internal/bytesconv"
        "github.com/cloudwego/hertz/pkg/app"
)

// Accounts is an alias to map[string]string, construct with {"username":"password"}
type Accounts map[string]string

// pairs is an alias to map[string]string, which mean {"header":"username"}
type pairs map[string]string

func (p pairs) findValue(needle string) (v string, ok bool) <span class="cov8" title="1">{
        v, ok = p[needle]
        return
}</span>

func constructPairs(accounts Accounts) pairs <span class="cov8" title="1">{
        length := len(accounts)
        p := make(pairs, length)
        for user, password := range accounts </span><span class="cov8" title="1">{
                value := "Basic " + base64.StdEncoding.EncodeToString(bytesconv.S2b(user+":"+password))
                p[value] = user
        }</span>
        <span class="cov8" title="1">return p</span>
}

// BasicAuthForRealm returns a Basic HTTP Authorization middleware. It takes as arguments a map[string]string where
// the key is the username and the value is the password, as well as the name of the Realm.
// If the realm is empty, "Authorization Required" will be used by default.
// (see http://tools.ietf.org/html/rfc2617#section-1.2)
func BasicAuthForRealm(accounts Accounts, realm, userKey string) app.HandlerFunc <span class="cov8" title="1">{
        realm = "Basic realm=" + strconv.Quote(realm)
        p := constructPairs(accounts)
        return func(ctx context.Context, c *app.RequestContext) </span><span class="cov8" title="1">{
                // Search user in the slice of allowed credentials
                user, found := p.findValue(c.Request.Header.Get("Authorization"))
                if !found </span><span class="cov8" title="1">{
                        // Credentials doesn't match, we return 401 and abort handlers chain.
                        c.Header("WWW-Authenticate", realm)
                        c.AbortWithStatus(http.StatusUnauthorized)
                        return
                }</span>

                // The user credentials was found, set user's id to key AuthUserKey in this context, the user's id can be read later using
                <span class="cov8" title="1">c.Set(userKey, user)</span>
        }
}

// BasicAuth is a constructor of BasicAuth verifier to hertz middleware
// It returns a Basic HTTP Authorization middleware. It takes as argument a map[string]string where
// the key is the username and the value is the password.
func BasicAuth(accounts Accounts) app.HandlerFunc <span class="cov8" title="1">{
        return BasicAuthForRealm(accounts, "Authorization Required", "user")
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package recovery

import (
        "context"

        "github.com/cloudwego/hertz/pkg/app"
        "github.com/cloudwego/hertz/pkg/common/hlog"
        "github.com/cloudwego/hertz/pkg/protocol/consts"
)

type (
        options struct {
                recoveryHandler func(c context.Context, ctx *app.RequestContext, err interface{}, stack []byte)
        }

        Option func(o *options)
)

func defaultRecoveryHandler(c context.Context, ctx *app.RequestContext, err interface{}, stack []byte) <span class="cov8" title="1">{
        hlog.SystemLogger().CtxErrorf(c, "[Recovery] err=%v\nstack=%s", err, stack)
        ctx.AbortWithStatus(consts.StatusInternalServerError)
}</span>

func newOptions(opts ...Option) *options <span class="cov8" title="1">{
        cfg := &amp;options{
                recoveryHandler: defaultRecoveryHandler,
        }

        for _, opt := range opts </span><span class="cov8" title="1">{
                opt(cfg)
        }</span>

        <span class="cov8" title="1">return cfg</span>
}

func WithRecoveryHandler(f func(c context.Context, ctx *app.RequestContext, err interface{}, stack []byte)) Option <span class="cov8" title="1">{
        return func(o *options) </span><span class="cov8" title="1">{
                o.recoveryHandler = f
        }</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package recovery

import (
        "bytes"
        "context"
        "fmt"
        "io/ioutil"
        "runtime"

        "github.com/cloudwego/hertz/pkg/app"
)

var (
        dunno     = []byte("???")
        centerDot = []byte("Â·")
        dot       = []byte(".")
        slash     = []byte("/")
)

// Recovery returns a middleware that recovers from any panic.
// By default, it will print the time, content, and stack information of the error and write a 500.
// Overriding the Config configuration, you can customize the error printing logic.
func Recovery(opts ...Option) app.HandlerFunc <span class="cov8" title="1">{
        cfg := newOptions(opts...)

        return func(c context.Context, ctx *app.RequestContext) </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{
                        if err := recover(); err != nil </span><span class="cov8" title="1">{
                                stack := stack(3)

                                cfg.recoveryHandler(c, ctx, err, stack)
                        }</span>
                }()
                <span class="cov8" title="1">ctx.Next(c)</span>
        }
}

// stack returns a nicely formatted stack frame, skipping skip frames.
func stack(skip int) []byte <span class="cov8" title="1">{
        buf := new(bytes.Buffer) // the returned data
        // As we loop, we open files and read them. These variables record the currently
        // loaded file.
        var lines [][]byte
        var lastFile string
        for i := skip; ; i++ </span><span class="cov8" title="1">{ // Skip the expected number of frames
                pc, file, line, ok := runtime.Caller(i)
                if !ok </span><span class="cov8" title="1">{
                        break</span>
                }
                // Print this much at least.  If we can't find the source, it won't show.
                <span class="cov8" title="1">fmt.Fprintf(buf, "%s:%d (0x%x)\n", file, line, pc)
                if file != lastFile </span><span class="cov8" title="1">{
                        data, err := ioutil.ReadFile(file)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">lines = bytes.Split(data, []byte{'\n'})
                        lastFile = file</span>
                }
                <span class="cov8" title="1">fmt.Fprintf(buf, "\t%s: %s\n", function(pc), source(lines, line))</span>
        }
        <span class="cov8" title="1">return buf.Bytes()</span>
}

// source returns a space-trimmed slice of the n'th line.
func source(lines [][]byte, n int) []byte <span class="cov8" title="1">{
        n-- // in stack trace, lines are 1-indexed but our array is 0-indexed
        if n &lt; 0 || n &gt;= len(lines) </span><span class="cov0" title="0">{
                return dunno
        }</span>
        <span class="cov8" title="1">return bytes.TrimSpace(lines[n])</span>
}

// function returns, if possible, the name of the function containing the PC.
func function(pc uintptr) []byte <span class="cov8" title="1">{
        fn := runtime.FuncForPC(pc)
        if fn == nil </span><span class="cov0" title="0">{
                return dunno
        }</span>
        <span class="cov8" title="1">name := []byte(fn.Name())
        // The name includes the path name to the package, which is unnecessary
        // since the file name is already included.  Plus, it has center dots.
        // That is, we see
        //        runtime/debug.*TÂ·ptrmethod
        // and want
        //        *T.ptrmethod
        // Also the package path might contains dot (e.g. code.google.com/...),
        // so first eliminate the path prefix
        if lastSlash := bytes.LastIndex(name, slash); lastSlash &gt;= 0 </span><span class="cov8" title="1">{
                name = name[lastSlash+1:]
        }</span>
        <span class="cov8" title="1">if period := bytes.Index(name, dot); period &gt;= 0 </span><span class="cov8" title="1">{
                name = name[period+1:]
        }</span>
        <span class="cov8" title="1">name = bytes.Replace(name, centerDot, dot, -1)
        return name</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">/*
 * Copyright 2023 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package binding

import (
        stdJson "encoding/json"
        "fmt"
        "reflect"
        "time"

        exprValidator "github.com/bytedance/go-tagexpr/v2/validator"
        inDecoder "github.com/cloudwego/hertz/pkg/app/server/binding/internal/decoder"
        hJson "github.com/cloudwego/hertz/pkg/common/json"
        "github.com/cloudwego/hertz/pkg/protocol"
        "github.com/cloudwego/hertz/pkg/route/param"
)

// BindConfig contains options for default bind behavior.
type BindConfig struct {
        // LooseZeroMode if set to true,
        // the empty string request parameter is bound to the zero value of parameter.
        // NOTE:
        //        The default is false.
        //        Suitable for these parameter types: query/header/cookie/form .
        LooseZeroMode bool
        // DisableDefaultTag is used to add default tags to a field when it has no tag
        // If is false, the field with no tag will be added default tags, for more automated binding. But there may be additional overhead.
        // NOTE:
        // The default is false.
        DisableDefaultTag bool
        // DisableStructFieldResolve is used to generate a separate decoder for a struct.
        // If is false, the 'struct' field will get a single inDecoder.structTypeFieldTextDecoder, and use json.Unmarshal for decode it.
        // It usually used to add json string to query parameter.
        // NOTE:
        // The default is false.
        DisableStructFieldResolve bool
        // EnableDecoderUseNumber is used to call the UseNumber method on the JSON
        // Decoder instance. UseNumber causes the Decoder to unmarshal a number into an
        // interface{} as a Number instead of as a float64.
        // NOTE:
        // The default is false.
        // It is used for BindJSON().
        EnableDecoderUseNumber bool
        // EnableDecoderDisallowUnknownFields is used to call the DisallowUnknownFields method
        // on the JSON Decoder instance. DisallowUnknownFields causes the Decoder to
        // return an error when the destination is a struct and the input contains object
        // keys which do not match any non-ignored, exported fields in the destination.
        // NOTE:
        // The default is false.
        // It is used for BindJSON().
        EnableDecoderDisallowUnknownFields bool
        // TypeUnmarshalFuncs registers customized type unmarshaler.
        // NOTE:
        // time.Time is registered by default
        TypeUnmarshalFuncs map[reflect.Type]inDecoder.CustomizeDecodeFunc
        // Validator is used to validate for BindAndValidate()
        Validator StructValidator
}

func NewBindConfig() *BindConfig <span class="cov8" title="1">{
        return &amp;BindConfig{
                LooseZeroMode:                      false,
                DisableDefaultTag:                  false,
                DisableStructFieldResolve:          false,
                EnableDecoderUseNumber:             false,
                EnableDecoderDisallowUnknownFields: false,
                TypeUnmarshalFuncs:                 make(map[reflect.Type]inDecoder.CustomizeDecodeFunc),
                Validator:                          defaultValidate,
        }
}</span>

// RegTypeUnmarshal registers customized type unmarshaler.
func (config *BindConfig) RegTypeUnmarshal(t reflect.Type, fn inDecoder.CustomizeDecodeFunc) error <span class="cov8" title="1">{
        // check
        switch t.Kind() </span>{
        case reflect.String, reflect.Bool,
                reflect.Float32, reflect.Float64,
                reflect.Int, reflect.Int64, reflect.Int32, reflect.Int16, reflect.Int8,
                reflect.Uint, reflect.Uint64, reflect.Uint32, reflect.Uint16, reflect.Uint8:<span class="cov8" title="1">
                return fmt.Errorf("registration type cannot be a basic type")</span>
        case reflect.Ptr:<span class="cov0" title="0">
                return fmt.Errorf("registration type cannot be a pointer type")</span>
        }
        <span class="cov8" title="1">if config.TypeUnmarshalFuncs == nil </span><span class="cov8" title="1">{
                config.TypeUnmarshalFuncs = make(map[reflect.Type]inDecoder.CustomizeDecodeFunc)
        }</span>
        <span class="cov8" title="1">config.TypeUnmarshalFuncs[t] = fn
        return nil</span>
}

// MustRegTypeUnmarshal registers customized type unmarshaler. It will panic if exist error.
func (config *BindConfig) MustRegTypeUnmarshal(t reflect.Type, fn func(req *protocol.Request, params param.Params, text string) (reflect.Value, error)) <span class="cov8" title="1">{
        err := config.RegTypeUnmarshal(t, fn)
        if err != nil </span><span class="cov8" title="1">{
                panic(err)</span>
        }
}

func (config *BindConfig) initTypeUnmarshal() <span class="cov8" title="1">{
        config.MustRegTypeUnmarshal(reflect.TypeOf(time.Time{}), func(req *protocol.Request, params param.Params, text string) (reflect.Value, error) </span><span class="cov8" title="1">{
                if text == "" </span><span class="cov0" title="0">{
                        return reflect.ValueOf(time.Time{}), nil
                }</span>
                <span class="cov8" title="1">t, err := time.Parse(time.RFC3339, text)
                if err != nil </span><span class="cov0" title="0">{
                        return reflect.Value{}, err
                }</span>
                <span class="cov8" title="1">return reflect.ValueOf(t), nil</span>
        })
}

// UseThirdPartyJSONUnmarshaler uses third-party json library for binding
// NOTE:
//
//        UseThirdPartyJSONUnmarshaler will remain in effect once it has been called.
func (config *BindConfig) UseThirdPartyJSONUnmarshaler(fn func(data []byte, v interface{}) error) <span class="cov8" title="1">{
        hJson.Unmarshal = fn
}</span>

// UseStdJSONUnmarshaler uses encoding/json as json library
// NOTE:
//
//        The current version uses encoding/json by default.
//        UseStdJSONUnmarshaler will remain in effect once it has been called.
func (config *BindConfig) UseStdJSONUnmarshaler() <span class="cov8" title="1">{
        config.UseThirdPartyJSONUnmarshaler(stdJson.Unmarshal)
}</span>

type ValidateErrFactory func(fieldSelector, msg string) error

type ValidateConfig struct {
        ValidateTag string
        ErrFactory  ValidateErrFactory
}

func NewValidateConfig() *ValidateConfig <span class="cov8" title="1">{
        return &amp;ValidateConfig{}
}</span>

// MustRegValidateFunc registers validator function expression.
// NOTE:
//
//        If force=true, allow to cover the existed same funcName.
//        MustRegValidateFunc will remain in effect once it has been called.
func (config *ValidateConfig) MustRegValidateFunc(funcName string, fn func(args ...interface{}) error, force ...bool) <span class="cov0" title="0">{
        exprValidator.MustRegFunc(funcName, fn, force...)
}</span>

// SetValidatorErrorFactory customizes the factory of validation error.
func (config *ValidateConfig) SetValidatorErrorFactory(errFactory ValidateErrFactory) <span class="cov8" title="1">{
        config.ErrFactory = errFactory
}</span>

// SetValidatorTag customizes the factory of validation error.
func (config *ValidateConfig) SetValidatorTag(tag string) <span class="cov0" title="0">{
        config.ValidateTag = tag
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">/*
 * Copyright 2023 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * The MIT License
 *
 * Copyright (c) 2019-present Fenny and Contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * Copyright (c) 2014 Manuel MartÃ­nez-Almeida
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This file may have been modified by CloudWeGo authors. All CloudWeGo
 * Modifications are Copyright 2023 CloudWeGo Authors
 */

package binding

import (
        "bytes"
        stdJson "encoding/json"
        "fmt"
        "io"
        "net/url"
        "reflect"
        "strings"
        "sync"

        exprValidator "github.com/bytedance/go-tagexpr/v2/validator"
        "github.com/cloudwego/hertz/internal/bytesconv"
        inDecoder "github.com/cloudwego/hertz/pkg/app/server/binding/internal/decoder"
        hJson "github.com/cloudwego/hertz/pkg/common/json"
        "github.com/cloudwego/hertz/pkg/common/utils"
        "github.com/cloudwego/hertz/pkg/protocol"
        "github.com/cloudwego/hertz/pkg/protocol/consts"
        "github.com/cloudwego/hertz/pkg/route/param"
        "google.golang.org/protobuf/proto"
)

const (
        queryTag           = "query"
        headerTag          = "header"
        formTag            = "form"
        pathTag            = "path"
        defaultValidateTag = "vd"
)

type decoderInfo struct {
        decoder      inDecoder.Decoder
        needValidate bool
}

var defaultBind = NewDefaultBinder(nil)

func DefaultBinder() Binder <span class="cov8" title="1">{
        return defaultBind
}</span>

type defaultBinder struct {
        config             *BindConfig
        decoderCache       sync.Map
        queryDecoderCache  sync.Map
        formDecoderCache   sync.Map
        headerDecoderCache sync.Map
        pathDecoderCache   sync.Map
}

func NewDefaultBinder(config *BindConfig) Binder <span class="cov8" title="1">{
        if config == nil </span><span class="cov8" title="1">{
                bindConfig := NewBindConfig()
                bindConfig.initTypeUnmarshal()
                return &amp;defaultBinder{
                        config: bindConfig,
                }
        }</span>
        <span class="cov8" title="1">config.initTypeUnmarshal()
        if config.Validator == nil </span><span class="cov8" title="1">{
                config.Validator = DefaultValidator()
        }</span>
        <span class="cov8" title="1">return &amp;defaultBinder{
                config: config,
        }</span>
}

// BindAndValidate binds data from *protocol.Request to obj and validates them if needed.
// NOTE:
//
//        obj should be a pointer.
func BindAndValidate(req *protocol.Request, obj interface{}, pathParams param.Params) error <span class="cov8" title="1">{
        return DefaultBinder().BindAndValidate(req, obj, pathParams)
}</span>

// Bind binds data from *protocol.Request to obj.
// NOTE:
//
//        obj should be a pointer.
func Bind(req *protocol.Request, obj interface{}, pathParams param.Params) error <span class="cov8" title="1">{
        return DefaultBinder().Bind(req, obj, pathParams)
}</span>

// Validate validates obj with "vd" tag
// NOTE:
//
//        obj should be a pointer.
//        Validate should be called after Bind.
func Validate(obj interface{}) error <span class="cov8" title="1">{
        return DefaultValidator().ValidateStruct(obj)
}</span>

func (b *defaultBinder) tagCache(tag string) *sync.Map <span class="cov8" title="1">{
        switch tag </span>{
        case queryTag:<span class="cov8" title="1">
                return &amp;b.queryDecoderCache</span>
        case headerTag:<span class="cov8" title="1">
                return &amp;b.headerDecoderCache</span>
        case formTag:<span class="cov8" title="1">
                return &amp;b.formDecoderCache</span>
        case pathTag:<span class="cov8" title="1">
                return &amp;b.pathDecoderCache</span>
        default:<span class="cov8" title="1">
                return &amp;b.decoderCache</span>
        }
}

func (b *defaultBinder) bindTag(req *protocol.Request, v interface{}, params param.Params, tag string) error <span class="cov8" title="1">{
        rv, typeID := valueAndTypeID(v)
        if err := checkPointer(rv); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">rt := dereferPointer(rv)
        if rt.Kind() != reflect.Struct </span><span class="cov8" title="1">{
                return b.bindNonStruct(req, v)
        }</span>

        <span class="cov8" title="1">if len(tag) == 0 </span><span class="cov8" title="1">{
                err := b.preBindBody(req, v)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("bind body failed, err=%v", err)
                }</span>
        }
        <span class="cov8" title="1">cache := b.tagCache(tag)
        cached, ok := cache.Load(typeID)
        if ok </span><span class="cov8" title="1">{
                // cached fieldDecoder, fast path
                decoder := cached.(decoderInfo)
                return decoder.decoder(req, params, rv.Elem())
        }</span>
        <span class="cov8" title="1">validateTag := defaultValidateTag
        if len(b.config.Validator.ValidateTag()) != 0 </span><span class="cov8" title="1">{
                validateTag = b.config.Validator.ValidateTag()
        }</span>
        <span class="cov8" title="1">decodeConfig := &amp;inDecoder.DecodeConfig{
                LooseZeroMode:                      b.config.LooseZeroMode,
                DisableDefaultTag:                  b.config.DisableDefaultTag,
                DisableStructFieldResolve:          b.config.DisableStructFieldResolve,
                EnableDecoderUseNumber:             b.config.EnableDecoderUseNumber,
                EnableDecoderDisallowUnknownFields: b.config.EnableDecoderDisallowUnknownFields,
                ValidateTag:                        validateTag,
                TypeUnmarshalFuncs:                 b.config.TypeUnmarshalFuncs,
        }
        decoder, needValidate, err := inDecoder.GetReqDecoder(rv.Type(), tag, decodeConfig)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">cache.Store(typeID, decoderInfo{decoder: decoder, needValidate: needValidate})
        return decoder(req, params, rv.Elem())</span>
}

func (b *defaultBinder) bindTagWithValidate(req *protocol.Request, v interface{}, params param.Params, tag string) error <span class="cov8" title="1">{
        rv, typeID := valueAndTypeID(v)
        if err := checkPointer(rv); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">rt := dereferPointer(rv)
        if rt.Kind() != reflect.Struct </span><span class="cov8" title="1">{
                return b.bindNonStruct(req, v)
        }</span>

        <span class="cov8" title="1">err := b.preBindBody(req, v)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("bind body failed, err=%v", err)
        }</span>
        <span class="cov8" title="1">cache := b.tagCache(tag)
        cached, ok := cache.Load(typeID)
        if ok </span><span class="cov8" title="1">{
                // cached fieldDecoder, fast path
                decoder := cached.(decoderInfo)
                err = decoder.decoder(req, params, rv.Elem())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if decoder.needValidate </span><span class="cov8" title="1">{
                        err = b.config.Validator.ValidateStruct(rv.Elem())
                }</span>
                <span class="cov8" title="1">return err</span>
        }
        <span class="cov8" title="1">validateTag := defaultValidateTag
        if len(b.config.Validator.ValidateTag()) != 0 </span><span class="cov8" title="1">{
                validateTag = b.config.Validator.ValidateTag()
        }</span>
        <span class="cov8" title="1">decodeConfig := &amp;inDecoder.DecodeConfig{
                LooseZeroMode:                      b.config.LooseZeroMode,
                DisableDefaultTag:                  b.config.DisableDefaultTag,
                DisableStructFieldResolve:          b.config.DisableStructFieldResolve,
                EnableDecoderUseNumber:             b.config.EnableDecoderUseNumber,
                EnableDecoderDisallowUnknownFields: b.config.EnableDecoderDisallowUnknownFields,
                ValidateTag:                        validateTag,
                TypeUnmarshalFuncs:                 b.config.TypeUnmarshalFuncs,
        }
        decoder, needValidate, err := inDecoder.GetReqDecoder(rv.Type(), tag, decodeConfig)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">cache.Store(typeID, decoderInfo{decoder: decoder, needValidate: needValidate})
        err = decoder(req, params, rv.Elem())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if needValidate </span><span class="cov8" title="1">{
                err = b.config.Validator.ValidateStruct(rv.Elem())
        }</span>
        <span class="cov8" title="1">return err</span>
}

func (b *defaultBinder) BindQuery(req *protocol.Request, v interface{}) error <span class="cov8" title="1">{
        return b.bindTag(req, v, nil, queryTag)
}</span>

func (b *defaultBinder) BindHeader(req *protocol.Request, v interface{}) error <span class="cov8" title="1">{
        return b.bindTag(req, v, nil, headerTag)
}</span>

func (b *defaultBinder) BindPath(req *protocol.Request, v interface{}, params param.Params) error <span class="cov8" title="1">{
        return b.bindTag(req, v, params, pathTag)
}</span>

func (b *defaultBinder) BindForm(req *protocol.Request, v interface{}) error <span class="cov8" title="1">{
        return b.bindTag(req, v, nil, formTag)
}</span>

func (b *defaultBinder) BindJSON(req *protocol.Request, v interface{}) error <span class="cov8" title="1">{
        return b.decodeJSON(bytes.NewReader(req.Body()), v)
}</span>

func (b *defaultBinder) decodeJSON(r io.Reader, obj interface{}) error <span class="cov8" title="1">{
        decoder := hJson.NewDecoder(r)
        if b.config.EnableDecoderUseNumber </span><span class="cov8" title="1">{
                decoder.UseNumber()
        }</span>
        <span class="cov8" title="1">if b.config.EnableDecoderDisallowUnknownFields </span><span class="cov8" title="1">{
                decoder.DisallowUnknownFields()
        }</span>

        <span class="cov8" title="1">return decoder.Decode(obj)</span>
}

func (b *defaultBinder) BindProtobuf(req *protocol.Request, v interface{}) error <span class="cov8" title="1">{
        msg, ok := v.(proto.Message)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("%s does not implement 'proto.Message'", v)
        }</span>
        <span class="cov8" title="1">return proto.Unmarshal(req.Body(), msg)</span>
}

func (b *defaultBinder) Name() string <span class="cov0" title="0">{
        return "hertz"
}</span>

func (b *defaultBinder) BindAndValidate(req *protocol.Request, v interface{}, params param.Params) error <span class="cov8" title="1">{
        return b.bindTagWithValidate(req, v, params, "")
}</span>

func (b *defaultBinder) Bind(req *protocol.Request, v interface{}, params param.Params) error <span class="cov8" title="1">{
        return b.bindTag(req, v, params, "")
}</span>

// best effort binding
func (b *defaultBinder) preBindBody(req *protocol.Request, v interface{}) error <span class="cov8" title="1">{
        if req.Header.ContentLength() &lt;= 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">ct := bytesconv.B2s(req.Header.ContentType())
        switch strings.ToLower(utils.FilterContentType(ct)) </span>{
        case consts.MIMEApplicationJSON:<span class="cov8" title="1">
                return hJson.Unmarshal(req.Body(), v)</span>
        case consts.MIMEPROTOBUF:<span class="cov8" title="1">
                msg, ok := v.(proto.Message)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s can not implement 'proto.Message'", v)
                }</span>
                <span class="cov8" title="1">return proto.Unmarshal(req.Body(), msg)</span>
        default:<span class="cov8" title="1">
                return nil</span>
        }
}

func (b *defaultBinder) bindNonStruct(req *protocol.Request, v interface{}) (err error) <span class="cov8" title="1">{
        ct := bytesconv.B2s(req.Header.ContentType())
        switch strings.ToLower(utils.FilterContentType(ct)) </span>{
        case consts.MIMEApplicationJSON:<span class="cov8" title="1">
                err = hJson.Unmarshal(req.Body(), v)</span>
        case consts.MIMEPROTOBUF:<span class="cov0" title="0">
                msg, ok := v.(proto.Message)
                if !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s can not implement 'proto.Message'", v)
                }</span>
                <span class="cov0" title="0">err = proto.Unmarshal(req.Body(), msg)</span>
        case consts.MIMEMultipartPOSTForm:<span class="cov0" title="0">
                form := make(url.Values)
                mf, err1 := req.MultipartForm()
                if err1 == nil &amp;&amp; mf.Value != nil </span><span class="cov0" title="0">{
                        for k, v := range mf.Value </span><span class="cov0" title="0">{
                                for _, vv := range v </span><span class="cov0" title="0">{
                                        form.Add(k, vv)
                                }</span>
                        }
                }
                <span class="cov0" title="0">b, _ := stdJson.Marshal(form)
                err = hJson.Unmarshal(b, v)</span>
        case consts.MIMEApplicationHTMLForm:<span class="cov8" title="1">
                form := make(url.Values)
                req.PostArgs().VisitAll(func(formKey, value []byte) </span><span class="cov8" title="1">{
                        form.Add(string(formKey), string(value))
                }</span>)
                <span class="cov8" title="1">b, _ := stdJson.Marshal(form)
                err = hJson.Unmarshal(b, v)</span>
        default:<span class="cov8" title="1">
                // using query to decode
                query := make(url.Values)
                req.URI().QueryArgs().VisitAll(func(queryKey, value []byte) </span><span class="cov8" title="1">{
                        query.Add(string(queryKey), string(value))
                }</span>)
                <span class="cov8" title="1">b, _ := stdJson.Marshal(query)
                err = hJson.Unmarshal(b, v)</span>
        }
        <span class="cov8" title="1">return</span>
}

var _ StructValidator = (*validator)(nil)

type validator struct {
        validateTag string
        validate    *exprValidator.Validator
}

func NewValidator(config *ValidateConfig) StructValidator <span class="cov8" title="1">{
        validateTag := defaultValidateTag
        if config != nil &amp;&amp; len(config.ValidateTag) != 0 </span><span class="cov8" title="1">{
                validateTag = config.ValidateTag
        }</span>
        <span class="cov8" title="1">vd := exprValidator.New(validateTag).SetErrorFactory(defaultValidateErrorFactory)
        if config != nil &amp;&amp; config.ErrFactory != nil </span><span class="cov8" title="1">{
                vd.SetErrorFactory(config.ErrFactory)
        }</span>
        <span class="cov8" title="1">return &amp;validator{
                validateTag: validateTag,
                validate:    vd,
        }</span>
}

// Error validate error
type validateError struct {
        FailPath, Msg string
}

// Error implements error interface.
func (e *validateError) Error() string <span class="cov0" title="0">{
        if e.Msg != "" </span><span class="cov0" title="0">{
                return e.Msg
        }</span>
        <span class="cov0" title="0">return "invalid parameter: " + e.FailPath</span>
}

func defaultValidateErrorFactory(failPath, msg string) error <span class="cov8" title="1">{
        return &amp;validateError{
                FailPath: failPath,
                Msg:      msg,
        }
}</span>

// ValidateStruct receives any kind of type, but only performed struct or pointer to struct type.
func (v *validator) ValidateStruct(obj interface{}) error <span class="cov8" title="1">{
        if obj == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return v.validate.Validate(obj)</span>
}

// Engine returns the underlying validator
func (v *validator) Engine() interface{} <span class="cov0" title="0">{
        return v.validate
}</span>

func (v *validator) ValidateTag() string <span class="cov8" title="1">{
        return v.validateTag
}</span>

var defaultValidate = NewValidator(NewValidateConfig())

func DefaultValidator() StructValidator <span class="cov8" title="1">{
        return defaultValidate
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">/*
 * Copyright 2023 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * MIT License
 *
 * Copyright (c) 2019-present Fenny and Contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * This file may have been modified by CloudWeGo authors. All CloudWeGo
 * Modifications are Copyright 2023 CloudWeGo Authors
 */

package binding

import (
        "fmt"
        "reflect"
        "unsafe"
)

func valueAndTypeID(v interface{}) (reflect.Value, uintptr) <span class="cov8" title="1">{
        header := (*emptyInterface)(unsafe.Pointer(&amp;v))
        rv := reflect.ValueOf(v)
        return rv, header.typeID
}</span>

type emptyInterface struct {
        typeID  uintptr
        dataPtr unsafe.Pointer
}

func checkPointer(rv reflect.Value) error <span class="cov8" title="1">{
        if rv.Kind() != reflect.Ptr || rv.IsNil() </span><span class="cov8" title="1">{
                return fmt.Errorf("receiver must be a non-nil pointer")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func dereferPointer(rv reflect.Value) reflect.Type <span class="cov8" title="1">{
        rt := rv.Type()
        for rt.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                rt = rt.Elem()
        }</span>
        <span class="cov8" title="1">return rt</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package server

import (
        "context"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/cloudwego/hertz/pkg/app/middlewares/server/recovery"
        "github.com/cloudwego/hertz/pkg/common/config"
        "github.com/cloudwego/hertz/pkg/common/errors"
        "github.com/cloudwego/hertz/pkg/common/hlog"
        "github.com/cloudwego/hertz/pkg/route"
)

// Hertz is the core struct of hertz.
type Hertz struct {
        *route.Engine
        signalWaiter func(err chan error) error
}

// New creates a hertz instance without any default config.
func New(opts ...config.Option) *Hertz <span class="cov8" title="1">{
        options := config.NewOptions(opts)
        h := &amp;Hertz{
                Engine: route.NewEngine(options),
        }
        return h
}</span>

// Default creates a hertz instance with default middlewares.
func Default(opts ...config.Option) *Hertz <span class="cov8" title="1">{
        h := New(opts...)
        h.Use(recovery.Recovery())

        return h
}</span>

// Spin runs the server until catching os.Signal or error returned by h.Run().
func (h *Hertz) Spin() <span class="cov8" title="1">{
        errCh := make(chan error)
        h.initOnRunHooks(errCh)
        go func() </span><span class="cov8" title="1">{
                errCh &lt;- h.Run()
        }</span>()

        <span class="cov8" title="1">signalWaiter := waitSignal
        if h.signalWaiter != nil </span><span class="cov0" title="0">{
                signalWaiter = h.signalWaiter
        }</span>

        <span class="cov8" title="1">if err := signalWaiter(errCh); err != nil </span><span class="cov8" title="1">{
                hlog.SystemLogger().Errorf("Receive close signal: error=%v", err)
                if err := h.Engine.Close(); err != nil </span><span class="cov0" title="0">{
                        hlog.SystemLogger().Errorf("Close error=%v", err)
                }</span>
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">hlog.SystemLogger().Infof("Begin graceful shutdown, wait at most num=%d seconds...", h.GetOptions().ExitWaitTimeout/time.Second)

        ctx, cancel := context.WithTimeout(context.Background(), h.GetOptions().ExitWaitTimeout)
        defer cancel()

        if err := h.Shutdown(ctx); err != nil </span><span class="cov8" title="1">{
                hlog.SystemLogger().Errorf("Shutdown error=%v", err)
        }</span>
}

// SetCustomSignalWaiter sets the signal waiter function.
// If Default one is not met the requirement, set this function to customize.
// Hertz will exit immediately if f returns an error, otherwise it will exit gracefully.
func (h *Hertz) SetCustomSignalWaiter(f func(err chan error) error) <span class="cov0" title="0">{
        h.signalWaiter = f
}</span>

// Default implementation for signal waiter.
// SIGTERM triggers immediately close.
// SIGHUP|SIGINT triggers graceful shutdown.
func waitSignal(errCh chan error) error <span class="cov8" title="1">{
        signalToNotify := []os.Signal{syscall.SIGINT, syscall.SIGHUP, syscall.SIGTERM}
        if signal.Ignored(syscall.SIGHUP) </span><span class="cov0" title="0">{
                signalToNotify = []os.Signal{syscall.SIGINT, syscall.SIGTERM}
        }</span>

        <span class="cov8" title="1">signals := make(chan os.Signal, 1)
        signal.Notify(signals, signalToNotify...)

        select </span>{
        case sig := &lt;-signals:<span class="cov8" title="1">
                switch sig </span>{
                case syscall.SIGTERM:<span class="cov0" title="0">
                        // force exit
                        return errors.NewPublic(sig.String())</span> // nolint
                case syscall.SIGHUP, syscall.SIGINT:<span class="cov8" title="1">
                        hlog.SystemLogger().Infof("Received signal: %s\n", sig)
                        // graceful shutdown
                        return nil</span>
                }
        case err := &lt;-errCh:<span class="cov8" title="1">
                // error occurs, exit immediately
                return err</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (h *Hertz) initOnRunHooks(errChan chan error) <span class="cov8" title="1">{
        // add register func to runHooks
        opt := h.GetOptions()
        h.OnRun = append(h.OnRun, func(ctx context.Context) error </span><span class="cov8" title="1">{
                go func() </span><span class="cov8" title="1">{
                        // delay register 1s
                        time.Sleep(1 * time.Second)
                        if err := opt.Registry.Register(opt.RegistryInfo); err != nil </span><span class="cov8" title="1">{
                                hlog.SystemLogger().Errorf("Register error=%v", err)
                                // pass err to errChan
                                errChan &lt;- err
                        }</span>
                }()
                <span class="cov8" title="1">return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file23" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package server

import (
        "context"
        "crypto/tls"
        "net"
        "strings"
        "time"

        "github.com/cloudwego/hertz/pkg/app/server/binding"
        "github.com/cloudwego/hertz/pkg/app/server/registry"
        "github.com/cloudwego/hertz/pkg/common/config"
        "github.com/cloudwego/hertz/pkg/common/tracer"
        "github.com/cloudwego/hertz/pkg/common/tracer/stats"
        "github.com/cloudwego/hertz/pkg/network"
        "github.com/cloudwego/hertz/pkg/network/standard"
)

// WithKeepAliveTimeout sets keep-alive timeout.
//
// In most cases, there is no need to care about this option.
func WithKeepAliveTimeout(t time.Duration) config.Option <span class="cov8" title="1">{
        return config.Option{F: func(o *config.Options) </span><span class="cov8" title="1">{
                o.KeepAliveTimeout = t
        }</span>}
}

// WithReadTimeout sets read timeout.
//
// Close the connection when read request timeout.
func WithReadTimeout(t time.Duration) config.Option <span class="cov8" title="1">{
        return config.Option{F: func(o *config.Options) </span><span class="cov8" title="1">{
                o.ReadTimeout = t
        }</span>}
}

// WithWriteTimeout sets write timeout.
//
// Connection will be closed when write request timeout.
func WithWriteTimeout(t time.Duration) config.Option <span class="cov8" title="1">{
        return config.Option{F: func(o *config.Options) </span><span class="cov8" title="1">{
                o.WriteTimeout = t
        }</span>}
}

// WithIdleTimeout sets idle timeout.
//
// Close the connection when the successive request timeout (in keepalive mode).
// Set this to protect server from misbehavior clients.
func WithIdleTimeout(t time.Duration) config.Option <span class="cov8" title="1">{
        return config.Option{F: func(o *config.Options) </span><span class="cov8" title="1">{
                o.IdleTimeout = t
        }</span>}
}

// WithRedirectTrailingSlash sets redirectTrailingSlash.
//
// Enables automatic redirection if the current route can't be matched but a
// handler for the path with (without) the trailing slash exists.
// For example if /foo/ is requested but a route only exists for /foo, the
// client is redirected to /foo with http status code 301 for GET requests
// and 307 for all other request methods.
func WithRedirectTrailingSlash(b bool) config.Option <span class="cov8" title="1">{
        return config.Option{F: func(o *config.Options) </span><span class="cov8" title="1">{
                o.RedirectTrailingSlash = b
        }</span>}
}

// WithRedirectFixedPath sets redirectFixedPath.
//
// If enabled, the router tries to fix the current request path, if no
// handle is registered for it.
// First superfluous path elements like ../ or // are removed.
// Afterwards the router does a case-insensitive lookup of the cleaned path.
// If a handle can be found for this route, the router makes a redirection
// to the corrected path with status code 301 for GET requests and 308 for
// all other request methods.
// For example /FOO and /..//Foo could be redirected to /foo.
// RedirectTrailingSlash is independent of this option.
func WithRedirectFixedPath(b bool) config.Option <span class="cov8" title="1">{
        return config.Option{F: func(o *config.Options) </span><span class="cov8" title="1">{
                o.RedirectFixedPath = b
        }</span>}
}

// WithHandleMethodNotAllowed sets handleMethodNotAllowed.
//
// If enabled, the router checks if another method is allowed for the
// current route, if the current request can not be routed.
// If this is the case, the request is answered with 'Method Not Allowed'
// and HTTP status code 405.
// If no other Method is allowed, the request is delegated to the NotFound
// handler.
func WithHandleMethodNotAllowed(b bool) config.Option <span class="cov8" title="1">{
        return config.Option{F: func(o *config.Options) </span><span class="cov8" title="1">{
                o.HandleMethodNotAllowed = b
        }</span>}
}

// WithUseRawPath sets useRawPath.
//
// If enabled, the url.RawPath will be used to find parameters.
func WithUseRawPath(b bool) config.Option <span class="cov8" title="1">{
        return config.Option{F: func(o *config.Options) </span><span class="cov8" title="1">{
                o.UseRawPath = b
        }</span>}
}

// WithRemoveExtraSlash sets removeExtraSlash.
//
// RemoveExtraSlash a parameter can be parsed from the URL even with extra slashes.
// If UseRawPath is false (by default), the RemoveExtraSlash effectively is true,
// as url.Path gonna be used, which is already cleaned.
func WithRemoveExtraSlash(b bool) config.Option <span class="cov8" title="1">{
        return config.Option{F: func(o *config.Options) </span><span class="cov8" title="1">{
                o.RemoveExtraSlash = b
        }</span>}
}

// WithUnescapePathValues sets unescapePathValues.
//
// If true, the path value will be unescaped.
// If UseRawPath is false (by default), the UnescapePathValues effectively is true,
// as url.Path gonna be used, which is already unescaped.
func WithUnescapePathValues(b bool) config.Option <span class="cov8" title="1">{
        return config.Option{F: func(o *config.Options) </span><span class="cov8" title="1">{
                o.UnescapePathValues = b
        }</span>}
}

// WithDisablePreParseMultipartForm sets disablePreParseMultipartForm.
//
// This option is useful for servers that desire to treat
// multipart form data as a binary blob, or choose when to parse the data.
// Server pre parses multipart form data by default.
func WithDisablePreParseMultipartForm(b bool) config.Option <span class="cov8" title="1">{
        return config.Option{F: func(o *config.Options) </span><span class="cov8" title="1">{
                o.DisablePreParseMultipartForm = b
        }</span>}
}

// WithHostPorts sets listening address.
func WithHostPorts(hp string) config.Option <span class="cov8" title="1">{
        return config.Option{F: func(o *config.Options) </span><span class="cov8" title="1">{
                o.Addr = hp
        }</span>}
}

// WithBasePath sets basePath.Must be "/" prefix and suffix,If not the default concatenate "/"
func WithBasePath(basePath string) config.Option <span class="cov8" title="1">{
        return config.Option{F: func(o *config.Options) </span><span class="cov8" title="1">{
                // Must be "/" prefix and suffix,If not the default concatenate "/"
                if !strings.HasPrefix(basePath, "/") </span><span class="cov0" title="0">{
                        basePath = "/" + basePath
                }</span>
                <span class="cov8" title="1">if !strings.HasSuffix(basePath, "/") </span><span class="cov8" title="1">{
                        basePath = basePath + "/"
                }</span>
                <span class="cov8" title="1">o.BasePath = basePath</span>
        }}
}

// WithMaxRequestBodySize sets the limitation of request body size. Unit: byte
//
// Body buffer which larger than this size will be put back into buffer poll.
func WithMaxRequestBodySize(bs int) config.Option <span class="cov8" title="1">{
        return config.Option{F: func(o *config.Options) </span><span class="cov8" title="1">{
                o.MaxRequestBodySize = bs
        }</span>}
}

// WithMaxKeepBodySize sets max size of request/response body to keep when recycled. Unit: byte
//
// Body buffer which larger than this size will be put back into buffer poll.
// Note: If memory pressure is high, try setting the value to 0.
func WithMaxKeepBodySize(bs int) config.Option <span class="cov8" title="1">{
        return config.Option{F: func(o *config.Options) </span><span class="cov8" title="1">{
                o.MaxKeepBodySize = bs
        }</span>}
}

// WithGetOnly sets whether accept GET request only. Default: false
func WithGetOnly(isOnly bool) config.Option <span class="cov8" title="1">{
        return config.Option{F: func(o *config.Options) </span><span class="cov8" title="1">{
                o.GetOnly = isOnly
        }</span>}
}

// WithKeepAlive sets Whether use long connection. Default: true
func WithKeepAlive(b bool) config.Option <span class="cov8" title="1">{
        return config.Option{F: func(o *config.Options) </span><span class="cov8" title="1">{
                o.DisableKeepalive = !b
        }</span>}
}

// WithStreamBody determines whether read body in stream or not.
//
// StreamRequestBody enables streaming request body,
// and calls the handler sooner when given body is
// larger than the current limit.
func WithStreamBody(b bool) config.Option <span class="cov8" title="1">{
        return config.Option{F: func(o *config.Options) </span><span class="cov8" title="1">{
                o.StreamRequestBody = b
        }</span>}
}

// WithNetwork sets network. Support "tcp", "udp", "unix"(unix domain socket).
func WithNetwork(nw string) config.Option <span class="cov8" title="1">{
        return config.Option{F: func(o *config.Options) </span><span class="cov8" title="1">{
                o.Network = nw
        }</span>}
}

// WithExitWaitTime sets timeout for graceful shutdown.
//
// The server may exit ahead after all connections closed.
// All responses after shutdown will be added 'Connection: close' header.
func WithExitWaitTime(timeout time.Duration) config.Option <span class="cov8" title="1">{
        return config.Option{F: func(o *config.Options) </span><span class="cov8" title="1">{
                o.ExitWaitTimeout = timeout
        }</span>}
}

// WithTLS sets TLS config to start a tls server.
//
// NOTE: If a tls server is started, it won't accept non-tls request.
func WithTLS(cfg *tls.Config) config.Option <span class="cov8" title="1">{
        return config.Option{F: func(o *config.Options) </span><span class="cov8" title="1">{
                // If there is no explicit transporter, change it to standard one. Netpoll do not support tls yet.
                if o.TransporterNewer == nil </span><span class="cov8" title="1">{
                        o.TransporterNewer = standard.NewTransporter
                }</span>
                <span class="cov8" title="1">o.TLS = cfg</span>
        }}
}

// WithListenConfig sets listener config.
func WithListenConfig(l *net.ListenConfig) config.Option <span class="cov8" title="1">{
        return config.Option{F: func(o *config.Options) </span><span class="cov8" title="1">{
                o.ListenConfig = l
        }</span>}
}

// WithTransport sets which network library to use.
func WithTransport(transporter func(options *config.Options) network.Transporter) config.Option <span class="cov8" title="1">{
        return config.Option{F: func(o *config.Options) </span><span class="cov8" title="1">{
                o.TransporterNewer = transporter
        }</span>}
}

// WithAltTransport sets which network library to use as an alternative transporter(need to be implemented by specific transporter).
func WithAltTransport(transporter func(options *config.Options) network.Transporter) config.Option <span class="cov8" title="1">{
        return config.Option{F: func(o *config.Options) </span><span class="cov8" title="1">{
                o.AltTransporterNewer = transporter
        }</span>}
}

// WithH2C sets whether enable H2C.
func WithH2C(enable bool) config.Option <span class="cov8" title="1">{
        return config.Option{F: func(o *config.Options) </span><span class="cov8" title="1">{
                o.H2C = enable
        }</span>}
}

// WithReadBufferSize sets the read buffer size which also limit the header size.
func WithReadBufferSize(size int) config.Option <span class="cov8" title="1">{
        return config.Option{F: func(o *config.Options) </span><span class="cov8" title="1">{
                o.ReadBufferSize = size
        }</span>}
}

// WithALPN sets whether enable ALPN.
func WithALPN(enable bool) config.Option <span class="cov8" title="1">{
        return config.Option{F: func(o *config.Options) </span><span class="cov8" title="1">{
                o.ALPN = enable
        }</span>}
}

// WithTracer adds tracer to server.
func WithTracer(t tracer.Tracer) config.Option <span class="cov8" title="1">{
        return config.Option{F: func(o *config.Options) </span><span class="cov8" title="1">{
                o.Tracers = append(o.Tracers, t)
        }</span>}
}

// WithTraceLevel sets the level trace.
func WithTraceLevel(level stats.Level) config.Option <span class="cov8" title="1">{
        return config.Option{F: func(o *config.Options) </span><span class="cov8" title="1">{
                o.TraceLevel = level
        }</span>}
}

// WithRegistry sets the registry and registry's info
func WithRegistry(r registry.Registry, info *registry.Info) config.Option <span class="cov8" title="1">{
        return config.Option{F: func(o *config.Options) </span><span class="cov8" title="1">{
                o.Registry = r
                o.RegistryInfo = info
        }</span>}
}

// WithAutoReloadRender sets the config of auto reload render.
// If auto reload render is enabled:
// 1. interval = 0 means reload render according to file watch mechanism.(recommended)
// 2. interval &gt; 0 means reload render every interval.
func WithAutoReloadRender(b bool, interval time.Duration) config.Option <span class="cov8" title="1">{
        return config.Option{F: func(o *config.Options) </span><span class="cov8" title="1">{
                o.AutoReloadRender = b
                o.AutoReloadInterval = interval
        }</span>}
}

// WithDisablePrintRoute sets whether disable debugPrintRoute
// If we don't set it, it will default to false
func WithDisablePrintRoute(b bool) config.Option <span class="cov8" title="1">{
        return config.Option{F: func(o *config.Options) </span><span class="cov8" title="1">{
                o.DisablePrintRoute = b
        }</span>}
}

// WithOnAccept sets the callback function when a new connection is accepted but cannot
// receive data in netpoll. In go net, it will be called before converting tls connection
func WithOnAccept(fn func(conn net.Conn) context.Context) config.Option <span class="cov8" title="1">{
        return config.Option{F: func(o *config.Options) </span><span class="cov8" title="1">{
                o.OnAccept = fn
        }</span>}
}

// WithOnConnect sets the onConnect function. It can received data from connection in netpoll.
// In go net, it will be called after converting tls connection.
func WithOnConnect(fn func(ctx context.Context, conn network.Conn) context.Context) config.Option <span class="cov8" title="1">{
        return config.Option{F: func(o *config.Options) </span><span class="cov8" title="1">{
                o.OnConnect = fn
        }</span>}
}

// WithBindConfig sets bind config.
func WithBindConfig(bc *binding.BindConfig) config.Option <span class="cov8" title="1">{
        return config.Option{F: func(o *config.Options) </span><span class="cov8" title="1">{
                o.BindConfig = bc
        }</span>}
}

// WithValidateConfig sets validate config.
func WithValidateConfig(vc *binding.ValidateConfig) config.Option <span class="cov8" title="1">{
        return config.Option{F: func(o *config.Options) </span><span class="cov8" title="1">{
                o.ValidateConfig = vc
        }</span>}
}

// WithCustomBinder sets customized Binder.
func WithCustomBinder(b binding.Binder) config.Option <span class="cov8" title="1">{
        return config.Option{F: func(o *config.Options) </span><span class="cov8" title="1">{
                o.CustomBinder = b
        }</span>}
}

// WithCustomValidator sets customized Binder.
func WithCustomValidator(b binding.StructValidator) config.Option <span class="cov8" title="1">{
        return config.Option{F: func(o *config.Options) </span><span class="cov8" title="1">{
                o.CustomValidator = b
        }</span>}
}

// WithDisableHeaderNamesNormalizing is used to set whether disable header names normalizing.
func WithDisableHeaderNamesNormalizing(disable bool) config.Option <span class="cov8" title="1">{
        return config.Option{F: func(o *config.Options) </span><span class="cov8" title="1">{
                o.DisableHeaderNamesNormalizing = disable
        }</span>}
}

func WithDisableDefaultDate(disable bool) config.Option <span class="cov8" title="1">{
        return config.Option{F: func(o *config.Options) </span><span class="cov8" title="1">{
                o.NoDefaultDate = disable
        }</span>}
}

func WithDisableDefaultContentType(disable bool) config.Option <span class="cov8" title="1">{
        return config.Option{F: func(o *config.Options) </span><span class="cov8" title="1">{
                o.NoDefaultContentType = disable
        }</span>}
}

// WithSenseClientDisconnection sets the ability to sense client disconnections.
// If we don't set it, it will default to false.
// There are two issues to note when using this option:
// 1. Warning: It only applies to netpoll.
// 2. After opening, the context.Context in the request will be cancelled.
//
//        Example:
//        server.Default(
//        server.WithSenseClientDisconnection(true),
//        )
func WithSenseClientDisconnection(b bool) config.Option <span class="cov8" title="1">{
        return config.Option{F: func(o *config.Options) </span><span class="cov8" title="1">{
                o.SenseClientDisconnection = b
        }</span>}
}
</pre>
		
		<pre class="file" id="file24" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package registry

import "net"

const (
        DefaultWeight = 10
)

// Registry is extension interface of service registry.
type Registry interface {
        Register(info *Info) error
        Deregister(info *Info) error
}

// Info is used for registry.
// The fields are just suggested, which is used depends on design.
type Info struct {
        // ServiceName will be set in hertz by default
        ServiceName string
        // Addr will be set in hertz by default
        Addr net.Addr
        // Weight will be set in hertz by default
        Weight int
        // extend other infos with Tags.
        Tags map[string]string
}

// NoopRegistry is an empty implement of Registry
var NoopRegistry Registry = &amp;noopRegistry{}

// NoopRegistry
type noopRegistry struct{}

func (e noopRegistry) Register(*Info) error <span class="cov8" title="1">{
        return nil
}</span>

func (e noopRegistry) Deregister(*Info) error <span class="cov8" title="1">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Manuel MartÃ­nez-Almeida
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.

 * This file may have been modified by CloudWeGo authors. All CloudWeGo
 * Modifications are Copyright 2022 CloudWeGo Authors.
 */

package render

import "github.com/cloudwego/hertz/pkg/protocol"

// Data contains ContentType and bytes data.
type Data struct {
        ContentType string
        Data        []byte
}

// Render (Data) writes data with custom ContentType.
func (r Data) Render(resp *protocol.Response) (err error) <span class="cov8" title="1">{
        r.WriteContentType(resp)
        resp.AppendBody(r.Data)
        return
}</span>

// WriteContentType (Data) writes custom ContentType.
func (r Data) WriteContentType(resp *protocol.Response) <span class="cov8" title="1">{
        writeContentType(resp, r.ContentType)
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Manuel MartÃ­nez-Almeida
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.

 * This file may have been modified by CloudWeGo authors. All CloudWeGo
 * Modifications are Copyright 2022 CloudWeGo Authors.
 */

package render

import (
        "html/template"
        "log"
        "sync"
        "time"

        "github.com/cloudwego/hertz/pkg/common/hlog"
        "github.com/cloudwego/hertz/pkg/protocol"
        "github.com/fsnotify/fsnotify"
)

// Delims represents a set of Left and Right delimiters for HTML template rendering.
type Delims struct {
        // Left delimiter, defaults to {{.
        Left string
        // Right delimiter, defaults to }}.
        Right string
}

// HTMLRender interface is to be implemented by HTMLProduction and HTMLDebug.
type HTMLRender interface {
        // Instance returns an HTML instance.
        Instance(string, interface{}) Render
        Close() error
}

// HTMLProduction contains template reference and its delims.
type HTMLProduction struct {
        Template *template.Template
}

// HTML contains template reference and its name with given interface object.
type HTML struct {
        Template *template.Template
        Name     string
        Data     interface{}
}

var htmlContentType = "text/html; charset=utf-8"

// Instance (HTMLProduction) returns an HTML instance which it realizes Render interface.
func (r HTMLProduction) Instance(name string, data interface{}) Render <span class="cov8" title="1">{
        return HTML{
                Template: r.Template,
                Name:     name,
                Data:     data,
        }
}</span>

func (r HTMLProduction) Close() error <span class="cov8" title="1">{
        return nil
}</span>

// Render (HTML) executes template and writes its result with custom ContentType for response.
func (r HTML) Render(resp *protocol.Response) error <span class="cov8" title="1">{
        r.WriteContentType(resp)

        if r.Name == "" </span><span class="cov0" title="0">{
                return r.Template.Execute(resp.BodyWriter(), r.Data)
        }</span>
        <span class="cov8" title="1">return r.Template.ExecuteTemplate(resp.BodyWriter(), r.Name, r.Data)</span>
}

// WriteContentType (HTML) writes HTML ContentType.
func (r HTML) WriteContentType(resp *protocol.Response) <span class="cov8" title="1">{
        writeContentType(resp, htmlContentType)
}</span>

type HTMLDebug struct {
        sync.Once
        Template        *template.Template
        RefreshInterval time.Duration

        Files   []string
        FuncMap template.FuncMap
        Delims  Delims

        reloadCh chan struct{}
        watcher  *fsnotify.Watcher
}

func (h *HTMLDebug) Instance(name string, data interface{}) Render <span class="cov8" title="1">{
        h.Do(func() </span><span class="cov8" title="1">{
                h.startChecker()
        }</span>)

        <span class="cov8" title="1">select </span>{
        case &lt;-h.reloadCh:<span class="cov0" title="0">
                h.reload()</span>
        default:<span class="cov8" title="1"></span>
        }

        <span class="cov8" title="1">return HTML{
                Template: h.Template,
                Name:     name,
                Data:     data,
        }</span>
}

func (h *HTMLDebug) Close() error <span class="cov8" title="1">{
        if h.watcher == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return h.watcher.Close()</span>
}

func (h *HTMLDebug) reload() <span class="cov8" title="1">{
        h.Template = template.Must(template.New("").
                Delims(h.Delims.Left, h.Delims.Right).
                Funcs(h.FuncMap).
                ParseFiles(h.Files...))
}</span>

func (h *HTMLDebug) startChecker() <span class="cov8" title="1">{
        h.reloadCh = make(chan struct{})

        if h.RefreshInterval &gt; 0 </span><span class="cov8" title="1">{
                go func() </span><span class="cov8" title="1">{
                        hlog.SystemLogger().Debugf("[HTMLDebug] HTML template reloader started with interval %v", h.RefreshInterval)
                        for range time.Tick(h.RefreshInterval) </span><span class="cov8" title="1">{
                                hlog.SystemLogger().Debugf("[HTMLDebug] triggering HTML template reloader")
                                h.reloadCh &lt;- struct{}{}
                                hlog.SystemLogger().Debugf("[HTMLDebug] HTML template has been reloaded, next reload in %v", h.RefreshInterval)
                        }</span>
                }()
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">watcher, err := fsnotify.NewWatcher()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov8" title="1">h.watcher = watcher
        for _, f := range h.Files </span><span class="cov8" title="1">{
                err := watcher.Add(f)
                hlog.SystemLogger().Debugf("[HTMLDebug] watching file: %s", f)
                if err != nil </span><span class="cov0" title="0">{
                        hlog.SystemLogger().Errorf("[HTMLDebug] add watching file: %s, error happened: %v", f, err)
                }</span>

        }

        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                hlog.SystemLogger().Debugf("[HTMLDebug] HTML template reloader started with file watcher")
                for </span><span class="cov8" title="1">{
                        select </span>{
                        case event, ok := &lt;-watcher.Events:<span class="cov8" title="1">
                                if !ok </span><span class="cov8" title="1">{
                                        return
                                }</span>
                                <span class="cov8" title="1">if event.Op&amp;fsnotify.Write == fsnotify.Write </span><span class="cov8" title="1">{
                                        hlog.SystemLogger().Debugf("[HTMLDebug] modified file: %s, html render template will be reloaded at the next rendering", event.Name)
                                        h.reloadCh &lt;- struct{}{}
                                        hlog.SystemLogger().Debugf("[HTMLDebug] HTML template has been reloaded")
                                }</span>
                        case err, ok := &lt;-watcher.Errors:<span class="cov0" title="0">
                                if !ok </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov0" title="0">hlog.SystemLogger().Errorf("error happened when watching the rendering files: %v", err)</span>
                        }
                }
        }()
}
</pre>
		
		<pre class="file" id="file27" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Manuel MartÃ­nez-Almeida
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.

 * This file may have been modified by CloudWeGo authors. All CloudWeGo
 * Modifications are Copyright 2022 CloudWeGo Authors.
 */

package render

import (
        "bytes"
        "encoding/json"

        hjson "github.com/cloudwego/hertz/pkg/common/json"
        "github.com/cloudwego/hertz/pkg/protocol"
)

// JSONMarshaler customize json.Marshal as you like
type JSONMarshaler func(v interface{}) ([]byte, error)

var jsonMarshalFunc JSONMarshaler

func init() <span class="cov8" title="1">{
        ResetJSONMarshal(hjson.Marshal)
}</span>

func ResetJSONMarshal(fn JSONMarshaler) <span class="cov8" title="1">{
        jsonMarshalFunc = fn
}</span>

func ResetStdJSONMarshal() <span class="cov8" title="1">{
        ResetJSONMarshal(json.Marshal)
}</span>

// JSONRender JSON contains the given interface object.
type JSONRender struct {
        Data interface{}
}

var jsonContentType = "application/json; charset=utf-8"

// Render (JSON) writes data with custom ContentType.
func (r JSONRender) Render(resp *protocol.Response) error <span class="cov8" title="1">{
        writeContentType(resp, jsonContentType)
        jsonBytes, err := jsonMarshalFunc(r.Data)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">resp.AppendBody(jsonBytes)
        return nil</span>
}

// WriteContentType (JSON) writes JSON ContentType.
func (r JSONRender) WriteContentType(resp *protocol.Response) <span class="cov8" title="1">{
        writeContentType(resp, jsonContentType)
}</span>

// PureJSON contains the given interface object.
type PureJSON struct {
        Data interface{}
}

// Render (JSON) writes data with custom ContentType.
func (r PureJSON) Render(resp *protocol.Response) (err error) <span class="cov8" title="1">{
        r.WriteContentType(resp)
        buffer := new(bytes.Buffer)
        encoder := json.NewEncoder(buffer)
        encoder.SetEscapeHTML(false)
        err = encoder.Encode(r.Data)
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">resp.AppendBody(buffer.Bytes())
        return</span>
}

// WriteContentType (JSON) writes JSON ContentType.
func (r PureJSON) WriteContentType(resp *protocol.Response) <span class="cov8" title="1">{
        writeContentType(resp, jsonContentType)
}</span>

// IndentedJSON contains the given interface object.
type IndentedJSON struct {
        Data interface{}
}

// Render (IndentedJSON) marshals the given interface object and writes it with custom ContentType.
func (r IndentedJSON) Render(resp *protocol.Response) (err error) <span class="cov8" title="1">{
        writeContentType(resp, jsonContentType)
        jsonBytes, err := jsonMarshalFunc(r.Data)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">var buf bytes.Buffer
        err = json.Indent(&amp;buf, jsonBytes, "", "    ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">resp.AppendBody(buf.Bytes())
        return nil</span>
}

// WriteContentType (JSON) writes JSON ContentType.
func (r IndentedJSON) WriteContentType(resp *protocol.Response) <span class="cov8" title="1">{
        writeContentType(resp, jsonContentType)
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Manuel MartÃ­nez-Almeida
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.

 * This file may have been modified by CloudWeGo authors. All CloudWeGo
 * Modifications are Copyright 2022 CloudWeGo Authors.
 */

package render

import (
        "github.com/cloudwego/hertz/pkg/protocol"
        "google.golang.org/protobuf/proto"
)

// ProtoBuf contains the given interface object.
type ProtoBuf struct {
        Data interface{}
}

var protobufContentType = "application/x-protobuf"

// Render (ProtoBuf) marshals the given interface object and writes data with custom ContentType.
func (r ProtoBuf) Render(resp *protocol.Response) error <span class="cov8" title="1">{
        r.WriteContentType(resp)
        bytes, err := proto.Marshal(r.Data.(proto.Message))
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">resp.AppendBody(bytes)
        return nil</span>
}

// WriteContentType (ProtoBuf) writes ProtoBuf ContentType.
func (r ProtoBuf) WriteContentType(resp *protocol.Response) <span class="cov8" title="1">{
        writeContentType(resp, protobufContentType)
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Manuel MartÃ­nez-Almeida
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.

 * This file may have been modified by CloudWeGo authors. All CloudWeGo
 * Modifications are Copyright 2022 CloudWeGo Authors.
 */

package render

import "github.com/cloudwego/hertz/pkg/protocol"

// Render interface is to be implemented by JSON, XML, HTML, YAML and so on.
type Render interface {
        // Render writes data with custom ContentType.
        // Do not panic inside, RequestContext will handle it.
        Render(resp *protocol.Response) error
        // WriteContentType writes custom ContentType.
        WriteContentType(resp *protocol.Response)
}

var (
        _ Render = JSONRender{}
        _ Render = String{}
        _ Render = Data{}
)

func writeContentType(resp *protocol.Response, value string) <span class="cov8" title="1">{
        resp.Header.SetContentType(value)
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Manuel MartÃ­nez-Almeida
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.

 * This file may have been modified by CloudWeGo authors. All CloudWeGo
 * Modifications are Copyright 2022 CloudWeGo Authors.
 */

package render

import (
        "fmt"

        "github.com/cloudwego/hertz/pkg/protocol"
)

// String contains the given interface object slice and its format.
type String struct {
        Format string
        Data   []interface{}
}

var plainContentType = "text/plain; charset=utf-8"

// Render (String) writes data with custom ContentType.
func (r String) Render(resp *protocol.Response) error <span class="cov8" title="1">{
        writeContentType(resp, plainContentType)
        output := r.Format
        if len(r.Data) &gt; 0 </span><span class="cov8" title="1">{
                output = fmt.Sprintf(r.Format, r.Data...)
        }</span>
        <span class="cov8" title="1">resp.AppendBodyString(output)
        return nil</span>
}

// WriteContentType (String) writes Plain ContentType.
func (r String) WriteContentType(resp *protocol.Response) <span class="cov8" title="1">{
        writeContentType(resp, plainContentType)
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Manuel MartÃ­nez-Almeida
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.

 * This file may have been modified by CloudWeGo authors. All CloudWeGo
 * Modifications are Copyright 2022 CloudWeGo Authors.
 */

package render

import (
        "encoding/xml"

        "github.com/cloudwego/hertz/pkg/protocol"
)

// XML contains the given interface object.
type XML struct {
        Data interface{}
}

var xmlContentType = "application/xml; charset=utf-8"

// Render (XML) encodes the given interface object and writes data with custom ContentType.
func (r XML) Render(resp *protocol.Response) error <span class="cov8" title="1">{
        writeContentType(resp, xmlContentType)
        xmlBytes, err := xml.Marshal(r.Data)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">resp.AppendBody(xmlBytes)
        return nil</span>
}

// WriteContentType (XML) writes XML ContentType for response.
func (r XML) WriteContentType(w *protocol.Response) <span class="cov8" title="1">{
        writeContentType(w, xmlContentType)
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package adaptor

import (
        "bytes"
        "net/http"

        "github.com/cloudwego/hertz/pkg/protocol"
)

// GetCompatRequest only support basic function of Request, not for all.
func GetCompatRequest(req *protocol.Request) (*http.Request, error) <span class="cov8" title="1">{
        r, err := http.NewRequest(string(req.Method()), req.URI().String(), bytes.NewReader(req.Body()))
        if err != nil </span><span class="cov0" title="0">{
                return r, err
        }</span>

        <span class="cov8" title="1">h := make(map[string][]string)
        req.Header.VisitAll(func(k, v []byte) </span><span class="cov8" title="1">{
                h[string(k)] = append(h[string(k)], string(v))
        }</span>)

        <span class="cov8" title="1">r.Header = h
        return r, nil</span>
}

// CopyToHertzRequest copy uri, host, method, protocol, header, but share body reader from http.Request to protocol.Request.
func CopyToHertzRequest(req *http.Request, hreq *protocol.Request) error <span class="cov8" title="1">{
        hreq.Header.SetRequestURI(req.RequestURI)
        hreq.Header.SetHost(req.Host)
        hreq.Header.SetMethod(req.Method)
        hreq.Header.SetProtocol(req.Proto)
        for k, v := range req.Header </span><span class="cov8" title="1">{
                for _, vv := range v </span><span class="cov8" title="1">{
                        hreq.Header.Add(k, vv)
                }</span>
        }
        <span class="cov8" title="1">if req.Body != nil </span><span class="cov0" title="0">{
                hreq.SetBodyStream(req.Body, hreq.Header.ContentLength())
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package adaptor

import (
        "net/http"

        "github.com/cloudwego/hertz/pkg/protocol"
        "github.com/cloudwego/hertz/pkg/protocol/consts"
)

type compatResponse struct {
        h           *protocol.Response
        header      http.Header
        writeHeader bool
}

func (c *compatResponse) Header() http.Header <span class="cov8" title="1">{
        if c.header != nil </span><span class="cov8" title="1">{
                return c.header
        }</span>
        <span class="cov0" title="0">c.header = make(map[string][]string)
        return c.header</span>
}

func (c *compatResponse) Write(b []byte) (int, error) <span class="cov8" title="1">{
        if !c.writeHeader </span><span class="cov8" title="1">{
                c.WriteHeader(consts.StatusOK)
        }</span>

        <span class="cov8" title="1">return c.h.BodyWriter().Write(b)</span>
}

func (c *compatResponse) WriteHeader(statusCode int) <span class="cov8" title="1">{
        if !c.writeHeader </span><span class="cov8" title="1">{
                for k, v := range c.header </span><span class="cov8" title="1">{
                        for _, vv := range v </span><span class="cov8" title="1">{
                                if k == consts.HeaderContentLength </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">if k == consts.HeaderSetCookie </span><span class="cov8" title="1">{
                                        cookie := protocol.AcquireCookie()
                                        _ = cookie.Parse(vv)
                                        c.h.Header.SetCookie(cookie)
                                        continue</span>
                                }
                                <span class="cov8" title="1">c.h.Header.Add(k, vv)</span>
                        }
                }
                <span class="cov8" title="1">c.writeHeader = true</span>
        }

        <span class="cov8" title="1">c.h.Header.SetStatusCode(statusCode)</span>
}

// GetCompatResponseWriter only support basic function of ResponseWriter, not for all.
func GetCompatResponseWriter(resp *protocol.Response) http.ResponseWriter <span class="cov8" title="1">{
        c := &amp;compatResponse{
                h: resp,
        }
        c.h.Header.SetNoDefaultContentType(true)

        h := make(map[string][]string)
        tmpKey := make([][]byte, 0, c.h.Header.Len())
        c.h.Header.VisitAll(func(k, v []byte) </span><span class="cov8" title="1">{
                h[string(k)] = append(h[string(k)], string(v))
                tmpKey = append(tmpKey, k)
        }</span>)

        <span class="cov8" title="1">for _, k := range tmpKey </span><span class="cov8" title="1">{
                c.h.Header.DelBytes(k)
        }</span>

        <span class="cov8" title="1">c.header = h
        return c</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015-present Aliaksandr Valialkin, VertaMedia, Kirill Danshin, Erik Dubbelboer, FastHTTP Authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This file may have been modified by CloudWeGo authors. All CloudWeGo
 * Modifications are Copyright 2022 CloudWeGo Authors.
 */

package bytebufferpool

import "io"

// ByteBuffer provides byte buffer, which can be used for minimizing
// memory allocations.
//
// ByteBuffer may be used with functions appending data to the given []byte
// slice. See example code for details.
//
// Use Get for obtaining an empty byte buffer.
type ByteBuffer struct {
        // B is a byte buffer to use in append-like workloads.
        // See example code for details.
        B []byte
}

// Len returns the size of the byte buffer.
func (b *ByteBuffer) Len() int <span class="cov8" title="1">{
        return len(b.B)
}</span>

// ReadFrom implements io.ReaderFrom.
//
// The function appends all the data read from r to b.
func (b *ByteBuffer) ReadFrom(r io.Reader) (int64, error) <span class="cov8" title="1">{
        p := b.B
        nStart := int64(len(p))
        nMax := int64(cap(p))
        n := nStart
        if nMax == 0 </span><span class="cov0" title="0">{
                nMax = 64
                p = make([]byte, nMax)
        }</span> else<span class="cov8" title="1"> {
                p = p[:nMax]
        }</span>
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                if n == nMax </span><span class="cov8" title="1">{
                        nMax *= 2
                        bNew := make([]byte, nMax)
                        copy(bNew, p)
                        p = bNew
                }</span>
                <span class="cov8" title="1">nn, err := r.Read(p[n:])
                n += int64(nn)
                if err != nil </span><span class="cov8" title="1">{
                        b.B = p[:n]
                        n -= nStart
                        if err == io.EOF </span><span class="cov8" title="1">{
                                return n, nil
                        }</span>
                        <span class="cov0" title="0">return n, err</span>
                }
        }
}

// WriteTo implements io.WriterTo.
func (b *ByteBuffer) WriteTo(w io.Writer) (int64, error) <span class="cov8" title="1">{
        n, err := w.Write(b.B)
        return int64(n), err
}</span>

// Bytes returns b.B, i.e. all the bytes accumulated in the buffer.
//
// The purpose of this function is bytes.Buffer compatibility.
func (b *ByteBuffer) Bytes() []byte <span class="cov0" title="0">{
        return b.B
}</span>

// Write implements io.Writer - it appends p to ByteBuffer.B
func (b *ByteBuffer) Write(p []byte) (int, error) <span class="cov0" title="0">{
        b.B = append(b.B, p...)
        return len(p), nil
}</span>

// WriteByte appends the byte c to the buffer.
//
// The purpose of this function is bytes.Buffer compatibility.
//
// The function always returns nil.
func (b *ByteBuffer) WriteByte(c byte) error <span class="cov0" title="0">{
        b.B = append(b.B, c)
        return nil
}</span>

// WriteString appends s to ByteBuffer.B.
func (b *ByteBuffer) WriteString(s string) (int, error) <span class="cov8" title="1">{
        b.B = append(b.B, s...)
        return len(s), nil
}</span>

// Set sets ByteBuffer.B to p.
func (b *ByteBuffer) Set(p []byte) <span class="cov0" title="0">{
        b.B = append(b.B[:0], p...)
}</span>

// SetString sets ByteBuffer.B to s.
func (b *ByteBuffer) SetString(s string) <span class="cov8" title="1">{
        b.B = append(b.B[:0], s...)
}</span>

// String returns string representation of ByteBuffer.B.
func (b *ByteBuffer) String() string <span class="cov8" title="1">{
        return string(b.B)
}</span>

// Reset makes ByteBuffer.B empty.
func (b *ByteBuffer) Reset() <span class="cov8" title="1">{
        b.B = b.B[:0]
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015-present Aliaksandr Valialkin, VertaMedia, Kirill Danshin, Erik Dubbelboer, FastHTTP Authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This file may have been modified by CloudWeGo authors. All CloudWeGo
 * Modifications are Copyright 2022 CloudWeGo Authors.
 */

package bytebufferpool

import (
        "sort"
        "sync"
        "sync/atomic"
)

const (
        minBitSize = 6 // 2**6=64 is a CPU cache line size
        steps      = 20

        minSize = 1 &lt;&lt; minBitSize
        maxSize = 1 &lt;&lt; (minBitSize + steps - 1)

        calibrateCallsThreshold = 42000
        maxPercentile           = 0.95
)

// Pool represents byte buffer pool.
//
// Distinct pools may be used for distinct types of byte buffers.
// Properly determined byte buffer types with their own pools may help reducing
// memory waste.
type Pool struct {
        calls       [steps]uint64
        calibrating uint64

        defaultSize uint64
        maxSize     uint64

        pool sync.Pool
}

var defaultPool Pool

// Get returns an empty byte buffer from the pool.
//
// Got byte buffer may be returned to the pool via Put call.
// This reduces the number of memory allocations required for byte buffer
// management.
func Get() *ByteBuffer <span class="cov8" title="1">{ return defaultPool.Get() }</span>

// Get returns new byte buffer with zero length.
//
// The byte buffer may be returned to the pool via Put after the use
// in order to minimize GC overhead.
func (p *Pool) Get() *ByteBuffer <span class="cov8" title="1">{
        v := p.pool.Get()
        if v != nil </span><span class="cov8" title="1">{
                return v.(*ByteBuffer)
        }</span>
        <span class="cov8" title="1">return &amp;ByteBuffer{
                B: make([]byte, 0, atomic.LoadUint64(&amp;p.defaultSize)),
        }</span>
}

// Put returns byte buffer to the pool.
//
// ByteBuffer.B mustn't be touched after returning it to the pool.
// Otherwise data races will occur.
func Put(b *ByteBuffer) <span class="cov8" title="1">{ defaultPool.Put(b) }</span>

// Put releases byte buffer obtained via Get to the pool.
//
// The buffer mustn't be accessed after returning to the pool.
func (p *Pool) Put(b *ByteBuffer) <span class="cov8" title="1">{
        idx := index(len(b.B))

        if atomic.AddUint64(&amp;p.calls[idx], 1) &gt; calibrateCallsThreshold </span><span class="cov8" title="1">{
                p.calibrate()
        }</span>

        <span class="cov8" title="1">maxSize := int(atomic.LoadUint64(&amp;p.maxSize))
        if maxSize == 0 || cap(b.B) &lt;= maxSize </span><span class="cov8" title="1">{
                b.Reset()
                p.pool.Put(b)
        }</span>
}

func (p *Pool) calibrate() <span class="cov8" title="1">{
        if !atomic.CompareAndSwapUint64(&amp;p.calibrating, 0, 1) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">a := make(callSizes, 0, steps)
        var callsSum uint64
        for i := uint64(0); i &lt; steps; i++ </span><span class="cov8" title="1">{
                calls := atomic.SwapUint64(&amp;p.calls[i], 0)
                callsSum += calls
                a = append(a, callSize{
                        calls: calls,
                        size:  minSize &lt;&lt; i,
                })
        }</span>
        <span class="cov8" title="1">sort.Sort(a)

        defaultSize := a[0].size
        maxSize := defaultSize

        maxSum := uint64(float64(callsSum) * maxPercentile)
        callsSum = 0
        for i := 0; i &lt; steps; i++ </span><span class="cov8" title="1">{
                if callsSum &gt; maxSum </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">callsSum += a[i].calls
                size := a[i].size
                if size &gt; maxSize </span><span class="cov8" title="1">{
                        maxSize = size
                }</span>
        }

        <span class="cov8" title="1">atomic.StoreUint64(&amp;p.defaultSize, defaultSize)
        atomic.StoreUint64(&amp;p.maxSize, maxSize)

        atomic.StoreUint64(&amp;p.calibrating, 0)</span>
}

type callSize struct {
        calls uint64
        size  uint64
}

type callSizes []callSize

func (ci callSizes) Len() int <span class="cov8" title="1">{
        return len(ci)
}</span>

func (ci callSizes) Less(i, j int) bool <span class="cov8" title="1">{
        return ci[i].calls &gt; ci[j].calls
}</span>

func (ci callSizes) Swap(i, j int) <span class="cov8" title="1">{
        ci[i], ci[j] = ci[j], ci[i]
}</span>

func index(n int) int <span class="cov8" title="1">{
        n--
        n &gt;&gt;= minBitSize
        idx := 0
        for n &gt; 0 </span><span class="cov8" title="1">{
                n &gt;&gt;= 1
                idx++
        }</span>
        <span class="cov8" title="1">if idx &gt;= steps </span><span class="cov8" title="1">{
                idx = steps - 1
        }</span>
        <span class="cov8" title="1">return idx</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015-present Aliaksandr Valialkin, VertaMedia, Kirill Danshin, Erik Dubbelboer, FastHTTP Authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This file may have been modified by CloudWeGo authors. All CloudWeGo
 * Modifications are Copyright 2022 CloudWeGo Authors.
 */

package compress

import (
        "bytes"
        "compress/gzip"
        "fmt"
        "io"
        "sync"

        "github.com/cloudwego/hertz/pkg/common/bytebufferpool"
        "github.com/cloudwego/hertz/pkg/common/stackless"
        "github.com/cloudwego/hertz/pkg/common/utils"
        "github.com/cloudwego/hertz/pkg/network"
)

const CompressDefaultCompression = 6 // flate.DefaultCompression

var gzipReaderPool sync.Pool

var (
        stacklessGzipWriterPoolMap = newCompressWriterPoolMap()
        realGzipWriterPoolMap      = newCompressWriterPoolMap()
)

func newCompressWriterPoolMap() []*sync.Pool <span class="cov8" title="1">{
        // Initialize pools for all the compression levels defined
        // in https://golang.org/pkg/compress/flate/#pkg-constants .
        // Compression levels are normalized with normalizeCompressLevel,
        // so the fit [0..11].
        var m []*sync.Pool
        for i := 0; i &lt; 12; i++ </span><span class="cov8" title="1">{
                m = append(m, &amp;sync.Pool{})
        }</span>
        <span class="cov8" title="1">return m</span>
}

type compressCtx struct {
        w     io.Writer
        p     []byte
        level int
}

// AppendGunzipBytes appends gunzipped src to dst and returns the resulting dst.
func AppendGunzipBytes(dst, src []byte) ([]byte, error) <span class="cov8" title="1">{
        w := &amp;byteSliceWriter{dst}
        _, err := WriteGunzip(w, src)
        return w.b, err
}</span>

type byteSliceWriter struct {
        b []byte
}

func (w *byteSliceWriter) Write(p []byte) (int, error) <span class="cov8" title="1">{
        w.b = append(w.b, p...)
        return len(p), nil
}</span>

// WriteGunzip writes gunzipped p to w and returns the number of uncompressed
// bytes written to w.
func WriteGunzip(w io.Writer, p []byte) (int, error) <span class="cov8" title="1">{
        r := &amp;byteSliceReader{p}
        zr, err := AcquireGzipReader(r)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">zw := network.NewWriter(w)
        n, err := utils.CopyZeroAlloc(zw, zr)
        ReleaseGzipReader(zr)
        nn := int(n)
        if int64(nn) != n </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("too much data gunzipped: %d", n)
        }</span>
        <span class="cov8" title="1">return nn, err</span>
}

type byteSliceReader struct {
        b []byte
}

func (r *byteSliceReader) Read(p []byte) (int, error) <span class="cov8" title="1">{
        if len(r.b) == 0 </span><span class="cov8" title="1">{
                return 0, io.EOF
        }</span>
        <span class="cov8" title="1">n := copy(p, r.b)
        r.b = r.b[n:]
        return n, nil</span>
}

func AcquireGzipReader(r io.Reader) (*gzip.Reader, error) <span class="cov8" title="1">{
        v := gzipReaderPool.Get()
        if v == nil </span><span class="cov8" title="1">{
                return gzip.NewReader(r)
        }</span>
        <span class="cov8" title="1">zr := v.(*gzip.Reader)
        if err := zr.Reset(r); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return zr, nil</span>
}

func ReleaseGzipReader(zr *gzip.Reader) <span class="cov8" title="1">{
        zr.Close()
        gzipReaderPool.Put(zr)
}</span>

// AppendGzipBytes appends gzipped src to dst and returns the resulting dst.
func AppendGzipBytes(dst, src []byte) []byte <span class="cov0" title="0">{
        return AppendGzipBytesLevel(dst, src, CompressDefaultCompression)
}</span>

// AppendGzipBytesLevel appends gzipped src to dst using the given
// compression level and returns the resulting dst.
//
// Supported compression levels are:
//
//   - CompressNoCompression
//   - CompressBestSpeed
//   - CompressBestCompression
//   - CompressDefaultCompression
//   - CompressHuffmanOnly
func AppendGzipBytesLevel(dst, src []byte, level int) []byte <span class="cov8" title="1">{
        w := &amp;byteSliceWriter{dst}
        WriteGzipLevel(w, src, level) //nolint:errcheck
        return w.b
}</span>

var stacklessWriteGzip = stackless.NewFunc(nonblockingWriteGzip)

func nonblockingWriteGzip(ctxv interface{}) <span class="cov8" title="1">{
        ctx := ctxv.(*compressCtx)
        zw := acquireRealGzipWriter(ctx.w, ctx.level)

        _, err := zw.Write(ctx.p)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("BUG: gzip.Writer.Write for len(p)=%d returned unexpected error: %s", len(ctx.p), err))</span>
        }

        <span class="cov8" title="1">releaseRealGzipWriter(zw, ctx.level)</span>
}

func releaseRealGzipWriter(zw *gzip.Writer, level int) <span class="cov8" title="1">{
        zw.Close()
        nLevel := normalizeCompressLevel(level)
        p := realGzipWriterPoolMap[nLevel]
        p.Put(zw)
}</span>

func acquireRealGzipWriter(w io.Writer, level int) *gzip.Writer <span class="cov8" title="1">{
        nLevel := normalizeCompressLevel(level)
        p := realGzipWriterPoolMap[nLevel]
        v := p.Get()
        if v == nil </span><span class="cov8" title="1">{
                zw, err := gzip.NewWriterLevel(w, level)
                if err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("BUG: unexpected error from gzip.NewWriterLevel(%d): %s", level, err))</span>
                }
                <span class="cov8" title="1">return zw</span>
        }
        <span class="cov8" title="1">zw := v.(*gzip.Writer)
        zw.Reset(w)
        return zw</span>
}

// normalizes compression level into [0..11], so it could be used as an index
// in *PoolMap.
func normalizeCompressLevel(level int) int <span class="cov8" title="1">{
        // -2 is the lowest compression level - CompressHuffmanOnly
        // 9 is the highest compression level - CompressBestCompression
        if level &lt; -2 || level &gt; 9 </span><span class="cov0" title="0">{
                level = CompressDefaultCompression
        }</span>
        <span class="cov8" title="1">return level + 2</span>
}

// WriteGzipLevel writes gzipped p to w using the given compression level
// and returns the number of compressed bytes written to w.
//
// Supported compression levels are:
//
//   - CompressNoCompression
//   - CompressBestSpeed
//   - CompressBestCompression
//   - CompressDefaultCompression
//   - CompressHuffmanOnly
func WriteGzipLevel(w io.Writer, p []byte, level int) (int, error) <span class="cov8" title="1">{
        switch w.(type) </span>{
        case *byteSliceWriter,
                *bytes.Buffer,
                *bytebufferpool.ByteBuffer:<span class="cov8" title="1">
                // These writers don't block, so we can just use stacklessWriteGzip
                ctx := &amp;compressCtx{
                        w:     w,
                        p:     p,
                        level: level,
                }
                stacklessWriteGzip(ctx)
                return len(p), nil</span>
        default:<span class="cov8" title="1">
                zw := AcquireStacklessGzipWriter(w, level)
                n, err := zw.Write(p)
                ReleaseStacklessGzipWriter(zw, level)
                return n, err</span>
        }
}

func AcquireStacklessGzipWriter(w io.Writer, level int) stackless.Writer <span class="cov8" title="1">{
        nLevel := normalizeCompressLevel(level)
        p := stacklessGzipWriterPoolMap[nLevel]
        v := p.Get()
        if v == nil </span><span class="cov8" title="1">{
                return stackless.NewWriter(w, func(w io.Writer) stackless.Writer </span><span class="cov8" title="1">{
                        return acquireRealGzipWriter(w, level)
                }</span>)
        }
        <span class="cov0" title="0">sw := v.(stackless.Writer)
        sw.Reset(w)
        return sw</span>
}

func ReleaseStacklessGzipWriter(sw stackless.Writer, level int) <span class="cov8" title="1">{
        sw.Close()
        nLevel := normalizeCompressLevel(level)
        p := stacklessGzipWriterPoolMap[nLevel]
        p.Put(sw)
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import (
        "crypto/tls"
        "time"

        "github.com/cloudwego/hertz/pkg/app/client/retry"
        "github.com/cloudwego/hertz/pkg/network"
        "github.com/cloudwego/hertz/pkg/protocol/consts"
)

type ConnPoolState struct {
        // The conn num of conn pool. These conns are idle connections.
        PoolConnNum int
        // Total conn num.
        TotalConnNum int
        // Number of pending connections
        WaitConnNum int
        // HostClient Addr
        Addr string
}

type HostClientState interface {
        ConnPoolState() ConnPoolState
}

type HostClientStateFunc func(HostClientState)

// ClientOption is the only struct that can be used to set ClientOptions.
type ClientOption struct {
        F func(o *ClientOptions)
}

type ClientOptions struct {
        // Timeout for establishing a connection to server
        DialTimeout time.Duration
        // The max connection nums for each host
        MaxConnsPerHost int

        MaxIdleConnDuration time.Duration
        MaxConnDuration     time.Duration
        MaxConnWaitTimeout  time.Duration
        KeepAlive           bool
        ReadTimeout         time.Duration
        TLSConfig           *tls.Config
        ResponseBodyStream  bool

        // Client name. Used in User-Agent request header.
        //
        // Default client name is used if not set.
        Name string

        // NoDefaultUserAgentHeader when set to true, causes the default
        // User-Agent header to be excluded from the Request.
        NoDefaultUserAgentHeader bool

        // Dialer is the custom dialer used to establish connection.
        // Default Dialer is used if not set.
        Dialer network.Dialer

        // Attempt to connect to both ipv4 and ipv6 addresses if set to true.
        //
        // This option is used only if default TCP dialer is used,
        // i.e. if Dialer is blank.
        //
        // By default client connects only to ipv4 addresses,
        // since unfortunately ipv6 remains broken in many networks worldwide :)
        DialDualStack bool

        // Maximum duration for full request writing (including body).
        //
        // By default request write timeout is unlimited.
        WriteTimeout time.Duration

        // Maximum response body size.
        //
        // The client returns ErrBodyTooLarge if this limit is greater than 0
        // and response body is greater than the limit.
        //
        // By default response body size is unlimited.
        MaxResponseBodySize int

        // Header names are passed as-is without normalization
        // if this option is set.
        //
        // Disabled header names' normalization may be useful only for proxying
        // responses to other clients expecting case-sensitive header names.
        //
        // By default request and response header names are normalized, i.e.
        // The first letter and the first letters following dashes
        // are uppercased, while all the other letters are lowercased.
        // Examples:
        //
        //     * HOST -&gt; Host
        //     * content-type -&gt; Content-Type
        //     * cONTENT-lenGTH -&gt; Content-Length
        DisableHeaderNamesNormalizing bool

        // Path values are sent as-is without normalization
        //
        // Disabled path normalization may be useful for proxying incoming requests
        // to servers that are expecting paths to be forwarded as-is.
        //
        // By default path values are normalized, i.e.
        // extra slashes are removed, special characters are encoded.
        DisablePathNormalizing bool

        // all configurations related to retry
        RetryConfig *retry.Config

        HostClientStateObserve HostClientStateFunc

        // StateObserve execution interval
        ObservationInterval time.Duration

        // Callback hook for re-configuring host client
        // If an error is returned, the request will be terminated.
        HostClientConfigHook func(hc interface{}) error
}

func NewClientOptions(opts []ClientOption) *ClientOptions <span class="cov8" title="1">{
        options := &amp;ClientOptions{
                DialTimeout:         consts.DefaultDialTimeout,
                MaxConnsPerHost:     consts.DefaultMaxConnsPerHost,
                MaxIdleConnDuration: consts.DefaultMaxIdleConnDuration,
                KeepAlive:           true,
                ObservationInterval: time.Second * 5,
        }
        options.Apply(opts)

        return options
}</span>

func (o *ClientOptions) Apply(opts []ClientOption) <span class="cov8" title="1">{
        for _, op := range opts </span><span class="cov8" title="1">{
                op.F(o)
        }</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import (
        "context"
        "crypto/tls"
        "net"
        "time"

        "github.com/cloudwego/hertz/pkg/app/server/registry"
        "github.com/cloudwego/hertz/pkg/network"
)

// Option is the only struct that can be used to set Options.
type Option struct {
        F func(o *Options)
}

const (
        defaultKeepAliveTimeout   = 1 * time.Minute
        defaultReadTimeout        = 3 * time.Minute
        defaultAddr               = ":8888"
        defaultNetwork            = "tcp"
        defaultBasePath           = "/"
        defaultMaxRequestBodySize = 4 * 1024 * 1024
        defaultWaitExitTimeout    = time.Second * 5
        defaultReadBufferSize     = 4 * 1024
)

type Options struct {
        KeepAliveTimeout             time.Duration
        ReadTimeout                  time.Duration
        WriteTimeout                 time.Duration
        IdleTimeout                  time.Duration
        RedirectTrailingSlash        bool
        MaxRequestBodySize           int
        MaxKeepBodySize              int
        GetOnly                      bool
        DisableKeepalive             bool
        RedirectFixedPath            bool
        HandleMethodNotAllowed       bool
        UseRawPath                   bool
        RemoveExtraSlash             bool
        UnescapePathValues           bool
        DisablePreParseMultipartForm bool
        NoDefaultDate                bool
        NoDefaultContentType         bool
        StreamRequestBody            bool
        NoDefaultServerHeader        bool
        DisablePrintRoute            bool
        SenseClientDisconnection     bool
        Network                      string
        Addr                         string
        BasePath                     string
        ExitWaitTimeout              time.Duration
        TLS                          *tls.Config
        H2C                          bool
        ReadBufferSize               int
        ALPN                         bool
        Tracers                      []interface{}
        TraceLevel                   interface{}
        ListenConfig                 *net.ListenConfig
        BindConfig                   interface{}
        ValidateConfig               interface{}
        CustomBinder                 interface{}
        CustomValidator              interface{}

        // TransporterNewer is the function to create a transporter.
        TransporterNewer    func(opt *Options) network.Transporter
        AltTransporterNewer func(opt *Options) network.Transporter

        // In netpoll library, OnAccept is called after connection accepted
        // but before adding it to epoll. OnConnect is called after adding it to epoll.
        // The difference is that onConnect can get data but OnAccept cannot.
        // If you'd like to check whether the peer IP is in the blacklist, you can use OnAccept.
        // In go net, OnAccept is executed after connection accepted but before establishing
        // tls connection. OnConnect is executed after establishing tls connection.
        OnAccept  func(conn net.Conn) context.Context
        OnConnect func(ctx context.Context, conn network.Conn) context.Context

        // Registry is used for service registry.
        Registry registry.Registry
        // RegistryInfo is base info used for service registry.
        RegistryInfo *registry.Info
        // Enable automatically HTML template reloading mechanism.

        AutoReloadRender bool
        // If AutoReloadInterval is set to 0(default).
        // The HTML template will reload according to files' changing event
        // otherwise it will reload after AutoReloadInterval.
        AutoReloadInterval time.Duration

        // Header names are passed as-is without normalization
        // if this option is set.
        //
        // Disabled header names' normalization may be useful only for proxying
        // responses to other clients expecting case-sensitive header names.
        //
        // By default, request and response header names are normalized, i.e.
        // The first letter and the first letters following dashes
        // are uppercased, while all the other letters are lowercased.
        // Examples:
        //
        //     * HOST -&gt; Host
        //     * content-type -&gt; Content-Type
        //     * cONTENT-lenGTH -&gt; Content-Length
        DisableHeaderNamesNormalizing bool
}

func (o *Options) Apply(opts []Option) <span class="cov8" title="1">{
        for _, op := range opts </span><span class="cov8" title="1">{
                op.F(o)
        }</span>
}

func NewOptions(opts []Option) *Options <span class="cov8" title="1">{
        options := &amp;Options{
                // Keep-alive timeout. When idle connection exceeds this time,
                // server will send keep-alive packets to ensure it's a validated
                // connection.
                //
                // NOTE: Usually there is no need to care about this value, just
                // care about IdleTimeout.
                KeepAliveTimeout: defaultKeepAliveTimeout,

                // the timeout of reading from low-level library
                ReadTimeout: defaultReadTimeout,

                // When there is no request during the idleTimeout, the connection
                // will be closed by server.
                // Default to ReadTimeout. Zero means no timeout.
                IdleTimeout: defaultReadTimeout,

                // Enables automatic redirection if the current route can't be matched but a
                // handler for the path with (without) the trailing slash exists.
                // For example if /foo/ is requested but a route only exists for /foo, the
                // client is redirected to /foo with http status code 301 for GET requests
                // and 308 for all other request methods.
                RedirectTrailingSlash: true,

                // If enabled, the router tries to fix the current request path, if no
                // handle is registered for it.
                // First superfluous path elements like ../ or // are removed.
                // Afterwards the router does a case-insensitive lookup of the cleaned path.
                // If a handle can be found for this route, the router makes a redirection
                // to the corrected path with status code 301 for GET requests and 308 for
                // all other request methods.
                // For example /FOO and /..//Foo could be redirected to /foo.
                // RedirectTrailingSlash is independent of this option.
                RedirectFixedPath: false,

                // If enabled, the router checks if another method is allowed for the
                // current route, if the current request can not be routed.
                // If this is the case, the request is answered with 'Method Not Allowed'
                // and HTTP status code 405.
                // If no other Method is allowed, the request is delegated to the NotFound
                // handler.
                HandleMethodNotAllowed: false,

                // If enabled, the url.RawPath will be used to find parameters.
                UseRawPath: false,

                // RemoveExtraSlash a parameter can be parsed from the URL even with extra slashes.
                RemoveExtraSlash: false,

                // If true, the path value will be unescaped.
                // If UseRawPath is false (by default), the UnescapePathValues effectively is true,
                // as url.Path gonna be used, which is already unescaped.
                UnescapePathValues: true,

                // ContinueHandler is called after receiving the Expect 100 Continue Header
                //
                // https://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html#sec8.2.3
                // https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.1.1
                // Using ContinueHandler a server can make decisioning on whether or not
                // to read a potentially large request body based on the headers
                //
                // The default is to automatically read request bodies of Expect 100 Continue requests
                // like they are normal requests
                DisablePreParseMultipartForm: false,

                // When set to true, causes the default Content-Type header to be excluded from the response.
                NoDefaultContentType: false,

                // When set to true, causes the default date header to be excluded from the response.
                NoDefaultDate: false,

                // Routes info printing is not disabled by default
                // Disabled when set to True
                DisablePrintRoute: false,

                // The ability to sense client disconnection is disabled by default
                SenseClientDisconnection: false,

                // "tcp", "udp", "unix"(unix domain socket)
                Network: defaultNetwork,

                // listen address
                Addr: defaultAddr,

                // basePath
                BasePath: defaultBasePath,

                // Define the max request body size. If the body Size exceeds this value,
                // an error will be returned
                MaxRequestBodySize: defaultMaxRequestBodySize,

                // max reserved body buffer size when reset Request &amp; Response
                // If the body size exceeds this value, then the buffer will be put to
                // sync.Pool instead of hold by Request/Response directly.
                MaxKeepBodySize: defaultMaxRequestBodySize,

                // only accept GET request
                GetOnly: false,

                DisableKeepalive: false,

                // request body stream switch
                StreamRequestBody: false,

                NoDefaultServerHeader: false,

                // graceful shutdown wait time
                ExitWaitTimeout: defaultWaitExitTimeout,

                // tls config
                TLS: nil,

                // Set init read buffer size. Usually there is no need to set it.
                ReadBufferSize: defaultReadBufferSize,

                // ALPN switch
                ALPN: false,

                // H2C switch
                H2C: false,

                // tracers
                Tracers: []interface{}{},

                // trace level, default LevelDetailed
                TraceLevel: new(interface{}),

                Registry: registry.NoopRegistry,

                // Disabled header names' normalization, default false
                DisableHeaderNamesNormalizing: false,
        }
        options.Apply(opts)
        return options
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package config

import "time"

var preDefinedOpts []RequestOption

type RequestOptions struct {
        tags map[string]string
        isSD bool

        dialTimeout  time.Duration
        readTimeout  time.Duration
        writeTimeout time.Duration
        // Request timeout. Usually set by DoDeadline or DoTimeout
        // if &lt;= 0, means not set
        requestTimeout time.Duration
        start          time.Time
}

// RequestOption is the only struct to set request-level options.
type RequestOption struct {
        F func(o *RequestOptions)
}

// NewRequestOptions create a *RequestOptions according to the given opts.
func NewRequestOptions(opts []RequestOption) *RequestOptions <span class="cov8" title="1">{
        options := &amp;RequestOptions{
                tags: make(map[string]string),
                isSD: false,
        }
        if preDefinedOpts != nil </span><span class="cov8" title="1">{
                options.Apply(preDefinedOpts)
        }</span>
        <span class="cov8" title="1">options.Apply(opts)
        return options</span>
}

// WithTag set tag in RequestOptions.
func WithTag(k, v string) RequestOption <span class="cov8" title="1">{
        return RequestOption{F: func(o *RequestOptions) </span><span class="cov8" title="1">{
                o.tags[k] = v
        }</span>}
}

// WithSD set isSD in RequestOptions.
func WithSD(b bool) RequestOption <span class="cov8" title="1">{
        return RequestOption{F: func(o *RequestOptions) </span><span class="cov8" title="1">{
                o.isSD = b
        }</span>}
}

// WithDialTimeout sets dial timeout.
//
// This is the request level configuration. It has a higher
// priority than the client level configuration
// Note: it won't take effect in the case of the number of
// connections in the connection pool exceeds the maximum
// number of connections and needs to establish a connection
// while waiting.
func WithDialTimeout(t time.Duration) RequestOption <span class="cov8" title="1">{
        return RequestOption{F: func(o *RequestOptions) </span><span class="cov8" title="1">{
                o.dialTimeout = t
        }</span>}
}

// WithReadTimeout sets read timeout.
//
// This is the request level configuration. It has a higher
// priority than the client level configuration
func WithReadTimeout(t time.Duration) RequestOption <span class="cov8" title="1">{
        return RequestOption{F: func(o *RequestOptions) </span><span class="cov8" title="1">{
                o.readTimeout = t
        }</span>}
}

// WithWriteTimeout sets write timeout.
//
// This is the request level configuration. It has a higher
// priority than the client level configuration
func WithWriteTimeout(t time.Duration) RequestOption <span class="cov8" title="1">{
        return RequestOption{F: func(o *RequestOptions) </span><span class="cov8" title="1">{
                o.writeTimeout = t
        }</span>}
}

// WithRequestTimeout sets whole request timeout. If it reaches timeout,
// the client will return.
//
// This is the request level configuration.
func WithRequestTimeout(t time.Duration) RequestOption <span class="cov0" title="0">{
        return RequestOption{F: func(o *RequestOptions) </span><span class="cov0" title="0">{
                o.requestTimeout = t
        }</span>}
}

func (o *RequestOptions) Apply(opts []RequestOption) <span class="cov8" title="1">{
        for _, op := range opts </span><span class="cov8" title="1">{
                op.F(o)
        }</span>
}

func (o *RequestOptions) Tag(k string) string <span class="cov8" title="1">{
        return o.tags[k]
}</span>

func (o *RequestOptions) Tags() map[string]string <span class="cov8" title="1">{
        return o.tags
}</span>

func (o *RequestOptions) IsSD() bool <span class="cov8" title="1">{
        return o.isSD
}</span>

func (o *RequestOptions) DialTimeout() time.Duration <span class="cov8" title="1">{
        return o.dialTimeout
}</span>

func (o *RequestOptions) ReadTimeout() time.Duration <span class="cov8" title="1">{
        return o.readTimeout
}</span>

func (o *RequestOptions) WriteTimeout() time.Duration <span class="cov8" title="1">{
        return o.writeTimeout
}</span>

func (o *RequestOptions) RequestTimeout() time.Duration <span class="cov0" title="0">{
        return o.requestTimeout
}</span>

// StartRequest records the start time of the request.
//
// Note: Users should not call this method.
func (o *RequestOptions) StartRequest() <span class="cov0" title="0">{
        if o.requestTimeout &gt; 0 </span><span class="cov0" title="0">{
                o.start = time.Now()
        }</span>
}

func (o *RequestOptions) StartTime() time.Time <span class="cov0" title="0">{
        return o.start
}</span>

func (o *RequestOptions) CopyTo(dst *RequestOptions) <span class="cov8" title="1">{
        if dst.tags == nil </span><span class="cov8" title="1">{
                dst.tags = make(map[string]string)
        }</span>

        <span class="cov8" title="1">for k, v := range o.tags </span><span class="cov8" title="1">{
                dst.tags[k] = v
        }</span>

        <span class="cov8" title="1">dst.isSD = o.isSD
        dst.readTimeout = o.readTimeout
        dst.writeTimeout = o.writeTimeout
        dst.dialTimeout = o.dialTimeout
        dst.requestTimeout = o.requestTimeout
        dst.start = o.start</span>
}

// SetPreDefinedOpts Pre define some RequestOption here
func SetPreDefinedOpts(opts ...RequestOption) <span class="cov8" title="1">{
        preDefinedOpts = nil
        preDefinedOpts = append(preDefinedOpts, opts...)
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Manuel MartÃ­nez-Almeida
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This file may have been modified by CloudWeGo authors. All CloudWeGo
 * Modifications are Copyright 2022 CloudWeGo Authors
 */

package errors

import (
        "errors"
        "fmt"
        "reflect"
        "strings"
)

var (
        // These errors are the base error, which are used for checking in errors.Is()
        ErrNeedMore           = errors.New("need more data")
        ErrChunkedStream      = errors.New("chunked stream")
        ErrBodyTooLarge       = errors.New("body size exceeds the given limit")
        ErrHijacked           = errors.New("connection has been hijacked")
        ErrTimeout            = errors.New("timeout")
        ErrIdleTimeout        = errors.New("idle timeout")
        ErrNothingRead        = errors.New("nothing read")
        ErrShortConnection    = errors.New("short connection")
        ErrNoFreeConns        = errors.New("no free connections available to host")
        ErrConnectionClosed   = errors.New("connection closed")
        ErrNotSupportProtocol = errors.New("not support protocol")
        ErrNoMultipartForm    = errors.New("request has no multipart/form-data Content-Type")
        ErrBadPoolConn        = errors.New("connection is closed by peer while being in the connection pool")
)

// ErrorType is an unsigned 64-bit error code as defined in the hertz spec.
type ErrorType uint64

type Error struct {
        Err  error
        Type ErrorType
        Meta interface{}
}

const (
        // ErrorTypeBind is used when Context.Bind() fails.
        ErrorTypeBind ErrorType = 1 &lt;&lt; iota
        // ErrorTypeRender is used when Context.Render() fails.
        ErrorTypeRender
        // ErrorTypePrivate indicates a private error.
        ErrorTypePrivate
        // ErrorTypePublic indicates a public error.
        ErrorTypePublic
        // ErrorTypeAny indicates any other error.
        ErrorTypeAny
)

type ErrorChain []*Error

var _ error = (*Error)(nil)

// SetType sets the error's type.
func (msg *Error) SetType(flags ErrorType) *Error <span class="cov8" title="1">{
        msg.Type = flags
        return msg
}</span>

// AbortWithMsg implements the error interface.
func (msg *Error) Error() string <span class="cov8" title="1">{
        return msg.Err.Error()
}</span>

func (a ErrorChain) String() string <span class="cov8" title="1">{
        if len(a) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">var buffer strings.Builder
        for i, msg := range a </span><span class="cov8" title="1">{
                fmt.Fprintf(&amp;buffer, "Error #%02d: %s\n", i+1, msg.Err)
                if msg.Meta != nil </span><span class="cov8" title="1">{
                        fmt.Fprintf(&amp;buffer, "     Meta: %v\n", msg.Meta)
                }</span>
        }
        <span class="cov8" title="1">return buffer.String()</span>
}

func (msg *Error) Unwrap() error <span class="cov0" title="0">{
        return msg.Err
}</span>

// SetMeta sets the error's meta data.
func (msg *Error) SetMeta(data interface{}) *Error <span class="cov8" title="1">{
        msg.Meta = data
        return msg
}</span>

// IsType judges one error.
func (msg *Error) IsType(flags ErrorType) bool <span class="cov8" title="1">{
        return (msg.Type &amp; flags) &gt; 0
}</span>

// JSON creates a properly formatted JSON
func (msg *Error) JSON() interface{} <span class="cov8" title="1">{
        jsonData := make(map[string]interface{})
        if msg.Meta != nil </span><span class="cov8" title="1">{
                value := reflect.ValueOf(msg.Meta)
                switch value.Kind() </span>{
                case reflect.Struct:<span class="cov8" title="1">
                        return msg.Meta</span>
                case reflect.Map:<span class="cov8" title="1">
                        for _, key := range value.MapKeys() </span><span class="cov8" title="1">{
                                jsonData[key.String()] = value.MapIndex(key).Interface()
                        }</span>
                default:<span class="cov8" title="1">
                        jsonData["meta"] = msg.Meta</span>
                }
        }
        <span class="cov8" title="1">if _, ok := jsonData["error"]; !ok </span><span class="cov8" title="1">{
                jsonData["error"] = msg.Error()
        }</span>
        <span class="cov8" title="1">return jsonData</span>
}

// Errors returns an array will all the error messages.
// Example:
//
//        c.Error(errors.New("first"))
//        c.Error(errors.New("second"))
//        c.Error(errors.New("third"))
//        c.Errors.Errors() // == []string{"first", "second", "third"}
func (a ErrorChain) Errors() []string <span class="cov8" title="1">{
        if len(a) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">errorStrings := make([]string, len(a))
        for i, err := range a </span><span class="cov8" title="1">{
                errorStrings[i] = err.Error()
        }</span>
        <span class="cov8" title="1">return errorStrings</span>
}

// ByType returns a readonly copy filtered the byte.
// ie ByType(hertz.ErrorTypePublic) returns a slice of errors with type=ErrorTypePublic.
func (a ErrorChain) ByType(typ ErrorType) ErrorChain <span class="cov8" title="1">{
        if len(a) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">if typ == ErrorTypeAny </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">var result ErrorChain
        for _, msg := range a </span><span class="cov8" title="1">{
                if msg.IsType(typ) </span><span class="cov8" title="1">{
                        result = append(result, msg)
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

// Last returns the last error in the slice. It returns nil if the array is empty.
// Shortcut for errors[len(errors)-1].
func (a ErrorChain) Last() *Error <span class="cov8" title="1">{
        if length := len(a); length &gt; 0 </span><span class="cov8" title="1">{
                return a[length-1]
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (a ErrorChain) JSON() interface{} <span class="cov8" title="1">{
        switch length := len(a); length </span>{
        case 0:<span class="cov8" title="1">
                return nil</span>
        case 1:<span class="cov8" title="1">
                return a.Last().JSON()</span>
        default:<span class="cov8" title="1">
                jsonData := make([]interface{}, length)
                for i, err := range a </span><span class="cov8" title="1">{
                        jsonData[i] = err.JSON()
                }</span>
                <span class="cov8" title="1">return jsonData</span>
        }
}

func New(err error, t ErrorType, meta interface{}) *Error <span class="cov8" title="1">{
        return &amp;Error{
                Err:  err,
                Type: t,
                Meta: meta,
        }
}</span>

// shortcut for creating a public *Error from string
func NewPublic(err string) *Error <span class="cov0" title="0">{
        return New(errors.New(err), ErrorTypePublic, nil)
}</span>

func NewPrivate(err string) *Error <span class="cov0" title="0">{
        return New(errors.New(err), ErrorTypePrivate, nil)
}</span>

func Newf(t ErrorType, meta interface{}, format string, v ...interface{}) *Error <span class="cov8" title="1">{
        return New(fmt.Errorf(format, v...), t, meta)
}</span>

func NewPublicf(format string, v ...interface{}) *Error <span class="cov8" title="1">{
        return New(fmt.Errorf(format, v...), ErrorTypePublic, nil)
}</span>

func NewPrivatef(format string, v ...interface{}) *Error <span class="cov8" title="1">{
        return New(fmt.Errorf(format, v...), ErrorTypePrivate, nil)
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package hlog

import (
        "context"
        "fmt"
        "io"
        "log"
        "os"
)

// Fatal calls the default logger's Fatal method and then os.Exit(1).
func Fatal(v ...interface{}) <span class="cov0" title="0">{
        logger.Fatal(v...)
}</span>

// Error calls the default logger's Error method.
func Error(v ...interface{}) <span class="cov8" title="1">{
        logger.Error(v...)
}</span>

// Warn calls the default logger's Warn method.
func Warn(v ...interface{}) <span class="cov8" title="1">{
        logger.Warn(v...)
}</span>

// Notice calls the default logger's Notice method.
func Notice(v ...interface{}) <span class="cov8" title="1">{
        logger.Notice(v...)
}</span>

// Info calls the default logger's Info method.
func Info(v ...interface{}) <span class="cov8" title="1">{
        logger.Info(v...)
}</span>

// Debug calls the default logger's Debug method.
func Debug(v ...interface{}) <span class="cov8" title="1">{
        logger.Debug(v...)
}</span>

// Trace calls the default logger's Trace method.
func Trace(v ...interface{}) <span class="cov8" title="1">{
        logger.Trace(v...)
}</span>

// Fatalf calls the default logger's Fatalf method and then os.Exit(1).
func Fatalf(format string, v ...interface{}) <span class="cov0" title="0">{
        logger.Fatalf(format, v...)
}</span>

// Errorf calls the default logger's Errorf method.
func Errorf(format string, v ...interface{}) <span class="cov8" title="1">{
        logger.Errorf(format, v...)
}</span>

// Warnf calls the default logger's Warnf method.
func Warnf(format string, v ...interface{}) <span class="cov8" title="1">{
        logger.Warnf(format, v...)
}</span>

// Noticef calls the default logger's Noticef method.
func Noticef(format string, v ...interface{}) <span class="cov8" title="1">{
        logger.Noticef(format, v...)
}</span>

// Infof calls the default logger's Infof method.
func Infof(format string, v ...interface{}) <span class="cov8" title="1">{
        logger.Infof(format, v...)
}</span>

// Debugf calls the default logger's Debugf method.
func Debugf(format string, v ...interface{}) <span class="cov8" title="1">{
        logger.Debugf(format, v...)
}</span>

// Tracef calls the default logger's Tracef method.
func Tracef(format string, v ...interface{}) <span class="cov8" title="1">{
        logger.Tracef(format, v...)
}</span>

// CtxFatalf calls the default logger's CtxFatalf method and then os.Exit(1).
func CtxFatalf(ctx context.Context, format string, v ...interface{}) <span class="cov0" title="0">{
        logger.CtxFatalf(ctx, format, v...)
}</span>

// CtxErrorf calls the default logger's CtxErrorf method.
func CtxErrorf(ctx context.Context, format string, v ...interface{}) <span class="cov8" title="1">{
        logger.CtxErrorf(ctx, format, v...)
}</span>

// CtxWarnf calls the default logger's CtxWarnf method.
func CtxWarnf(ctx context.Context, format string, v ...interface{}) <span class="cov8" title="1">{
        logger.CtxWarnf(ctx, format, v...)
}</span>

// CtxNoticef calls the default logger's CtxNoticef method.
func CtxNoticef(ctx context.Context, format string, v ...interface{}) <span class="cov8" title="1">{
        logger.CtxNoticef(ctx, format, v...)
}</span>

// CtxInfof calls the default logger's CtxInfof method.
func CtxInfof(ctx context.Context, format string, v ...interface{}) <span class="cov8" title="1">{
        logger.CtxInfof(ctx, format, v...)
}</span>

// CtxDebugf calls the default logger's CtxDebugf method.
func CtxDebugf(ctx context.Context, format string, v ...interface{}) <span class="cov8" title="1">{
        logger.CtxDebugf(ctx, format, v...)
}</span>

// CtxTracef calls the default logger's CtxTracef method.
func CtxTracef(ctx context.Context, format string, v ...interface{}) <span class="cov8" title="1">{
        logger.CtxTracef(ctx, format, v...)
}</span>

type defaultLogger struct {
        stdlog *log.Logger
        level  Level
        depth  int
}

func (ll *defaultLogger) SetOutput(w io.Writer) <span class="cov8" title="1">{
        ll.stdlog.SetOutput(w)
}</span>

func (ll *defaultLogger) SetLevel(lv Level) <span class="cov8" title="1">{
        ll.level = lv
}</span>

func (ll *defaultLogger) logf(lv Level, format *string, v ...interface{}) <span class="cov8" title="1">{
        if ll.level &gt; lv </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">msg := lv.toString()
        if format != nil </span><span class="cov8" title="1">{
                if len(v) &gt; 0 </span><span class="cov8" title="1">{
                        msg += fmt.Sprintf(*format, v...)
                }</span> else<span class="cov8" title="1"> {
                        msg += *format
                }</span>
        } else<span class="cov8" title="1"> {
                msg += fmt.Sprint(v...)
        }</span>

        <span class="cov8" title="1">ll.stdlog.Output(ll.depth, msg)
        if lv == LevelFatal </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
}

func (ll *defaultLogger) Fatal(v ...interface{}) <span class="cov0" title="0">{
        ll.logf(LevelFatal, nil, v...)
}</span>

func (ll *defaultLogger) Error(v ...interface{}) <span class="cov8" title="1">{
        ll.logf(LevelError, nil, v...)
}</span>

func (ll *defaultLogger) Warn(v ...interface{}) <span class="cov8" title="1">{
        ll.logf(LevelWarn, nil, v...)
}</span>

func (ll *defaultLogger) Notice(v ...interface{}) <span class="cov8" title="1">{
        ll.logf(LevelNotice, nil, v...)
}</span>

func (ll *defaultLogger) Info(v ...interface{}) <span class="cov8" title="1">{
        ll.logf(LevelInfo, nil, v...)
}</span>

func (ll *defaultLogger) Debug(v ...interface{}) <span class="cov8" title="1">{
        ll.logf(LevelDebug, nil, v...)
}</span>

func (ll *defaultLogger) Trace(v ...interface{}) <span class="cov8" title="1">{
        ll.logf(LevelTrace, nil, v...)
}</span>

func (ll *defaultLogger) Fatalf(format string, v ...interface{}) <span class="cov0" title="0">{
        ll.logf(LevelFatal, &amp;format, v...)
}</span>

func (ll *defaultLogger) Errorf(format string, v ...interface{}) <span class="cov8" title="1">{
        ll.logf(LevelError, &amp;format, v...)
}</span>

func (ll *defaultLogger) Warnf(format string, v ...interface{}) <span class="cov8" title="1">{
        ll.logf(LevelWarn, &amp;format, v...)
}</span>

func (ll *defaultLogger) Noticef(format string, v ...interface{}) <span class="cov8" title="1">{
        ll.logf(LevelNotice, &amp;format, v...)
}</span>

func (ll *defaultLogger) Infof(format string, v ...interface{}) <span class="cov8" title="1">{
        ll.logf(LevelInfo, &amp;format, v...)
}</span>

func (ll *defaultLogger) Debugf(format string, v ...interface{}) <span class="cov8" title="1">{
        ll.logf(LevelDebug, &amp;format, v...)
}</span>

func (ll *defaultLogger) Tracef(format string, v ...interface{}) <span class="cov8" title="1">{
        ll.logf(LevelTrace, &amp;format, v...)
}</span>

func (ll *defaultLogger) CtxFatalf(ctx context.Context, format string, v ...interface{}) <span class="cov0" title="0">{
        ll.logf(LevelFatal, &amp;format, v...)
}</span>

func (ll *defaultLogger) CtxErrorf(ctx context.Context, format string, v ...interface{}) <span class="cov8" title="1">{
        ll.logf(LevelError, &amp;format, v...)
}</span>

func (ll *defaultLogger) CtxWarnf(ctx context.Context, format string, v ...interface{}) <span class="cov8" title="1">{
        ll.logf(LevelWarn, &amp;format, v...)
}</span>

func (ll *defaultLogger) CtxNoticef(ctx context.Context, format string, v ...interface{}) <span class="cov8" title="1">{
        ll.logf(LevelNotice, &amp;format, v...)
}</span>

func (ll *defaultLogger) CtxInfof(ctx context.Context, format string, v ...interface{}) <span class="cov8" title="1">{
        ll.logf(LevelInfo, &amp;format, v...)
}</span>

func (ll *defaultLogger) CtxDebugf(ctx context.Context, format string, v ...interface{}) <span class="cov8" title="1">{
        ll.logf(LevelDebug, &amp;format, v...)
}</span>

func (ll *defaultLogger) CtxTracef(ctx context.Context, format string, v ...interface{}) <span class="cov8" title="1">{
        ll.logf(LevelTrace, &amp;format, v...)
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package hlog

import (
        "io"
        "log"
        "os"
)

var (
        // Provide default logger for users to use
        logger FullLogger = &amp;defaultLogger{
                stdlog: log.New(os.Stderr, "", log.LstdFlags|log.Lshortfile|log.Lmicroseconds),
                depth:  4,
        }

        // Provide system logger for print system log
        sysLogger FullLogger = &amp;systemLogger{
                &amp;defaultLogger{
                        stdlog: log.New(os.Stderr, "", log.LstdFlags|log.Lshortfile|log.Lmicroseconds),
                        depth:  4,
                },
                systemLogPrefix,
        }
)

// SetOutput sets the output of default logger and system logger. By default, it is stderr.
func SetOutput(w io.Writer) <span class="cov8" title="1">{
        logger.SetOutput(w)
        sysLogger.SetOutput(w)
}</span>

// SetLevel sets the level of logs below which logs will not be output.
// The default logger and system logger level is LevelTrace.
// Note that this method is not concurrent-safe.
func SetLevel(lv Level) <span class="cov0" title="0">{
        logger.SetLevel(lv)
        sysLogger.SetLevel(lv)
}</span>

// DefaultLogger return the default logger for hertz.
func DefaultLogger() FullLogger <span class="cov8" title="1">{
        return logger
}</span>

// SystemLogger return the system logger for hertz to print system log.
// This function is not recommended for users to use.
func SystemLogger() FullLogger <span class="cov8" title="1">{
        return sysLogger
}</span>

// SetSystemLogger sets the system logger.
// Note that this method is not concurrent-safe and must not be called
// This function is not recommended for users to use.
func SetSystemLogger(v FullLogger) <span class="cov8" title="1">{
        sysLogger = &amp;systemLogger{v, systemLogPrefix}
}</span>

// SetLogger sets the default logger and the system logger.
// Note that this method is not concurrent-safe and must not be called
// after the use of DefaultLogger and global functions in this package.
func SetLogger(v FullLogger) <span class="cov8" title="1">{
        logger = v
        SetSystemLogger(v)
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package hlog

import (
        "context"
        "fmt"
        "io"
)

// FormatLogger is a logger interface that output logs with a format.
type FormatLogger interface {
        Tracef(format string, v ...interface{})
        Debugf(format string, v ...interface{})
        Infof(format string, v ...interface{})
        Noticef(format string, v ...interface{})
        Warnf(format string, v ...interface{})
        Errorf(format string, v ...interface{})
        Fatalf(format string, v ...interface{})
}

// Logger is a logger interface that provides logging function with levels.
type Logger interface {
        Trace(v ...interface{})
        Debug(v ...interface{})
        Info(v ...interface{})
        Notice(v ...interface{})
        Warn(v ...interface{})
        Error(v ...interface{})
        Fatal(v ...interface{})
}

// CtxLogger is a logger interface that accepts a context argument and output
// logs with a format.
type CtxLogger interface {
        CtxTracef(ctx context.Context, format string, v ...interface{})
        CtxDebugf(ctx context.Context, format string, v ...interface{})
        CtxInfof(ctx context.Context, format string, v ...interface{})
        CtxNoticef(ctx context.Context, format string, v ...interface{})
        CtxWarnf(ctx context.Context, format string, v ...interface{})
        CtxErrorf(ctx context.Context, format string, v ...interface{})
        CtxFatalf(ctx context.Context, format string, v ...interface{})
}

// Control provides methods to config a logger.
type Control interface {
        SetLevel(Level)
        SetOutput(io.Writer)
}

// FullLogger is the combination of Logger, FormatLogger, CtxLogger and Control.
type FullLogger interface {
        Logger
        FormatLogger
        CtxLogger
        Control
}

// Level defines the priority of a log message.
// When a logger is configured with a level, any log message with a lower
// log level (smaller by integer comparison) will not be output.
type Level int

// The levels of logs.
const (
        LevelTrace Level = iota
        LevelDebug
        LevelInfo
        LevelNotice
        LevelWarn
        LevelError
        LevelFatal
)

var strs = []string{
        "[Trace] ",
        "[Debug] ",
        "[Info] ",
        "[Notice] ",
        "[Warn] ",
        "[Error] ",
        "[Fatal] ",
}

func (lv Level) toString() string <span class="cov8" title="1">{
        if lv &gt;= LevelTrace &amp;&amp; lv &lt;= LevelFatal </span><span class="cov8" title="1">{
                return strs[lv]
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("[?%d] ", lv)</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package hlog

import (
        "context"
        "io"
        "strings"
        "sync"
)

var silentMode = false

// SetSilentMode is used to mute engine error log,
// for example: error when reading request headers.
// If true, hertz engine will mute it.
func SetSilentMode(s bool) <span class="cov0" title="0">{
        silentMode = s
}</span>

var builderPool = sync.Pool{New: func() interface{} <span class="cov8" title="1">{
        return &amp;strings.Builder{} // nolint:SA6002
}</span>}

type systemLogger struct {
        logger FullLogger
        prefix string
}

func (ll *systemLogger) SetOutput(w io.Writer) <span class="cov8" title="1">{
        ll.logger.SetOutput(w)
}</span>

func (ll *systemLogger) SetLevel(lv Level) <span class="cov0" title="0">{
        ll.logger.SetLevel(lv)
}</span>

func (ll *systemLogger) Fatal(v ...interface{}) <span class="cov0" title="0">{
        v = append([]interface{}{ll.prefix}, v...)
        ll.logger.Fatal(v...)
}</span>

func (ll *systemLogger) Error(v ...interface{}) <span class="cov8" title="1">{
        v = append([]interface{}{ll.prefix}, v...)
        ll.logger.Error(v...)
}</span>

func (ll *systemLogger) Warn(v ...interface{}) <span class="cov8" title="1">{
        v = append([]interface{}{ll.prefix}, v...)
        ll.logger.Warn(v...)
}</span>

func (ll *systemLogger) Notice(v ...interface{}) <span class="cov8" title="1">{
        v = append([]interface{}{ll.prefix}, v...)
        ll.logger.Notice(v...)
}</span>

func (ll *systemLogger) Info(v ...interface{}) <span class="cov8" title="1">{
        v = append([]interface{}{ll.prefix}, v...)
        ll.logger.Info(v...)
}</span>

func (ll *systemLogger) Debug(v ...interface{}) <span class="cov8" title="1">{
        v = append([]interface{}{ll.prefix}, v...)
        ll.logger.Debug(v...)
}</span>

func (ll *systemLogger) Trace(v ...interface{}) <span class="cov8" title="1">{
        v = append([]interface{}{ll.prefix}, v...)
        ll.logger.Trace(v...)
}</span>

func (ll *systemLogger) Fatalf(format string, v ...interface{}) <span class="cov0" title="0">{
        ll.logger.Fatalf(ll.addPrefix(format), v...)
}</span>

func (ll *systemLogger) Errorf(format string, v ...interface{}) <span class="cov8" title="1">{
        if silentMode &amp;&amp; format == EngineErrorFormat </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">ll.logger.Errorf(ll.addPrefix(format), v...)</span>
}

func (ll *systemLogger) Warnf(format string, v ...interface{}) <span class="cov8" title="1">{
        ll.logger.Warnf(ll.addPrefix(format), v...)
}</span>

func (ll *systemLogger) Noticef(format string, v ...interface{}) <span class="cov8" title="1">{
        ll.logger.Noticef(ll.addPrefix(format), v...)
}</span>

func (ll *systemLogger) Infof(format string, v ...interface{}) <span class="cov8" title="1">{
        ll.logger.Infof(ll.addPrefix(format), v...)
}</span>

func (ll *systemLogger) Debugf(format string, v ...interface{}) <span class="cov8" title="1">{
        ll.logger.Debugf(ll.addPrefix(format), v...)
}</span>

func (ll *systemLogger) Tracef(format string, v ...interface{}) <span class="cov8" title="1">{
        ll.logger.Tracef(ll.addPrefix(format), v...)
}</span>

func (ll *systemLogger) CtxFatalf(ctx context.Context, format string, v ...interface{}) <span class="cov0" title="0">{
        ll.logger.CtxFatalf(ctx, ll.addPrefix(format), v...)
}</span>

func (ll *systemLogger) CtxErrorf(ctx context.Context, format string, v ...interface{}) <span class="cov8" title="1">{
        ll.logger.CtxErrorf(ctx, ll.addPrefix(format), v...)
}</span>

func (ll *systemLogger) CtxWarnf(ctx context.Context, format string, v ...interface{}) <span class="cov8" title="1">{
        ll.logger.CtxWarnf(ctx, ll.addPrefix(format), v...)
}</span>

func (ll *systemLogger) CtxNoticef(ctx context.Context, format string, v ...interface{}) <span class="cov8" title="1">{
        ll.logger.CtxNoticef(ctx, ll.addPrefix(format), v...)
}</span>

func (ll *systemLogger) CtxInfof(ctx context.Context, format string, v ...interface{}) <span class="cov8" title="1">{
        ll.logger.CtxInfof(ctx, ll.addPrefix(format), v...)
}</span>

func (ll *systemLogger) CtxDebugf(ctx context.Context, format string, v ...interface{}) <span class="cov8" title="1">{
        ll.logger.CtxDebugf(ctx, ll.addPrefix(format), v...)
}</span>

func (ll *systemLogger) CtxTracef(ctx context.Context, format string, v ...interface{}) <span class="cov8" title="1">{
        ll.logger.CtxTracef(ctx, ll.addPrefix(format), v...)
}</span>

func (ll *systemLogger) addPrefix(format string) string <span class="cov8" title="1">{
        builder := builderPool.Get().(*strings.Builder)
        builder.Grow(len(format) + len(ll.prefix))
        builder.WriteString(ll.prefix)
        builder.WriteString(format)
        s := builder.String()
        builder.Reset()
        builderPool.Put(builder) // nolint:SA6002
        return s
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015-present Aliaksandr Valialkin, VertaMedia, Kirill Danshin, Erik Dubbelboer, FastHTTP Authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This file may have been modified by CloudWeGo authors. All CloudWeGo
 * Modifications are Copyright 2022 CloudWeGo Authors.
 */

package stackless

import (
        "runtime"
        "sync"
)

// NewFunc returns stackless wrapper for the function f.
//
// Unlike f, the returned stackless wrapper doesn't use stack space
// on the goroutine that calls it.
// The wrapper may save a lot of stack space if the following conditions
// are met:
//
//   - f doesn't contain blocking calls on network, I/O or channels;
//   - f uses a lot of stack space;
//   - the wrapper is called from high number of concurrent goroutines.
//
// The stackless wrapper returns false if the call cannot be processed
// at the moment due to high load.
func NewFunc(f func(ctx interface{})) func(ctx interface{}) bool <span class="cov8" title="1">{
        if f == nil </span><span class="cov0" title="0">{
                panic("BUG: f cannot be nil")</span>
        }

        <span class="cov8" title="1">funcWorkCh := make(chan *funcWork, runtime.GOMAXPROCS(-1)*2048)
        onceInit := func() </span><span class="cov8" title="1">{
                n := runtime.GOMAXPROCS(-1)
                for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                        go funcWorker(funcWorkCh, f)
                }</span>
        }
        <span class="cov8" title="1">var once sync.Once

        return func(ctx interface{}) bool </span><span class="cov8" title="1">{
                once.Do(onceInit)
                fw := getFuncWork()
                fw.ctx = ctx

                select </span>{
                case funcWorkCh &lt;- fw:<span class="cov8" title="1"></span>
                default:<span class="cov0" title="0">
                        putFuncWork(fw)
                        return false</span>
                }
                <span class="cov8" title="1">&lt;-fw.done
                putFuncWork(fw)
                return true</span>
        }
}

func funcWorker(funcWorkCh &lt;-chan *funcWork, f func(ctx interface{})) <span class="cov8" title="1">{
        for fw := range funcWorkCh </span><span class="cov8" title="1">{
                f(fw.ctx)
                fw.done &lt;- struct{}{}
        }</span>
}

func getFuncWork() *funcWork <span class="cov8" title="1">{
        v := funcWorkPool.Get()
        if v == nil </span><span class="cov8" title="1">{
                v = &amp;funcWork{
                        done: make(chan struct{}, 1),
                }
        }</span>
        <span class="cov8" title="1">return v.(*funcWork)</span>
}

func putFuncWork(fw *funcWork) <span class="cov8" title="1">{
        fw.ctx = nil
        funcWorkPool.Put(fw)
}</span>

var funcWorkPool sync.Pool

type funcWork struct {
        ctx  interface{}
        done chan struct{}
}
</pre>
		
		<pre class="file" id="file46" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015-present Aliaksandr Valialkin, VertaMedia, Kirill Danshin, Erik Dubbelboer, FastHTTP Authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This file may have been modified by CloudWeGo authors. All CloudWeGo
 * Modifications are Copyright 2022 CloudWeGo Authors.
 */

package stackless

import (
        "fmt"
        "io"

        "github.com/cloudwego/hertz/pkg/common/bytebufferpool"
        "github.com/cloudwego/hertz/pkg/common/errors"
)

// Writer is an interface stackless writer must conform to.
//
// The interface contains common subset for Writers from compress/* packages.
type Writer interface {
        Write(p []byte) (int, error)
        Flush() error
        Close() error
        Reset(w io.Writer)
}

// NewWriterFunc must return new writer that will be wrapped into
// stackless writer.
type NewWriterFunc func(w io.Writer) Writer

// NewWriter creates a stackless writer around a writer returned
// from newWriter.
//
// The returned writer writes data to dstW.
//
// Writers that use a lot of stack space may be wrapped into stackless writer,
// thus saving stack space for high number of concurrently running goroutines.
func NewWriter(dstW io.Writer, newWriter NewWriterFunc) Writer <span class="cov8" title="1">{
        w := &amp;writer{
                dstW: dstW,
        }
        w.zw = newWriter(&amp;w.xw)
        return w
}</span>

type writer struct {
        dstW io.Writer
        zw   Writer
        xw   xWriter

        err error
        n   int

        p  []byte
        op op
}

type op int

const (
        opWrite op = iota
        opFlush
        opClose
        opReset
)

func (w *writer) Write(p []byte) (int, error) <span class="cov8" title="1">{
        w.p = p
        err := w.do(opWrite)
        w.p = nil
        return w.n, err
}</span>

func (w *writer) Flush() error <span class="cov8" title="1">{
        return w.do(opFlush)
}</span>

func (w *writer) Close() error <span class="cov8" title="1">{
        return w.do(opClose)
}</span>

func (w *writer) Reset(dstW io.Writer) <span class="cov8" title="1">{
        w.xw.Reset()
        w.do(opReset) //nolint:errcheck
        w.dstW = dstW
}</span>

func (w *writer) do(op op) error <span class="cov8" title="1">{
        w.op = op
        if !stacklessWriterFunc(w) </span><span class="cov0" title="0">{
                return errHighLoad
        }</span>
        <span class="cov8" title="1">err := w.err
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if w.xw.bb != nil &amp;&amp; len(w.xw.bb.B) &gt; 0 </span><span class="cov8" title="1">{
                _, err = w.dstW.Write(w.xw.bb.B)
        }</span>
        <span class="cov8" title="1">w.xw.Reset()

        return err</span>
}

var errHighLoad = errors.NewPublic("cannot compress data due to high load")

var stacklessWriterFunc = NewFunc(writerFunc)

func writerFunc(ctx interface{}) <span class="cov8" title="1">{
        w := ctx.(*writer)
        switch w.op </span>{
        case opWrite:<span class="cov8" title="1">
                w.n, w.err = w.zw.Write(w.p)</span>
        case opFlush:<span class="cov8" title="1">
                w.err = w.zw.Flush()</span>
        case opClose:<span class="cov8" title="1">
                w.err = w.zw.Close()</span>
        case opReset:<span class="cov8" title="1">
                w.zw.Reset(&amp;w.xw)
                w.err = nil</span>
        default:<span class="cov0" title="0">
                panic(fmt.Sprintf("BUG: unexpected op: %d", w.op))</span>
        }
}

type xWriter struct {
        bb *bytebufferpool.ByteBuffer
}

func (w *xWriter) Write(p []byte) (int, error) <span class="cov8" title="1">{
        if w.bb == nil </span><span class="cov8" title="1">{
                w.bb = bufferPool.Get()
        }</span>
        <span class="cov8" title="1">return w.bb.Write(p)</span>
}

func (w *xWriter) Reset() <span class="cov8" title="1">{
        if w.bb != nil </span><span class="cov8" title="1">{
                bufferPool.Put(w.bb)
                w.bb = nil
        }</span>
}

var bufferPool bytebufferpool.Pool
</pre>
		
		<pre class="file" id="file47" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package mock

import "fmt"

func CreateFixedBody(bodySize int) []byte <span class="cov8" title="1">{
        var b []byte
        for i := 0; i &lt; bodySize; i++ </span><span class="cov8" title="1">{
                b = append(b, byte(i%10)+'0')
        }</span>
        <span class="cov8" title="1">return b</span>
}

func CreateChunkedBody(body []byte, trailer map[string]string, hasTrailer bool) []byte <span class="cov8" title="1">{
        var b []byte
        chunkSize := 1
        for len(body) &gt; 0 </span><span class="cov8" title="1">{
                if chunkSize &gt; len(body) </span><span class="cov0" title="0">{
                        chunkSize = len(body)
                }</span>
                <span class="cov8" title="1">b = append(b, []byte(fmt.Sprintf("%x\r\n", chunkSize))...)
                b = append(b, body[:chunkSize]...)
                b = append(b, []byte("\r\n")...)
                body = body[chunkSize:]
                chunkSize++</span>
        }
        <span class="cov8" title="1">if hasTrailer </span><span class="cov8" title="1">{
                b = append(b, "0\r\n"...)
                for k, v := range trailer </span><span class="cov8" title="1">{
                        b = append(b, k...)
                        b = append(b, ": "...)
                        b = append(b, v...)
                        b = append(b, "\r\n"...)
                }</span>
                <span class="cov8" title="1">b = append(b, "\r\n"...)</span>
        }
        <span class="cov8" title="1">return b</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package mock

import (
        "bytes"
        "io"
        "net"
        "strings"
        "time"

        errs "github.com/cloudwego/hertz/pkg/common/errors"
        "github.com/cloudwego/hertz/pkg/network"
        "github.com/cloudwego/netpoll"
)

var (
        ErrReadTimeout  = errs.New(errs.ErrTimeout, errs.ErrorTypePublic, "read timeout")
        ErrWriteTimeout = errs.New(errs.ErrTimeout, errs.ErrorTypePublic, "write timeout")
)

type Conn struct {
        readTimeout time.Duration
        zr          network.Reader
        zw          network.ReadWriter
        wroteLen    int
}

type Recorder interface {
        network.Reader
        WroteLen() int
}

func (m *Conn) SetWriteTimeout(t time.Duration) error <span class="cov8" title="1">{
        // TODO implement me
        return nil
}</span>

type SlowReadConn struct {
        *Conn
}

func (m *SlowReadConn) SetWriteTimeout(t time.Duration) error <span class="cov8" title="1">{
        return nil
}</span>

func (m *SlowReadConn) SetReadTimeout(t time.Duration) error <span class="cov8" title="1">{
        m.Conn.readTimeout = t
        return nil
}</span>

func SlowReadDialer(addr string) (network.Conn, error) <span class="cov8" title="1">{
        return NewSlowReadConn(""), nil
}</span>

func SlowWriteDialer(addr string) (network.Conn, error) <span class="cov8" title="1">{
        return NewSlowWriteConn(""), nil
}</span>

func (m *Conn) ReadBinary(n int) (p []byte, err error) <span class="cov8" title="1">{
        return m.zr.(netpoll.Reader).ReadBinary(n)
}</span>

func (m *Conn) Read(b []byte) (n int, err error) <span class="cov8" title="1">{
        return netpoll.NewIOReader(m.zr.(netpoll.Reader)).Read(b)
}</span>

func (m *Conn) Write(b []byte) (n int, err error) <span class="cov8" title="1">{
        return netpoll.NewIOWriter(m.zw.(netpoll.ReadWriter)).Write(b)
}</span>

func (m *Conn) Release() error <span class="cov8" title="1">{
        return nil
}</span>

func (m *Conn) Peek(i int) ([]byte, error) <span class="cov8" title="1">{
        b, err := m.zr.Peek(i)
        if err != nil || len(b) != i </span><span class="cov8" title="1">{
                if m.readTimeout &lt;= 0 </span><span class="cov0" title="0">{
                        // simulate timeout forever
                        select </span>{}
                }
                <span class="cov8" title="1">time.Sleep(m.readTimeout)
                return nil, errs.ErrTimeout</span>
        }
        <span class="cov8" title="1">return b, err</span>
}

func (m *Conn) Skip(n int) error <span class="cov8" title="1">{
        return m.zr.Skip(n)
}</span>

func (m *Conn) ReadByte() (byte, error) <span class="cov8" title="1">{
        return m.zr.ReadByte()
}</span>

func (m *Conn) Len() int <span class="cov8" title="1">{
        return m.zr.Len()
}</span>

func (m *Conn) Malloc(n int) (buf []byte, err error) <span class="cov8" title="1">{
        m.wroteLen += n
        return m.zw.Malloc(n)
}</span>

func (m *Conn) WriteBinary(b []byte) (n int, err error) <span class="cov8" title="1">{
        n, err = m.zw.WriteBinary(b)
        m.wroteLen += n
        return n, err
}</span>

func (m *Conn) Flush() error <span class="cov8" title="1">{
        return m.zw.Flush()
}</span>

func (m *Conn) WriterRecorder() Recorder <span class="cov8" title="1">{
        return &amp;recorder{c: m, Reader: m.zw}
}</span>

func (m *Conn) GetReadTimeout() time.Duration <span class="cov8" title="1">{
        return m.readTimeout
}</span>

type recorder struct {
        c *Conn
        network.Reader
}

func (r *recorder) WroteLen() int <span class="cov8" title="1">{
        return r.c.wroteLen
}</span>

func (m *SlowReadConn) Peek(i int) ([]byte, error) <span class="cov8" title="1">{
        b, err := m.zr.Peek(i)
        if m.readTimeout &gt; 0 </span><span class="cov8" title="1">{
                time.Sleep(m.readTimeout)
        }</span> else<span class="cov0" title="0"> {
                time.Sleep(100 * time.Millisecond)
        }</span>
        <span class="cov8" title="1">if err != nil || len(b) != i </span><span class="cov8" title="1">{
                return nil, ErrReadTimeout
        }</span>
        <span class="cov8" title="1">return b, err</span>
}

func NewConn(source string) *Conn <span class="cov8" title="1">{
        zr := netpoll.NewReader(strings.NewReader(source))
        zw := netpoll.NewReadWriter(&amp;bytes.Buffer{})

        return &amp;Conn{
                zr: zr,
                zw: zw,
        }
}</span>

type BrokenConn struct {
        *Conn
}

func (o *BrokenConn) Peek(i int) ([]byte, error) <span class="cov8" title="1">{
        return nil, io.ErrUnexpectedEOF
}</span>

func (o *BrokenConn) Read(b []byte) (n int, err error) <span class="cov0" title="0">{
        return 0, io.ErrUnexpectedEOF
}</span>

func (o *BrokenConn) Flush() error <span class="cov8" title="1">{
        return errs.ErrConnectionClosed
}</span>

func NewBrokenConn(source string) *BrokenConn <span class="cov8" title="1">{
        return &amp;BrokenConn{Conn: NewConn(source)}
}</span>

type OneTimeConn struct {
        isRead        bool
        isFlushed     bool
        contentLength int
        *Conn
}

func (o *OneTimeConn) Peek(n int) ([]byte, error) <span class="cov8" title="1">{
        if o.isRead </span><span class="cov8" title="1">{
                return nil, io.EOF
        }</span>
        <span class="cov8" title="1">return o.Conn.Peek(n)</span>
}

func (o *OneTimeConn) Skip(n int) error <span class="cov8" title="1">{
        if o.isRead </span><span class="cov8" title="1">{
                return io.EOF
        }</span>
        <span class="cov8" title="1">o.contentLength -= n

        if o.contentLength == 0 </span><span class="cov8" title="1">{
                o.isRead = true
        }</span>

        <span class="cov8" title="1">return o.Conn.Skip(n)</span>
}

func (o *OneTimeConn) Flush() error <span class="cov8" title="1">{
        if o.isFlushed </span><span class="cov8" title="1">{
                return errs.ErrConnectionClosed
        }</span>
        <span class="cov8" title="1">o.isFlushed = true
        return o.Conn.Flush()</span>
}

func NewOneTimeConn(source string) *OneTimeConn <span class="cov8" title="1">{
        return &amp;OneTimeConn{isRead: false, isFlushed: false, Conn: NewConn(source), contentLength: len(source)}
}</span>

func NewSlowReadConn(source string) *SlowReadConn <span class="cov8" title="1">{
        return &amp;SlowReadConn{Conn: NewConn(source)}
}</span>

type ErrorReadConn struct {
        *Conn
        errorToReturn error
}

func NewErrorReadConn(err error) *ErrorReadConn <span class="cov0" title="0">{
        return &amp;ErrorReadConn{
                Conn:          NewConn(""),
                errorToReturn: err,
        }
}</span>

func (er *ErrorReadConn) Peek(n int) ([]byte, error) <span class="cov0" title="0">{
        return nil, er.errorToReturn
}</span>

type SlowWriteConn struct {
        *Conn
        writeTimeout time.Duration
}

func (m *SlowWriteConn) SetWriteTimeout(t time.Duration) error <span class="cov8" title="1">{
        m.writeTimeout = t
        return nil
}</span>

func NewSlowWriteConn(source string) *SlowWriteConn <span class="cov8" title="1">{
        return &amp;SlowWriteConn{NewConn(source), 0}
}</span>

func (m *SlowWriteConn) Flush() error <span class="cov8" title="1">{
        err := m.zw.Flush()
        time.Sleep(100 * time.Millisecond)
        if err == nil </span><span class="cov8" title="1">{
                time.Sleep(m.writeTimeout)
                return ErrWriteTimeout
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (m *Conn) Close() error <span class="cov8" title="1">{
        return nil
}</span>

func (m *Conn) LocalAddr() net.Addr <span class="cov8" title="1">{
        return nil
}</span>

func (m *Conn) RemoteAddr() net.Addr <span class="cov8" title="1">{
        return nil
}</span>

func (m *Conn) SetDeadline(t time.Time) error <span class="cov8" title="1">{
        panic("implement me")</span>
}

func (m *Conn) SetReadDeadline(t time.Time) error <span class="cov8" title="1">{
        m.readTimeout = -time.Since(t)
        return nil
}</span>

func (m *Conn) SetWriteDeadline(t time.Time) error <span class="cov8" title="1">{
        panic("implement me")</span>
}

func (m *Conn) Reader() network.Reader <span class="cov8" title="1">{
        return m.zr
}</span>

func (m *Conn) Writer() network.Writer <span class="cov8" title="1">{
        return m.zw
}</span>

func (m *Conn) IsActive() bool <span class="cov8" title="1">{
        panic("implement me")</span>
}

func (m *Conn) SetIdleTimeout(timeout time.Duration) error <span class="cov8" title="1">{
        return nil
}</span>

func (m *Conn) SetReadTimeout(t time.Duration) error <span class="cov8" title="1">{
        m.readTimeout = t
        return nil
}</span>

func (m *Conn) SetOnRequest(on netpoll.OnRequest) error <span class="cov8" title="1">{
        panic("implement me")</span>
}

func (m *Conn) AddCloseCallback(callback netpoll.CloseCallback) error <span class="cov8" title="1">{
        panic("implement me")</span>
}

type StreamConn struct {
        Data []byte
}

func NewStreamConn() *StreamConn <span class="cov8" title="1">{
        return &amp;StreamConn{
                Data: make([]byte, 1&lt;&lt;15, 1&lt;&lt;16),
        }
}</span>

func (m *StreamConn) Peek(n int) ([]byte, error) <span class="cov8" title="1">{
        if len(m.Data) &gt;= n </span><span class="cov8" title="1">{
                return m.Data[:n], nil
        }</span>
        <span class="cov8" title="1">if n == 1 </span><span class="cov8" title="1">{
                m.Data = m.Data[:cap(m.Data)]
                return m.Data[:1], nil
        }</span>
        <span class="cov8" title="1">return nil, errs.NewPublic("not enough data")</span>
}

func (m *StreamConn) Skip(n int) error <span class="cov8" title="1">{
        if len(m.Data) &gt;= n </span><span class="cov8" title="1">{
                m.Data = m.Data[n:]
                return nil
        }</span>
        <span class="cov8" title="1">return errs.NewPublic("not enough data")</span>
}

func (m *StreamConn) Release() error <span class="cov8" title="1">{
        panic("implement me")</span>
}

func (m *StreamConn) Len() int <span class="cov8" title="1">{
        return len(m.Data)
}</span>

func (m *StreamConn) ReadByte() (byte, error) <span class="cov8" title="1">{
        panic("implement me")</span>
}

func (m *StreamConn) ReadBinary(n int) (p []byte, err error) <span class="cov8" title="1">{
        panic("implement me")</span>
}

func DialerFun(addr string) (network.Conn, error) <span class="cov8" title="1">{
        return NewConn(""), nil
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package mock

import (
        "bufio"
        "bytes"
        "io"
)

// ZeroCopyReader is used to create ZeroCopyReader for testing.
//
// NOTE: In principle, ut should use the zcReader created by netpoll.NewReader() for mock testing,
// but because zcReader does not implement the io.Reader interface, the test requirements of
// io.Reader involved are replaced with MockZeroCopyReader
type ZeroCopyReader struct {
        *bufio.Reader
}

func (m ZeroCopyReader) Peek(n int) ([]byte, error) <span class="cov8" title="1">{
        b, err := m.Reader.Peek(n)
        // if n is bigger than the buffer in m.Reader,
        // it will only return bufio.ErrBufferFull even if the underline reader return io.EOF.
        // so we make another Peek to get the real error.
        // for more info: https://github.com/golang/go/issues/50569
        if err == bufio.ErrBufferFull &amp;&amp; len(b) == 0 </span><span class="cov8" title="1">{
                return m.Reader.Peek(1)
        }</span>
        <span class="cov8" title="1">return b, err</span>
}

func (m ZeroCopyReader) Skip(n int) (err error) <span class="cov8" title="1">{
        _, err = m.Reader.Discard(n)
        return
}</span>

func (m ZeroCopyReader) Release() (err error) <span class="cov8" title="1">{
        return nil
}</span>

func (m ZeroCopyReader) Len() (length int) <span class="cov8" title="1">{
        return m.Reader.Buffered()
}</span>

func (m ZeroCopyReader) ReadBinary(n int) (p []byte, err error) <span class="cov8" title="1">{
        panic("implement me")</span>
}

func NewZeroCopyReader(r string) ZeroCopyReader <span class="cov8" title="1">{
        br := bufio.NewReaderSize(bytes.NewBufferString(r), len(r))
        return ZeroCopyReader{br}
}</span>

func NewLimitReader(r *bytes.Buffer) io.LimitedReader <span class="cov0" title="0">{
        return io.LimitedReader{
                R: r,
                N: int64(r.Len()),
        }
}</span>

type EOFReader struct{}

func (e *EOFReader) Peek(n int) ([]byte, error) <span class="cov8" title="1">{
        return []byte{}, io.EOF
}</span>

func (e *EOFReader) Skip(n int) error <span class="cov8" title="1">{
        return nil
}</span>

func (e *EOFReader) Release() error <span class="cov8" title="1">{
        return nil
}</span>

func (e *EOFReader) Len() int <span class="cov8" title="1">{
        return 0
}</span>

func (e *EOFReader) ReadByte() (byte, error) <span class="cov8" title="1">{
        return ' ', io.EOF
}</span>

func (e *EOFReader) ReadBinary(n int) (p []byte, err error) <span class="cov8" title="1">{
        return p, io.EOF
}</span>

func (e *EOFReader) Read(p []byte) (n int, err error) <span class="cov8" title="1">{
        return 0, io.EOF
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">/*
 * Copyright 2023 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package mock

import "bytes"

type ExtWriter struct {
        tmp     []byte
        Buf     *bytes.Buffer
        IsFinal *bool
}

func (m *ExtWriter) Write(p []byte) (n int, err error) <span class="cov8" title="1">{
        m.tmp = p
        return len(p), nil
}</span>

func (m *ExtWriter) Flush() error <span class="cov8" title="1">{
        _, err := m.Buf.Write(m.tmp)
        return err
}</span>

func (m *ExtWriter) Finalize() error <span class="cov8" title="1">{
        if !*m.IsFinal </span><span class="cov8" title="1">{
                *m.IsFinal = true
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *ExtWriter) SetBody(body []byte) <span class="cov8" title="1">{
        m.Buf.Reset()
        m.tmp = body
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015-present Aliaksandr Valialkin, VertaMedia, Kirill Danshin, Erik Dubbelboer, FastHTTP Authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This file may have been modified by CloudWeGo authors. All CloudWeGo
 * Modifications are Copyright 2022 CloudWeGo Authors.
 */

package timer

import (
        "sync"
        "time"
)

func initTimer(t *time.Timer, timeout time.Duration) *time.Timer <span class="cov8" title="1">{
        if t == nil </span><span class="cov8" title="1">{
                return time.NewTimer(timeout)
        }</span>
        <span class="cov8" title="1">if t.Reset(timeout) </span><span class="cov8" title="1">{
                panic("BUG: active timer trapped into initTimer()")</span>
        }
        <span class="cov8" title="1">return t</span>
}

func stopTimer(t *time.Timer) <span class="cov8" title="1">{
        if !t.Stop() </span><span class="cov0" title="0">{
                // Collect possibly added time from the channel
                // if timer has been stopped and nobody collected its value.
                select </span>{
                case &lt;-t.C:<span class="cov0" title="0"></span>
                default:<span class="cov0" title="0"></span>
                }
        }
}

// AcquireTimer returns a time.Timer from the pool and updates it to
// send the current time on its channel after at least timeout.
//
// The returned Timer may be returned to the pool with ReleaseTimer
// when no longer needed. This allows reducing GC load.
func AcquireTimer(timeout time.Duration) *time.Timer <span class="cov8" title="1">{
        v := timerPool.Get()
        if v == nil </span><span class="cov8" title="1">{
                return time.NewTimer(timeout)
        }</span>
        <span class="cov8" title="1">t := v.(*time.Timer)
        initTimer(t, timeout)
        return t</span>
}

// ReleaseTimer returns the time.Timer acquired via AcquireTimer to the pool
// and prevents the Timer from firing.
//
// Do not access the released time.Timer or read from its channel otherwise
// data races may occur.
func ReleaseTimer(t *time.Timer) <span class="cov8" title="1">{
        stopTimer(t)
        timerPool.Put(t)
}</span>

var timerPool sync.Pool
</pre>
		
		<pre class="file" id="file52" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package stats

import (
        "sync"
        "sync/atomic"

        "github.com/cloudwego/hertz/pkg/common/errors"
)

// EventIndex indicates a unique event.
type EventIndex int

// Level sets the record level.
type Level int

// Event levels.
const (
        LevelDisabled Level = iota
        LevelBase
        LevelDetailed
)

// Event is used to indicate a specific event.
type Event interface {
        Index() EventIndex
        Level() Level
}

type event struct {
        idx   EventIndex
        level Level
}

// Index implements the Event interface.
func (e event) Index() EventIndex <span class="cov0" title="0">{
        return e.idx
}</span>

// Level implements the Event interface.
func (e event) Level() Level <span class="cov8" title="1">{
        return e.level
}</span>

const (
        _ EventIndex = iota
        serverHandleStart
        serverHandleFinish
        httpStart
        httpFinish
        readHeaderStart
        readHeaderFinish
        readBodyStart
        readBodyFinish
        writeStart
        writeFinish
        predefinedEventNum
)

// Predefined events.
var (
        HTTPStart  = newEvent(httpStart, LevelBase)
        HTTPFinish = newEvent(httpFinish, LevelBase)

        ServerHandleStart  = newEvent(serverHandleStart, LevelDetailed)
        ServerHandleFinish = newEvent(serverHandleFinish, LevelDetailed)
        ReadHeaderStart    = newEvent(readHeaderStart, LevelDetailed)
        ReadHeaderFinish   = newEvent(readHeaderFinish, LevelDetailed)
        ReadBodyStart      = newEvent(readBodyStart, LevelDetailed)
        ReadBodyFinish     = newEvent(readBodyFinish, LevelDetailed)
        WriteStart         = newEvent(writeStart, LevelDetailed)
        WriteFinish        = newEvent(writeFinish, LevelDetailed)
)

// errors
var (
        ErrNotAllowed = errors.NewPublic("event definition is not allowed after initialization")
        ErrDuplicated = errors.NewPublic("event name is already defined")
)

var (
        lock        sync.RWMutex
        inited      int32
        userDefined = make(map[string]Event)
        maxEventNum = int(predefinedEventNum)
)

// FinishInitialization freezes all events defined and prevents further definitions to be added.
func FinishInitialization() <span class="cov8" title="1">{
        atomic.StoreInt32(&amp;inited, 1)
}</span>

// DefineNewEvent allows user to add event definitions during program initialization.
func DefineNewEvent(name string, level Level) (Event, error) <span class="cov8" title="1">{
        if atomic.LoadInt32(&amp;inited) == 1 </span><span class="cov8" title="1">{
                return nil, ErrNotAllowed
        }</span>
        <span class="cov8" title="1">lock.Lock()
        defer lock.Unlock()
        evt, exist := userDefined[name]
        if exist </span><span class="cov8" title="1">{
                return evt, ErrDuplicated
        }</span>
        <span class="cov8" title="1">userDefined[name] = newEvent(EventIndex(maxEventNum), level)
        maxEventNum++
        return userDefined[name], nil</span>
}

// MaxEventNum returns the number of event defined.
func MaxEventNum() int <span class="cov8" title="1">{
        lock.RLock()
        defer lock.RUnlock()
        return maxEventNum
}</span>

func newEvent(idx EventIndex, level Level) Event <span class="cov8" title="1">{
        return event{
                idx:   idx,
                level: level,
        }
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">/*
 * Copyright 2023 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ut

import (
        "io"
        "io/ioutil"

        "github.com/cloudwego/hertz/pkg/app"
        "github.com/cloudwego/hertz/pkg/common/config"
        "github.com/cloudwego/hertz/pkg/protocol"
        "github.com/cloudwego/hertz/pkg/route"
)

// CreateUtRequestContext returns an app.RequestContext for testing purposes
func CreateUtRequestContext(method, url string, body *Body, headers ...Header) *app.RequestContext <span class="cov8" title="1">{
        engine := route.NewEngine(config.NewOptions([]config.Option{}))
        return createUtRequestContext(engine, method, url, body, headers...)
}</span>

func createUtRequestContext(engine *route.Engine, method, url string, body *Body, headers ...Header) *app.RequestContext <span class="cov8" title="1">{
        ctx := engine.NewContext()

        var r *protocol.Request
        if body != nil &amp;&amp; body.Body != nil </span><span class="cov8" title="1">{
                r = protocol.NewRequest(method, url, body.Body)
                r.CopyTo(&amp;ctx.Request)
                if engine.IsStreamRequestBody() || body.Len == -1 </span><span class="cov8" title="1">{
                        ctx.Request.SetBodyStream(body.Body, body.Len)
                }</span> else<span class="cov8" title="1"> {
                        buf, err := ioutil.ReadAll(&amp;io.LimitedReader{R: body.Body, N: int64(body.Len)})
                        ctx.Request.SetBody(buf)
                        if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                                panic(err)</span>
                        }
                }
        } else<span class="cov8" title="1"> {
                r = protocol.NewRequest(method, url, nil)
                r.CopyTo(&amp;ctx.Request)
        }</span>

        <span class="cov8" title="1">for _, v := range headers </span><span class="cov8" title="1">{
                if ctx.Request.Header.Get(v.Key) != "" </span><span class="cov8" title="1">{
                        ctx.Request.Header.Add(v.Key, v.Value)
                }</span> else<span class="cov8" title="1"> {
                        ctx.Request.Header.Set(v.Key, v.Value)
                }</span>
        }

        <span class="cov8" title="1">return ctx</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Package ut provides a convenient way to write unit test for the business logic.
package ut

import (
        "context"
        "io"

        "github.com/cloudwego/hertz/pkg/route"
)

// Header is a key-value pair indicating one http header
type Header struct {
        Key   string
        Value string
}

// Body is for setting Request.Body
type Body struct {
        Body io.Reader
        Len  int
}

// PerformRequest send a constructed request to given engine without network transporting
//
// # Url can be a standard relative URI or a simple absolute path
//
// If engine.streamRequestBody is true, it sets body as bodyStream
// if not, it sets body as bodyBytes
//
// ResponseRecorder returned are flushed, which means its StatusCode is always set (default 200)
//
// See ./request_test.go for more examples
func PerformRequest(engine *route.Engine, method, url string, body *Body, headers ...Header) *ResponseRecorder <span class="cov8" title="1">{
        ctx := createUtRequestContext(engine, method, url, body, headers...)
        engine.ServeHTTP(context.Background(), ctx)

        w := NewRecorder()
        h := w.Header()
        ctx.Response.Header.CopyTo(h)

        w.WriteHeader(ctx.Response.StatusCode())
        w.Write(ctx.Response.Body())
        w.Flush()
        return w
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ut

import (
        "bytes"

        "github.com/cloudwego/hertz/pkg/protocol"
        "github.com/cloudwego/hertz/pkg/protocol/consts"
)

// ResponseRecorder records handler's response for later test
type ResponseRecorder struct {
        // Code is the HTTP response code set by WriteHeader.
        //
        // Note that if a Handler never calls WriteHeader or Write,
        // this might end up being 0, rather than the implicit
        // http.StatusOK. To get the implicit value, use the Result
        // method.
        Code int

        // header contains the headers explicitly set by the Handler.
        // It is an internal detail.
        header *protocol.ResponseHeader

        // Body is the buffer to which the Handler's Write calls are sent.
        // If nil, the Writes are silently discarded.
        Body *bytes.Buffer

        // Flushed is whether the Handler called Flush.
        Flushed bool

        result      *protocol.Response // cache of Result's return value
        wroteHeader bool
}

// NewRecorder returns an initialized ResponseRecorder.
func NewRecorder() *ResponseRecorder <span class="cov8" title="1">{
        return &amp;ResponseRecorder{
                header: new(protocol.ResponseHeader),
                Body:   new(bytes.Buffer),
                Code:   consts.StatusOK,
        }
}</span>

// Header returns the response headers to mutate within a handler.
// To test the headers that were written after a handler completes,
// use the Result method and see the returned Response value's Header.
func (rw *ResponseRecorder) Header() *protocol.ResponseHeader <span class="cov8" title="1">{
        m := rw.header
        if m == nil </span><span class="cov8" title="1">{
                m = new(protocol.ResponseHeader)
                rw.header = m
        }</span>
        <span class="cov8" title="1">return m</span>
}

// Write implements io.Writer. The data in buf is written to
// rw.Body, if not nil.
func (rw *ResponseRecorder) Write(buf []byte) (int, error) <span class="cov8" title="1">{
        if !rw.wroteHeader </span><span class="cov8" title="1">{
                rw.WriteHeader(consts.StatusOK)
        }</span>
        <span class="cov8" title="1">if rw.Body != nil </span><span class="cov8" title="1">{
                rw.Body.Write(buf)
        }</span>
        <span class="cov8" title="1">return len(buf), nil</span>
}

// WriteString implements io.StringWriter. The data in str is written
// to rw.Body, if not nil.
func (rw *ResponseRecorder) WriteString(str string) (int, error) <span class="cov8" title="1">{
        if !rw.wroteHeader </span><span class="cov8" title="1">{
                rw.WriteHeader(consts.StatusOK)
        }</span>
        <span class="cov8" title="1">if rw.Body != nil </span><span class="cov8" title="1">{
                rw.Body.WriteString(str)
        }</span>
        <span class="cov8" title="1">return len(str), nil</span>
}

// WriteHeader sends an HTTP response header with the provided
// status code.
func (rw *ResponseRecorder) WriteHeader(code int) <span class="cov8" title="1">{
        if rw.wroteHeader </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if rw.header == nil </span><span class="cov8" title="1">{
                rw.header = new(protocol.ResponseHeader)
        }</span>
        <span class="cov8" title="1">rw.header.SetStatusCode(code)
        rw.Code = code
        rw.wroteHeader = true</span>
}

// Flush implements http.Flusher. To test whether Flush was
// called, see rw.Flushed.
func (rw *ResponseRecorder) Flush() <span class="cov8" title="1">{
        if !rw.wroteHeader </span><span class="cov8" title="1">{
                rw.WriteHeader(consts.StatusOK)
        }</span>
        <span class="cov8" title="1">rw.Flushed = true</span>
}

// Result returns the response generated by the handler.
//
// The returned Response will have at least its StatusCode,
// Header, Body, and optionally Trailer populated.
// More fields may be populated in the future, so callers should
// not DeepEqual the result in tests.
//
// The Response.Header is a snapshot of the headers at the time of the
// first write call, or at the time of this call, if the handler never
// did a write.
//
// The Response.Body is guaranteed to be non-nil and Body.Read call is
// guaranteed to not return any error other than io.EOF.
//
// Result must only be called after the handler has finished running.
func (rw *ResponseRecorder) Result() *protocol.Response <span class="cov8" title="1">{
        if rw.result != nil </span><span class="cov8" title="1">{
                return rw.result
        }</span>

        <span class="cov8" title="1">res := new(protocol.Response)
        h := rw.Header()
        h.CopyTo(&amp;res.Header)
        if rw.Body != nil </span><span class="cov8" title="1">{
                b := rw.Body.Bytes()
                res.SetBody(b)
                res.Header.SetContentLength(len(b))
        }</span>

        <span class="cov8" title="1">rw.result = res
        return res</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package utils

import "sync"

var CopyBufPool = sync.Pool{
        New: func() interface{} <span class="cov8" title="1">{
                return make([]byte, 4096)
        }</span>,
}
</pre>
		
		<pre class="file" id="file57" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package utils

import (
        "bytes"
        "fmt"
        "io"

        "github.com/cloudwego/hertz/internal/bytesconv"
        "github.com/cloudwego/hertz/internal/bytestr"
        "github.com/cloudwego/hertz/pkg/common/errors"
        "github.com/cloudwego/hertz/pkg/network"
)

var errBrokenChunk = errors.NewPublic("cannot find crlf at the end of chunk")

func ParseChunkSize(r network.Reader) (int, error) <span class="cov8" title="1">{
        n, err := bytesconv.ReadHexInt(r)
        if err != nil </span><span class="cov8" title="1">{
                if err == io.EOF </span><span class="cov8" title="1">{
                        err = io.ErrUnexpectedEOF
                }</span>
                <span class="cov8" title="1">return -1, err</span>
        }
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                c, err := r.ReadByte()
                if err != nil </span><span class="cov8" title="1">{
                        return -1, errors.NewPublic(fmt.Sprintf("cannot read '\r' char at the end of chunk size: %s", err))
                }</span>
                // Skip any trailing whitespace after chunk size.
                <span class="cov8" title="1">if c == ' ' </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if c != '\r' </span><span class="cov8" title="1">{
                        return -1, errors.NewPublic(
                                fmt.Sprintf("unexpected char %q at the end of chunk size. Expected %q", c, '\r'),
                        )
                }</span>
                <span class="cov8" title="1">break</span>
        }
        <span class="cov8" title="1">c, err := r.ReadByte()
        if err != nil </span><span class="cov8" title="1">{
                return -1, errors.NewPublic(fmt.Sprintf("cannot read '\n' char at the end of chunk size: %s", err))
        }</span>
        <span class="cov8" title="1">if c != '\n' </span><span class="cov8" title="1">{
                return -1, errors.NewPublic(
                        fmt.Sprintf("unexpected char %q at the end of chunk size. Expected %q", c, '\n'),
                )
        }</span>
        <span class="cov8" title="1">return n, nil</span>
}

// SkipCRLF will only skip the next CRLF("\r\n"), otherwise, error will be returned.
func SkipCRLF(reader network.Reader) error <span class="cov8" title="1">{
        p, err := reader.Peek(len(bytestr.StrCRLF))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if !bytes.Equal(p, bytestr.StrCRLF) </span><span class="cov8" title="1">{
                return errBrokenChunk
        }</span>

        <span class="cov8" title="1">reader.Skip(len(p)) // nolint: errcheck
        return nil</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">/*
 * Copyright 2024 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package utils

import (
        "os"
        "strconv"
        "strings"

        "github.com/cloudwego/hertz/pkg/common/errors"
)

// Get bool from env
func GetBoolFromEnv(key string) (bool, error) <span class="cov0" title="0">{
        value, isExist := os.LookupEnv(key)
        if !isExist </span><span class="cov0" title="0">{
                return false, errors.NewPublic("env not exist")
        }</span>

        <span class="cov0" title="0">value = strings.TrimSpace(value)
        return strconv.ParseBool(value)</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package utils

import (
        "io"

        "github.com/cloudwego/hertz/pkg/network"
)

func CopyBuffer(dst network.Writer, src io.Reader, buf []byte) (written int64, err error) <span class="cov8" title="1">{
        if buf != nil &amp;&amp; len(buf) == 0 </span><span class="cov8" title="1">{
                panic("empty buffer in io.CopyBuffer")</span>
        }
        <span class="cov8" title="1">return copyBuffer(dst, src, buf)</span>
}

// copyBuffer is the actual implementation of Copy and CopyBuffer.
// If buf is nil, one is allocated.
func copyBuffer(dst network.Writer, src io.Reader, buf []byte) (written int64, err error) <span class="cov8" title="1">{
        if wt, ok := src.(io.WriterTo); ok </span><span class="cov8" title="1">{
                if w, ok := dst.(io.Writer); ok </span><span class="cov8" title="1">{
                        return wt.WriteTo(w)
                }</span>
        }

        // Sendfile impl
        <span class="cov8" title="1">if rf, ok := dst.(io.ReaderFrom); ok </span><span class="cov8" title="1">{
                return rf.ReadFrom(src)
        }</span>

        <span class="cov8" title="1">if buf == nil </span><span class="cov8" title="1">{
                size := 32 * 1024
                if l, ok := src.(*io.LimitedReader); ok &amp;&amp; int64(size) &gt; l.N </span><span class="cov8" title="1">{
                        if l.N &lt; 1 </span><span class="cov8" title="1">{
                                size = 1
                        }</span> else<span class="cov8" title="1"> {
                                size = int(l.N)
                        }</span>
                }
                <span class="cov8" title="1">buf = make([]byte, size)</span>
        }
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                nr, er := src.Read(buf)
                if nr &gt; 0 </span><span class="cov8" title="1">{
                        nw, eb := dst.WriteBinary(buf[:nr])
                        if eb != nil </span><span class="cov0" title="0">{
                                err = eb
                                return
                        }</span>

                        <span class="cov8" title="1">if nw &gt; 0 </span><span class="cov8" title="1">{
                                written += int64(nw)
                        }</span>
                        <span class="cov8" title="1">if nr != nw </span><span class="cov0" title="0">{
                                err = io.ErrShortWrite
                                return
                        }</span>
                        <span class="cov8" title="1">if err = dst.Flush(); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
                <span class="cov8" title="1">if er != nil </span><span class="cov8" title="1">{
                        if er != io.EOF </span><span class="cov0" title="0">{
                                err = er
                        }</span>
                        <span class="cov8" title="1">break</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

func CopyZeroAlloc(w network.Writer, r io.Reader) (int64, error) <span class="cov8" title="1">{
        vbuf := CopyBufPool.Get()
        buf := vbuf.([]byte)
        n, err := CopyBuffer(w, r, buf)
        CopyBufPool.Put(vbuf)
        return n, err
}</span>
</pre>
		
		<pre class="file" id="file60" style="display: none">/*
 * Copyright 2021 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package utils

import "net"

var _ net.Addr = (*NetAddr)(nil)

// NetAddr implements the net.Addr interface.
type NetAddr struct {
        network string
        address string
}

// NewNetAddr creates a new NetAddr object with the network and address provided.
func NewNetAddr(network, address string) net.Addr <span class="cov8" title="1">{
        return &amp;NetAddr{network, address}
}</span>

// Network implements the net.Addr interface.
func (na *NetAddr) Network() string <span class="cov8" title="1">{
        return na.network
}</span>

// String implements the net.Addr interface.
func (na *NetAddr) String() string <span class="cov8" title="1">{
        return na.address
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package utils

import "net"

const (
        UNKNOWN_IP_ADDR = "-"
)

var localIP string

// LocalIP returns host's ip
func LocalIP() string <span class="cov8" title="1">{
        return localIP
}</span>

// getLocalIp enumerates local net interfaces to find local ip, it should only be called in init phase
func getLocalIp() string <span class="cov8" title="1">{
        inters, err := net.Interfaces()
        if err != nil </span><span class="cov0" title="0">{
                return UNKNOWN_IP_ADDR
        }</span>
        <span class="cov8" title="1">for _, inter := range inters </span><span class="cov8" title="1">{
                if inter.Flags&amp;net.FlagLoopback != net.FlagLoopback &amp;&amp;
                        inter.Flags&amp;net.FlagUp != 0 </span><span class="cov8" title="1">{
                        addrs, err := inter.Addrs()
                        if err != nil </span><span class="cov0" title="0">{
                                return UNKNOWN_IP_ADDR
                        }</span>
                        <span class="cov8" title="1">for _, addr := range addrs </span><span class="cov8" title="1">{
                                if ipnet, ok := addr.(*net.IPNet); ok &amp;&amp; !ipnet.IP.IsLoopback() </span><span class="cov8" title="1">{
                                        return ipnet.IP.String()
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return UNKNOWN_IP_ADDR</span>
}

func init() <span class="cov8" title="1">{
        localIP = getLocalIp()
}</span>

// TLSRecordHeaderLooksLikeHTTP reports whether a TLS record header
// looks like it might've been a misdirected plaintext HTTP request.
func TLSRecordHeaderLooksLikeHTTP(hdr [5]byte) bool <span class="cov8" title="1">{
        switch string(hdr[:]) </span>{
        case "GET /", "HEAD ", "POST ", "PUT /", "OPTIO":<span class="cov8" title="1">
                return true</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Manuel MartÃ­nez-Almeida
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This file may have been modified by CloudWeGo authors. All CloudWeGo
 * Modifications are Copyright 2022 CloudWeGo Authors
 */

package utils

import "strings"

// CleanPath is the URL version of path.Clean, it returns a canonical URL path
// for p, eliminating . and .. elements.
//
// The following rules are applied iteratively until no further processing can
// be done:
//  1. Replace multiple slashes with a single slash.
//  2. Eliminate each . path name element (the current directory).
//  3. Eliminate each inner .. path name element (the parent directory)
//     along with the non-.. element that precedes it.
//  4. Eliminate .. elements that begin a rooted path:
//     that is, replace "/.." by "/" at the beginning of a path.
//
// If the result of this process is an empty string, "/" is returned
func CleanPath(p string) string <span class="cov8" title="1">{
        const stackBufSize = 128

        // Turn empty string into "/"
        if p == "" </span><span class="cov8" title="1">{
                return "/"
        }</span>

        // Reasonably sized buffer on stack to avoid allocations in the common case.
        // If a larger buffer is required, it gets allocated dynamically.
        <span class="cov8" title="1">buf := make([]byte, 0, stackBufSize)

        n := len(p)

        // Invariants:
        //      reading from path; r is index of next byte to process.
        //      writing to buf; w is index of next byte to write.

        // path must start with '/'
        r := 1
        w := 1

        if p[0] != '/' </span><span class="cov8" title="1">{
                r = 0

                if n+1 &gt; stackBufSize </span><span class="cov0" title="0">{
                        buf = make([]byte, n+1)
                }</span> else<span class="cov8" title="1"> {
                        buf = buf[:n+1]
                }</span>
                <span class="cov8" title="1">buf[0] = '/'</span>
        }

        <span class="cov8" title="1">trailing := n &gt; 1 &amp;&amp; p[n-1] == '/'

        // A bit more clunky without a 'lazybuf' like the path package, but the loop
        // gets completely inlined (bufApp calls).
        // So in contrast to the path package this loop has no expensive function
        // calls (except make, if needed).

        for r &lt; n </span><span class="cov8" title="1">{
                switch </span>{
                case p[r] == '/':<span class="cov8" title="1">
                        // empty path element, trailing slash is added after the end
                        r++</span>

                case p[r] == '.' &amp;&amp; r+1 == n:<span class="cov8" title="1">
                        trailing = true
                        r++</span>

                case p[r] == '.' &amp;&amp; p[r+1] == '/':<span class="cov8" title="1">
                        // . element
                        r += 2</span>

                case p[r] == '.' &amp;&amp; p[r+1] == '.' &amp;&amp; (r+2 == n || p[r+2] == '/'):<span class="cov8" title="1">
                        // .. element: remove to last /
                        r += 3

                        if w &gt; 1 </span><span class="cov8" title="1">{
                                // can backtrack
                                w--

                                if len(buf) == 0 </span><span class="cov8" title="1">{
                                        for w &gt; 1 &amp;&amp; p[w] != '/' </span><span class="cov8" title="1">{
                                                w--
                                        }</span>
                                } else<span class="cov8" title="1"> {
                                        for w &gt; 1 &amp;&amp; buf[w] != '/' </span><span class="cov8" title="1">{
                                                w--
                                        }</span>
                                }
                        }

                default:<span class="cov8" title="1">
                        // Real path element.
                        // Add slash if needed
                        if w &gt; 1 </span><span class="cov8" title="1">{
                                bufApp(&amp;buf, p, w, '/')
                                w++
                        }</span>

                        // Copy element
                        <span class="cov8" title="1">for r &lt; n &amp;&amp; p[r] != '/' </span><span class="cov8" title="1">{
                                bufApp(&amp;buf, p, w, p[r])
                                w++
                                r++
                        }</span>
                }
        }

        // Re-append trailing slash
        <span class="cov8" title="1">if trailing &amp;&amp; w &gt; 1 </span><span class="cov8" title="1">{
                bufApp(&amp;buf, p, w, '/')
                w++
        }</span>

        // If the original string was not modified (or only shortened at the end),
        // return the respective substring of the original string.
        // Otherwise return a new string from the buffer.
        <span class="cov8" title="1">if len(buf) == 0 </span><span class="cov8" title="1">{
                return p[:w]
        }</span>
        <span class="cov8" title="1">return string(buf[:w])</span>
}

// Internal helper to lazily create a buffer if necessary.
// Calls to this function get inlined.
func bufApp(buf *[]byte, s string, w int, c byte) <span class="cov8" title="1">{
        b := *buf
        if len(b) == 0 </span><span class="cov8" title="1">{
                // No modification of the original string so far.
                // If the next character is the same as in the original string, we do
                // not yet have to allocate a buffer.
                if s[w] == c </span><span class="cov8" title="1">{
                        return
                }</span>

                // Otherwise use either the stack buffer, if it is large enough, or
                // allocate a new buffer on the heap, and copy all previous characters.
                <span class="cov8" title="1">if l := len(s); l &gt; cap(b) </span><span class="cov0" title="0">{
                        *buf = make([]byte, len(s))
                }</span> else<span class="cov8" title="1"> {
                        *buf = (*buf)[:l]
                }</span>
                <span class="cov8" title="1">b = *buf

                copy(b, s[:w])</span>
        }
        <span class="cov8" title="1">b[w] = c</span>
}

// AddMissingPort adds a port to a host if it is missing.
// A literal IPv6 address in hostport must be enclosed in square
// brackets, as in "[::1]:80", "[::1%lo0]:80".
func AddMissingPort(addr string, isTLS bool) string <span class="cov8" title="1">{
        if strings.IndexByte(addr, ':') &gt;= 0 </span><span class="cov8" title="1">{
                endOfV6 := strings.IndexByte(addr, ']')
                // we do not care about the validity of the address, just check if it has more bytes after ']'
                if endOfV6 &lt; len(addr)-1 </span><span class="cov8" title="1">{
                        return addr
                }</span>
        }
        <span class="cov8" title="1">if !isTLS </span><span class="cov8" title="1">{
                return addr + ":80"
        }</span>
        <span class="cov8" title="1">return addr + ":443"</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015-present Aliaksandr Valialkin, VertaMedia, Kirill Danshin, Erik Dubbelboer, FastHTTP Authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This file may have been modified by CloudWeGo authors. All CloudWeGo
 * Modifications are Copyright 2022 CloudWeGo Authors.
 */

package utils

import (
        "bytes"
        "reflect"
        "runtime"
        "strings"

        "github.com/cloudwego/hertz/internal/bytesconv"
        errs "github.com/cloudwego/hertz/pkg/common/errors"
)

var errNeedMore = errs.New(errs.ErrNeedMore, errs.ErrorTypePublic, "cannot find trailing lf")

func Assert(guard bool, text string) <span class="cov8" title="1">{
        if !guard </span><span class="cov8" title="1">{
                panic(text)</span>
        }
}

// H is a shortcut for map[string]interface{}
type H map[string]interface{}

func IsTrueString(str string) bool <span class="cov8" title="1">{
        return strings.ToLower(str) == "true"
}</span>

func NameOfFunction(f interface{}) string <span class="cov8" title="1">{
        return runtime.FuncForPC(reflect.ValueOf(f).Pointer()).Name()
}</span>

func CaseInsensitiveCompare(a, b []byte) bool <span class="cov8" title="1">{
        if len(a) != len(b) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">for i := 0; i &lt; len(a); i++ </span><span class="cov8" title="1">{
                if a[i]|0x20 != b[i]|0x20 </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func NormalizeHeaderKey(b []byte, disableNormalizing bool) <span class="cov8" title="1">{
        if disableNormalizing </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">n := len(b)
        if n == 0 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">b[0] = bytesconv.ToUpperTable[b[0]]
        for i := 1; i &lt; n; i++ </span><span class="cov8" title="1">{
                p := &amp;b[i]
                if *p == '-' </span><span class="cov8" title="1">{
                        i++
                        if i &lt; n </span><span class="cov8" title="1">{
                                b[i] = bytesconv.ToUpperTable[b[i]]
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }
                <span class="cov8" title="1">*p = bytesconv.ToLowerTable[*p]</span>
        }
}

func NextLine(b []byte) ([]byte, []byte, error) <span class="cov8" title="1">{
        nNext := bytes.IndexByte(b, '\n')
        if nNext &lt; 0 </span><span class="cov8" title="1">{
                return nil, nil, errNeedMore
        }</span>
        <span class="cov8" title="1">n := nNext
        if n &gt; 0 &amp;&amp; b[n-1] == '\r' </span><span class="cov8" title="1">{
                n--
        }</span>
        <span class="cov8" title="1">return b[:n], b[nNext+1:], nil</span>
}

func FilterContentType(content string) string <span class="cov8" title="1">{
        for i, char := range content </span><span class="cov8" title="1">{
                if char == ' ' || char == ';' </span><span class="cov8" title="1">{
                        return content[:i]
                }</span>
        }
        <span class="cov8" title="1">return content</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">//go:build !windows
// +build !windows

/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package dialer

import "github.com/cloudwego/hertz/pkg/network/netpoll"

func init() <span class="cov8" title="1">{
        defaultDialer = netpoll.NewDialer()
}</span>
</pre>
		
		<pre class="file" id="file65" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package dialer

import (
        "crypto/tls"
        "net"
        "time"

        "github.com/cloudwego/hertz/pkg/network"
)

var defaultDialer network.Dialer

// SetDialer is used to set the global default dialer.
// Deprecated: use WithDialer instead.
func SetDialer(dialer network.Dialer) <span class="cov8" title="1">{
        defaultDialer = dialer
}</span>

func DefaultDialer() network.Dialer <span class="cov8" title="1">{
        return defaultDialer
}</span>

func DialConnection(network, address string, timeout time.Duration, tlsConfig *tls.Config) (conn network.Conn, err error) <span class="cov8" title="1">{
        return defaultDialer.DialConnection(network, address, timeout, tlsConfig)
}</span>

func DialTimeout(network, address string, timeout time.Duration, tlsConfig *tls.Config) (conn net.Conn, err error) <span class="cov8" title="1">{
        return defaultDialer.DialTimeout(network, address, timeout, tlsConfig)
}</span>

// AddTLS is used to add tls to a persistent connection, i.e. negotiate a TLS session. If conn is already a TLS
// tunnel, this function establishes a nested TLS session inside the encrypted channel.
func AddTLS(conn network.Conn, tlsConfig *tls.Config) (network.Conn, error) <span class="cov8" title="1">{
        return defaultDialer.AddTLS(conn, tlsConfig)
}</span>
</pre>
		
		<pre class="file" id="file66" style="display: none">// Copyright 2022 CloudWeGo Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package netpoll

import (
        "errors"
        "io"
        "strings"
        "syscall"

        errs "github.com/cloudwego/hertz/pkg/common/errors"
        "github.com/cloudwego/hertz/pkg/common/hlog"
        "github.com/cloudwego/hertz/pkg/network"
        "github.com/cloudwego/netpoll"
)

type Conn struct {
        network.Conn
}

func (c *Conn) ToHertzError(err error) error <span class="cov0" title="0">{
        if errors.Is(err, netpoll.ErrConnClosed) || errors.Is(err, syscall.EPIPE) </span><span class="cov0" title="0">{
                return errs.ErrConnectionClosed
        }</span>

        // only unify read timeout for now
        <span class="cov0" title="0">if errors.Is(err, netpoll.ErrReadTimeout) </span><span class="cov0" title="0">{
                return errs.ErrTimeout
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (c *Conn) Peek(n int) (b []byte, err error) <span class="cov8" title="1">{
        b, err = c.Conn.Peek(n)
        err = normalizeErr(err)
        return
}</span>

func (c *Conn) Read(p []byte) (int, error) <span class="cov0" title="0">{
        n, err := c.Conn.Read(p)
        err = normalizeErr(err)
        return n, err
}</span>

func (c *Conn) Skip(n int) error <span class="cov8" title="1">{
        return c.Conn.Skip(n)
}</span>

func (c *Conn) Release() error <span class="cov8" title="1">{
        return c.Conn.Release()
}</span>

func (c *Conn) Len() int <span class="cov8" title="1">{
        return c.Conn.Len()
}</span>

func (c *Conn) ReadByte() (b byte, err error) <span class="cov8" title="1">{
        b, err = c.Conn.ReadByte()
        err = normalizeErr(err)
        return
}</span>

func (c *Conn) ReadBinary(n int) (b []byte, err error) <span class="cov8" title="1">{
        b, err = c.Conn.ReadBinary(n)
        err = normalizeErr(err)
        return
}</span>

func (c *Conn) Malloc(n int) (buf []byte, err error) <span class="cov8" title="1">{
        return c.Conn.Malloc(n)
}</span>

func (c *Conn) WriteBinary(b []byte) (n int, err error) <span class="cov8" title="1">{
        return c.Conn.WriteBinary(b)
}</span>

func (c *Conn) Flush() error <span class="cov8" title="1">{
        return c.Conn.Flush()
}</span>

func (c *Conn) HandleSpecificError(err error, rip string) (needIgnore bool) <span class="cov8" title="1">{
        if errors.Is(err, netpoll.ErrConnClosed) || errors.Is(err, syscall.EPIPE) || errors.Is(err, syscall.ECONNRESET) </span><span class="cov8" title="1">{
                // ignore flushing error when connection is closed or reset
                if strings.Contains(err.Error(), "when flush") </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov8" title="1">hlog.SystemLogger().Debugf("Netpoll error=%s, remoteAddr=%s", err.Error(), rip)
                return true</span>
        }
        <span class="cov8" title="1">return false</span>
}

func normalizeErr(err error) error <span class="cov8" title="1">{
        if errors.Is(err, netpoll.ErrEOF) </span><span class="cov0" title="0">{
                return io.EOF
        }</span>

        <span class="cov8" title="1">return err</span>
}

func newConn(c netpoll.Connection) network.Conn <span class="cov8" title="1">{
        return &amp;Conn{Conn: c.(network.Conn)}
}</span>
</pre>
		
		<pre class="file" id="file67" style="display: none">// Copyright 2022 CloudWeGo Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package netpoll

import (
        "crypto/tls"
        "net"
        "time"

        "github.com/cloudwego/hertz/pkg/common/errors"
        "github.com/cloudwego/hertz/pkg/network"
        "github.com/cloudwego/netpoll"
)

var errNotSupportTLS = errors.NewPublic("not support tls")

type dialer struct {
        netpoll.Dialer
}

func (d dialer) DialConnection(n, address string, timeout time.Duration, tlsConfig *tls.Config) (conn network.Conn, err error) <span class="cov8" title="1">{
        if tlsConfig != nil </span><span class="cov8" title="1">{
                // https
                return nil, errNotSupportTLS
        }</span>
        <span class="cov8" title="1">c, err := d.Dialer.DialConnection(n, address, timeout)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">conn = newConn(c)
        return</span>
}

func (d dialer) DialTimeout(network, address string, timeout time.Duration, tlsConfig *tls.Config) (conn net.Conn, err error) <span class="cov8" title="1">{
        if tlsConfig != nil </span><span class="cov8" title="1">{
                return nil, errNotSupportTLS
        }</span>
        <span class="cov8" title="1">conn, err = d.Dialer.DialTimeout(network, address, timeout)
        return</span>
}

func (d dialer) AddTLS(conn network.Conn, tlsConfig *tls.Config) (network.Conn, error) <span class="cov8" title="1">{
        return nil, errNotSupportTLS
}</span>

func NewDialer() network.Dialer <span class="cov8" title="1">{
        return dialer{Dialer: netpoll.NewDialer()}
}</span>
</pre>
		
		<pre class="file" id="file68" style="display: none">// Copyright 2022 CloudWeGo Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

//go:build !windows
// +build !windows

package netpoll

import (
        "context"
        "io"
        "net"
        "sync"
        "time"

        "github.com/cloudwego/hertz/pkg/common/config"
        "github.com/cloudwego/hertz/pkg/common/hlog"
        "github.com/cloudwego/hertz/pkg/network"
        "github.com/cloudwego/netpoll"
)

func init() <span class="cov8" title="1">{
        // disable netpoll's log
        netpoll.SetLoggerOutput(io.Discard)
}</span>

type ctxCancelKeyStruct struct{}

var ctxCancelKey = ctxCancelKeyStruct{}

func cancelContext(ctx context.Context) context.Context <span class="cov8" title="1">{
        ctx, cancel := context.WithCancel(ctx)
        ctx = context.WithValue(ctx, ctxCancelKey, cancel)
        return ctx
}</span>

type transporter struct {
        sync.RWMutex
        senseClientDisconnection bool
        network                  string
        addr                     string
        keepAliveTimeout         time.Duration
        readTimeout              time.Duration
        writeTimeout             time.Duration
        listener                 net.Listener
        eventLoop                netpoll.EventLoop
        listenConfig             *net.ListenConfig
        OnAccept                 func(conn net.Conn) context.Context
        OnConnect                func(ctx context.Context, conn network.Conn) context.Context
}

// For transporter switch
func NewTransporter(options *config.Options) network.Transporter <span class="cov8" title="1">{
        return &amp;transporter{
                senseClientDisconnection: options.SenseClientDisconnection,
                network:                  options.Network,
                addr:                     options.Addr,
                keepAliveTimeout:         options.KeepAliveTimeout,
                readTimeout:              options.ReadTimeout,
                writeTimeout:             options.WriteTimeout,
                listener:                 nil,
                eventLoop:                nil,
                listenConfig:             options.ListenConfig,
                OnAccept:                 options.OnAccept,
                OnConnect:                options.OnConnect,
        }
}</span>

// ListenAndServe binds listen address and keep serving, until an error occurs
// or the transport shutdowns
func (t *transporter) ListenAndServe(onReq network.OnData) (err error) <span class="cov8" title="1">{
        network.UnlinkUdsFile(t.network, t.addr) //nolint:errcheck
        if t.listenConfig != nil </span><span class="cov0" title="0">{
                t.listener, err = t.listenConfig.Listen(context.Background(), t.network, t.addr)
        }</span> else<span class="cov8" title="1"> {
                t.listener, err = net.Listen(t.network, t.addr)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                panic("create netpoll listener fail: " + err.Error())</span>
        }

        // Initialize custom option for EventLoop
        <span class="cov8" title="1">opts := []netpoll.Option{
                netpoll.WithIdleTimeout(t.keepAliveTimeout),
                netpoll.WithOnPrepare(func(conn netpoll.Connection) context.Context </span><span class="cov8" title="1">{
                        conn.SetReadTimeout(t.readTimeout) // nolint:errcheck
                        if t.writeTimeout &gt; 0 </span><span class="cov8" title="1">{
                                conn.SetWriteTimeout(t.writeTimeout)
                        }</span>
                        <span class="cov8" title="1">ctx := context.Background()
                        if t.OnAccept != nil </span><span class="cov8" title="1">{
                                ctx = t.OnAccept(newConn(conn))
                        }</span>
                        <span class="cov8" title="1">if t.senseClientDisconnection </span><span class="cov8" title="1">{
                                ctx = cancelContext(ctx)
                        }</span>
                        <span class="cov8" title="1">return ctx</span>
                }),
        }

        <span class="cov8" title="1">if t.OnConnect != nil </span><span class="cov8" title="1">{
                opts = append(opts, netpoll.WithOnConnect(func(ctx context.Context, conn netpoll.Connection) context.Context </span><span class="cov8" title="1">{
                        return t.OnConnect(ctx, newConn(conn))
                }</span>))
        }

        <span class="cov8" title="1">if t.senseClientDisconnection </span><span class="cov8" title="1">{
                opts = append(opts, netpoll.WithOnDisconnect(func(ctx context.Context, connection netpoll.Connection) </span><span class="cov8" title="1">{
                        cancelFunc, ok := ctx.Value(ctxCancelKey).(context.CancelFunc)
                        if cancelFunc != nil &amp;&amp; ok </span><span class="cov8" title="1">{
                                cancelFunc()
                        }</span>
                }))
        }

        // Create EventLoop
        <span class="cov8" title="1">t.Lock()
        t.eventLoop, err = netpoll.NewEventLoop(func(ctx context.Context, connection netpoll.Connection) error </span><span class="cov8" title="1">{
                return onReq(ctx, newConn(connection))
        }</span>, opts...)
        <span class="cov8" title="1">t.Unlock()
        if err != nil </span><span class="cov0" title="0">{
                panic("create netpoll event-loop fail")</span>
        }

        // Start Server
        <span class="cov8" title="1">hlog.SystemLogger().Infof("HTTP server listening on address=%s", t.listener.Addr().String())
        t.RLock()
        err = t.eventLoop.Serve(t.listener)
        t.RUnlock()
        if err != nil </span><span class="cov0" title="0">{
                panic("netpoll server exit")</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Close forces transport to close immediately (no wait timeout)
func (t *transporter) Close() error <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(context.Background(), 0)
        defer cancel()
        return t.Shutdown(ctx)
}</span>

// Shutdown will trigger listener stop and graceful shutdown
// It will wait all connections close until reaching ctx.Deadline()
func (t *transporter) Shutdown(ctx context.Context) error <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                network.UnlinkUdsFile(t.network, t.addr) //nolint:errcheck
                t.RUnlock()
        }</span>()
        <span class="cov8" title="1">t.RLock()
        if t.eventLoop == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return t.eventLoop.Shutdown(ctx)</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package standard

import (
        "sync"

        "github.com/bytedance/gopkg/lang/mcache"
)

var bufferPool = sync.Pool{}

func init() <span class="cov8" title="1">{
        bufferPool.New = func() interface{} </span><span class="cov8" title="1">{
                return &amp;linkBufferNode{}
        }</span>
}

type linkBufferNode struct {
        buf      []byte          // buffer
        off      int             // read-offset
        malloc   int             // write-offset
        next     *linkBufferNode // the next node of the linked buffer
        readOnly bool            // whether this node is a read only node
}

type linkBuffer struct {
        // The release head
        head *linkBufferNode
        // The read pointer to point current read node
        // There is no need to save current write node
        read *linkBufferNode
        // Tail node
        write *linkBufferNode
        len   int
}

func (l *linkBuffer) release() <span class="cov8" title="1">{
        for l.head != nil </span><span class="cov8" title="1">{
                node := l.head
                l.head = l.head.next
                node.Release()
        }</span>
}

// newBufferNode creates a new node with buffer size
func newBufferNode(size int) *linkBufferNode <span class="cov8" title="1">{
        buf := bufferPool.Get().(*linkBufferNode)
        buf.buf = malloc(size, size)
        return buf
}</span>

// Reset resets this node.
//
// NOTE: Reset won't recycle the buffer of node.
func (b *linkBufferNode) Reset() <span class="cov8" title="1">{
        b.buf = b.buf[:0]
        b.off, b.malloc = 0, 0
        b.readOnly = false
}</span>

// Len calculates the data size of this node.
func (b *linkBufferNode) Len() int <span class="cov8" title="1">{
        return b.malloc - b.off
}</span>

func (b *linkBufferNode) recyclable() bool <span class="cov8" title="1">{
        return cap(b.buf) &lt;= block8k &amp;&amp; !b.readOnly
}</span>

// Cap returns the capacity of the node buffer
func (b *linkBufferNode) Cap() int <span class="cov8" title="1">{
        return cap(b.buf) - b.malloc
}</span>

// Release will recycle the buffer of node
func (b *linkBufferNode) Release() <span class="cov8" title="1">{
        if !b.readOnly </span><span class="cov8" title="1">{
                free(b.buf)
        }</span>
        <span class="cov8" title="1">b.readOnly = false
        b.buf = nil
        b.next = nil
        b.malloc, b.off = 0, 0
        bufferPool.Put(b)</span>
}

// malloc limits the cap of the buffer from mcache.
func malloc(size, capacity int) []byte <span class="cov8" title="1">{
        if capacity &gt; mallocMax </span><span class="cov8" title="1">{
                return make([]byte, size, capacity)
        }</span>
        <span class="cov8" title="1">return mcache.Malloc(size, capacity)</span>
}

// free limits the cap of the buffer from mcache.
func free(buf []byte) <span class="cov8" title="1">{
        if cap(buf) &gt; mallocMax </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">mcache.Free(buf)</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package standard

import (
        "crypto/tls"
        "errors"
        "io"
        "net"
        "runtime"
        "strconv"
        "syscall"
        "time"

        errs "github.com/cloudwego/hertz/pkg/common/errors"
        "github.com/cloudwego/hertz/pkg/common/hlog"
        "github.com/cloudwego/hertz/pkg/network"
)

const (
        block1k                  = 1024
        block4k                  = 4096
        block8k                  = 8192
        mallocMax                = block1k * 512
        defaultMallocSize        = block4k
        maxConsecutiveEmptyReads = 100
)

type Conn struct {
        c            net.Conn
        inputBuffer  *linkBuffer
        outputBuffer *linkBuffer
        caches       [][]byte // buf allocated by Next when cross-package, which should be freed when release
        maxSize      int      // history max malloc size

        err error
}

func (c *Conn) ToHertzError(err error) error <span class="cov0" title="0">{
        if errors.Is(err, syscall.EPIPE) || errors.Is(err, syscall.ENOTCONN) </span><span class="cov0" title="0">{
                return errs.ErrConnectionClosed
        }</span>
        <span class="cov0" title="0">if netErr, ok := err.(*net.OpError); ok &amp;&amp; netErr.Timeout() </span><span class="cov0" title="0">{
                return errs.ErrTimeout
        }</span>

        <span class="cov0" title="0">return err</span>
}

func (c *Conn) SetWriteTimeout(t time.Duration) error <span class="cov0" title="0">{
        if t &lt;= 0 </span><span class="cov0" title="0">{
                return c.c.SetWriteDeadline(time.Time{})
        }</span>
        <span class="cov0" title="0">return c.c.SetWriteDeadline(time.Now().Add(t))</span>
}

func (c *Conn) SetReadTimeout(t time.Duration) error <span class="cov8" title="1">{
        if t &lt;= 0 </span><span class="cov8" title="1">{
                return c.c.SetReadDeadline(time.Time{})
        }</span>
        <span class="cov8" title="1">return c.c.SetReadDeadline(time.Now().Add(t))</span>
}

type TLSConn struct {
        Conn
}

func min(a, b int) int <span class="cov8" title="1">{
        if a &lt; b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}

func (c *Conn) Read(b []byte) (l int, err error) <span class="cov8" title="1">{
        l = c.Len()
        // If there is some data in inputBuffer, copy it to b and return.
        if l &gt; 0 </span><span class="cov8" title="1">{
                l = min(l, len(b))
                return l, c.next(l, b)
        }</span>

        // If left buffer size is less than block4k, first Peek(1) to fill the buffer.
        // Then copy min(c.Len, len(b)) to b.
        <span class="cov8" title="1">if len(b) &lt;= block4k </span><span class="cov8" title="1">{
                // If c.fill(1) return err, conn.Read must return 0, err. So there is no need
                // to check c.Len
                err = c.fill(1)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov8" title="1">l = min(c.Len(), len(b))
                return l, c.next(l, b)</span>
        }

        // Call Read() directly to fill buffer b
        <span class="cov8" title="1">return c.c.Read(b)</span>
}

// Write calls Write syscall directly to send data.
// Will flush buffer immediately, for performance considerations use WriteBinary instead.
func (c *Conn) Write(b []byte) (n int, err error) <span class="cov8" title="1">{
        if err = c.Flush(); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">return c.c.Write(b)</span>
}

// ReadFrom implements io.ReaderFrom. If the underlying writer
// supports the ReadFrom method, and c has no buffered data yet,
// this calls the underlying ReadFrom without buffering.
func (c *Conn) ReadFrom(r io.Reader) (n int64, err error) <span class="cov8" title="1">{
        if err = c.Flush(); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if w, ok := c.c.(io.ReaderFrom); ok </span><span class="cov0" title="0">{
                n, err = w.ReadFrom(r)
                return
        }</span>

        <span class="cov8" title="1">var m int
        bufNode := c.outputBuffer.write

        // if there is no available buffer, create one.
        if !bufNode.recyclable() || cap(bufNode.buf) == 0 </span><span class="cov0" title="0">{
                c.Malloc(block4k)
                c.outputBuffer.write.Reset()
                c.outputBuffer.len = cap(c.outputBuffer.write.buf)
                bufNode = c.outputBuffer.write
        }</span>

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                if bufNode.Cap() == 0 </span><span class="cov8" title="1">{
                        if err1 := c.Flush(); err1 != nil </span><span class="cov0" title="0">{
                                return n, err1
                        }</span>
                }

                <span class="cov8" title="1">nr := 0
                for nr &lt; maxConsecutiveEmptyReads </span><span class="cov8" title="1">{
                        m, err = r.Read(bufNode.buf[bufNode.malloc:cap(bufNode.buf)])
                        if m != 0 || err != nil </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov0" title="0">nr++</span>
                }
                <span class="cov8" title="1">if nr == maxConsecutiveEmptyReads </span><span class="cov0" title="0">{
                        return n, io.ErrNoProgress
                }</span>
                <span class="cov8" title="1">bufNode.malloc += m
                n += int64(m)
                if err != nil </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">if err == io.EOF </span><span class="cov8" title="1">{
                // If we filled the buffer exactly, flush preemptively.
                if bufNode.Cap() == 0 </span><span class="cov0" title="0">{
                        err = c.Flush()
                }</span> else<span class="cov8" title="1"> {
                        err = nil
                        // Update buffer available length for next Malloc
                        c.outputBuffer.len = bufNode.Cap()
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

// Close closes the connection
func (c *Conn) Close() error <span class="cov8" title="1">{
        return c.c.Close()
}</span>

// CloseNoResetBuffer closes the connection without reset buffer.
func (c *Conn) CloseNoResetBuffer() error <span class="cov0" title="0">{
        return c.c.Close()
}</span>

// LocalAddr returns the local address of the connection.
func (c *Conn) LocalAddr() net.Addr <span class="cov8" title="1">{
        return c.c.LocalAddr()
}</span>

// RemoteAddr returns the remote address of the connection.
func (c *Conn) RemoteAddr() net.Addr <span class="cov8" title="1">{
        return c.c.RemoteAddr()
}</span>

// SetDeadline sets the connection deadline.
func (c *Conn) SetDeadline(t time.Time) error <span class="cov8" title="1">{
        return c.c.SetDeadline(t)
}</span>

// SetReadDeadline sets the read deadline of the connection.
func (c *Conn) SetReadDeadline(t time.Time) error <span class="cov8" title="1">{
        return c.c.SetReadDeadline(t)
}</span>

// SetWriteDeadline sets the write deadline of the connection.
func (c *Conn) SetWriteDeadline(t time.Time) error <span class="cov8" title="1">{
        return c.c.SetWriteDeadline(t)
}</span>

func (c *Conn) releaseCaches() <span class="cov8" title="1">{
        for i := range c.caches </span><span class="cov8" title="1">{
                free(c.caches[i])
                c.caches[i] = nil
        }</span>
        <span class="cov8" title="1">c.caches = c.caches[:0]</span>
}

// Release release linkBuffer.
//
// NOTE: This function should only be called in inputBuffer.
func (c *Conn) Release() error <span class="cov8" title="1">{
        // c.Len() is used to check whether the data has been fully read. If there
        // is some data in inputBuffer, we mustn't use head and write to check
        // whether current node can be released. We should use head and read as the
        // judge connection.
        if c.Len() == 0 </span><span class="cov8" title="1">{
                // Reset buffer so that we can reuse it
                // In this case, the request can be held in one single node. We just need
                // Reset this node to hold next request.
                //
                // NOTE: Each connection will bind a buffer. We need to care about the memory usage.
                if c.inputBuffer.head == c.inputBuffer.write </span><span class="cov8" title="1">{
                        c.inputBuffer.write.Reset()
                        return nil
                }</span>

                // Critical condition that the buffer is big enough to hold the whole request
                // In this case, head holds the last request and current request has been held
                // in write node. So we just need to release head and reset write.
                <span class="cov8" title="1">if c.inputBuffer.head.next == c.inputBuffer.write </span><span class="cov8" title="1">{
                        // Recalculate the maxSize
                        size := c.inputBuffer.head.malloc
                        node := c.inputBuffer.head
                        node.Release()
                        size += c.inputBuffer.write.malloc
                        if size &gt; mallocMax </span><span class="cov0" title="0">{
                                size = mallocMax
                        }</span>
                        <span class="cov8" title="1">if size &gt; c.maxSize </span><span class="cov8" title="1">{
                                c.maxSize = size
                        }</span>
                        <span class="cov8" title="1">c.handleTail()
                        c.inputBuffer.head, c.inputBuffer.read = c.inputBuffer.write, c.inputBuffer.write
                        c.releaseCaches()
                        return nil</span>
                }
        }

        // If there is some data in the buffer, it means the request hasn't been fully handled.
        // Or the request is too big to hold in a single node.
        // Cross multi node.
        <span class="cov8" title="1">size := 0
        for c.inputBuffer.head != c.inputBuffer.read </span><span class="cov8" title="1">{
                node := c.inputBuffer.head
                c.inputBuffer.head = c.inputBuffer.head.next
                size += c.inputBuffer.head.malloc
                node.Release()
        }</span>
        // The readOnly field in readOnly is just used to malloc a new node so that next
        // request can be held in one node.
        // It has nothing to do with release logic.
        <span class="cov8" title="1">c.inputBuffer.write.readOnly = true
        if size &gt; mallocMax </span><span class="cov8" title="1">{
                size = mallocMax
        }</span>
        <span class="cov8" title="1">if size &gt; c.maxSize </span><span class="cov8" title="1">{
                c.maxSize = size
        }</span>
        <span class="cov8" title="1">c.releaseCaches()
        return nil</span>
}

// handleTail prevents too large tail node to ensure the memory usage.
func (c *Conn) handleTail() <span class="cov8" title="1">{
        if cap(c.inputBuffer.write.buf) &gt; mallocMax </span><span class="cov0" title="0">{
                node := c.inputBuffer.write
                c.inputBuffer.write.next = newBufferNode(c.maxSize)
                c.inputBuffer.write = c.inputBuffer.write.next
                node.Release()
                return
        }</span>
        <span class="cov8" title="1">c.inputBuffer.write.Reset()</span>
}

// Peek returns the next n bytes without advancing the reader. The bytes stop
// being valid at the next read call. If Peek returns fewer than n bytes, it
// also returns an error explaining why the read is short.
func (c *Conn) Peek(i int) (p []byte, err error) <span class="cov8" title="1">{
        node := c.inputBuffer.read
        // fill the inputBuffer so that there is enough data
        err = c.fill(i)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if c.Len() &lt; i </span><span class="cov8" title="1">{
                i = c.Len()
                err = c.readErr()
        }</span>

        <span class="cov8" title="1">l := node.Len()
        // Enough data in a single node, so that just return the slice of the node.
        if l &gt;= i </span><span class="cov8" title="1">{
                return node.buf[node.off : node.off+i], err
        }</span>

        // not enough data in a signal node
        <span class="cov8" title="1">if block1k &lt; i &amp;&amp; i &lt;= mallocMax </span><span class="cov8" title="1">{
                p = malloc(i, i)
                c.caches = append(c.caches, p)
        }</span> else<span class="cov8" title="1"> {
                p = make([]byte, i)
        }</span>
        <span class="cov8" title="1">c.peekBuffer(i, p)
        return p, err</span>
}

// peekBuffer loads the buf with data of size i without moving read pointer.
func (c *Conn) peekBuffer(i int, buf []byte) <span class="cov8" title="1">{
        l, pIdx, node := 0, 0, c.inputBuffer.read
        for ack := i; ack &gt; 0; ack = ack - l </span><span class="cov8" title="1">{
                l = node.Len()
                if l &gt;= ack </span><span class="cov8" title="1">{
                        copy(buf[pIdx:], node.buf[node.off:node.off+ack])
                        break</span>
                } else<span class="cov8" title="1"> if l &gt; 0 </span><span class="cov8" title="1">{
                        pIdx += copy(buf[pIdx:], node.buf[node.off:node.off+l])
                }</span>
                <span class="cov8" title="1">node = node.next</span>
        }
}

// next loads the buf with data of size i with moving read pointer.
func (c *Conn) next(length int, b []byte) error <span class="cov8" title="1">{
        c.peekBuffer(length, b)
        err := c.Skip(length)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return c.Release()</span>
}

// fill loads more data than size i, otherwise it will block read.
// NOTE: fill may fill data less than i and store err in Conn.err
// when last read returns n &gt; 0 and err != nil. So after calling
// fill, it is necessary to check whether c.Len() &gt; i
func (c *Conn) fill(i int) (err error) <span class="cov8" title="1">{
        // Check if there is enough data in inputBuffer.
        if c.Len() &gt;= i </span><span class="cov8" title="1">{
                return nil
        }</span>
        // check whether conn has returned err before.
        <span class="cov8" title="1">if err = c.readErr(); err != nil </span><span class="cov8" title="1">{
                if c.Len() &gt; 0 </span><span class="cov8" title="1">{
                        c.err = err
                        return nil
                }</span>
                <span class="cov0" title="0">return</span>
        }
        <span class="cov8" title="1">node := c.inputBuffer.write
        node.buf = node.buf[:cap(node.buf)]
        left := cap(node.buf) - node.malloc

        // If left capacity is less than the length of expected data
        // or it is a new request, we malloc an enough node to hold
        // the data
        if left &lt; i-c.Len() || node.readOnly </span><span class="cov8" title="1">{
                // not enough capacity
                malloc := i
                if i &lt; c.maxSize </span><span class="cov0" title="0">{
                        malloc = c.maxSize
                }</span>
                <span class="cov8" title="1">c.inputBuffer.write.next = newBufferNode(malloc)
                c.inputBuffer.write = c.inputBuffer.write.next
                // Set readOnly flag to false so that current node can be recycled.
                // In inputBuffer, whether readOnly value is, the node need to be recycled.
                node.readOnly = false</span>
        }

        <span class="cov8" title="1">i -= c.Len()
        node = c.inputBuffer.write
        node.buf = node.buf[:cap(node.buf)]

        // Circulate reading data so that the node holds enough data
        for i &gt; 0 </span><span class="cov8" title="1">{
                n, err := c.c.Read(c.inputBuffer.write.buf[node.malloc:])
                if n &gt; 0 </span><span class="cov8" title="1">{
                        node.malloc += n
                        c.inputBuffer.len += n
                        i -= n
                        if err != nil </span><span class="cov8" title="1">{
                                c.err = err
                                return nil
                        }</span>
                }
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Skip discards the next n bytes.
func (c *Conn) Skip(n int) error <span class="cov8" title="1">{
        // check whether enough or not.
        if c.Len() &lt; n </span><span class="cov8" title="1">{
                return errs.NewPrivate("link buffer skip[" + strconv.Itoa(n) + "] not enough")
        }</span>
        <span class="cov8" title="1">c.inputBuffer.len -= n // re-cal length

        var l int
        for ack := n; ack &gt; 0; ack = ack - l </span><span class="cov8" title="1">{
                l = c.inputBuffer.read.Len()
                if l &gt;= ack </span><span class="cov8" title="1">{
                        c.inputBuffer.read.off += ack
                        break</span>
                }
                <span class="cov8" title="1">c.inputBuffer.read = c.inputBuffer.read.next</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// ReadByte is used to read one byte with advancing the read pointer.
func (c *Conn) ReadByte() (p byte, err error) <span class="cov8" title="1">{
        b, err := c.Peek(1)
        if err != nil </span><span class="cov0" title="0">{
                return ' ', err
        }</span>
        <span class="cov8" title="1">err = c.Skip(1)
        if err != nil </span><span class="cov0" title="0">{
                return ' ', err
        }</span>
        <span class="cov8" title="1">return b[0], nil</span>
}

// ReadBinary is used to read next n byte with copy, and the read pointer will be advanced.
func (c *Conn) ReadBinary(i int) ([]byte, error) <span class="cov8" title="1">{
        out := make([]byte, i)
        b, err := c.Peek(i)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">copy(out, b)
        err = c.Skip(i)
        return out, err</span>
}

// Len returns the total length of the readable data in the reader.
func (c *Conn) Len() int <span class="cov8" title="1">{
        return c.inputBuffer.len
}</span>

// Malloc will provide a n bytes buffer to send data.
func (c *Conn) Malloc(n int) (buf []byte, err error) <span class="cov8" title="1">{
        if n == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        // If the capacity of the current buffer is larger than we need,
        // there is no need to malloc new node
        <span class="cov8" title="1">if c.outputBuffer.len &gt; n </span><span class="cov8" title="1">{
                node := c.outputBuffer.write
                malloc := node.malloc
                node.malloc += n
                node.buf = node.buf[:node.malloc]
                c.outputBuffer.len -= n
                return node.buf[malloc:node.malloc], nil
        }</span>

        <span class="cov8" title="1">mallocSize := n
        if n &lt; defaultMallocSize </span><span class="cov8" title="1">{
                mallocSize = defaultMallocSize
        }</span>
        <span class="cov8" title="1">node := newBufferNode(mallocSize)
        node.malloc = n
        c.outputBuffer.len = cap(node.buf) - n
        c.outputBuffer.write.next = node
        c.outputBuffer.write = c.outputBuffer.write.next
        return node.buf[:n], nil</span>
}

// WriteBinary will use the user buffer to flush.
//
// NOTE: Before flush successfully, the buffer b should be valid.
func (c *Conn) WriteBinary(b []byte) (n int, err error) <span class="cov8" title="1">{
        // If the data size is less than 4k, then just copy to outputBuffer.
        if len(b) &lt; block4k </span><span class="cov8" title="1">{
                buf, err := c.Malloc(len(b))
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov8" title="1">return copy(buf, b), nil</span>
        }
        // Build a new node with buffer b.
        <span class="cov8" title="1">node := newBufferNode(0)
        node.malloc = len(b)
        node.readOnly = true
        node.buf = b
        c.outputBuffer.write.next = node
        c.outputBuffer.write = c.outputBuffer.write.next
        c.outputBuffer.len = 0
        return len(b), nil</span>
}

// Flush will send data to the peer end.
func (c *Conn) Flush() (err error) <span class="cov8" title="1">{
        // No data to flush
        if c.outputBuffer.head == c.outputBuffer.write &amp;&amp; c.outputBuffer.head.Len() == 0 </span><span class="cov8" title="1">{
                return
        }</span>

        // Current node is the tail node of last request, so move to next node.
        <span class="cov8" title="1">if c.outputBuffer.head.Len() == 0 </span><span class="cov8" title="1">{
                node := c.outputBuffer.head
                c.outputBuffer.head = c.outputBuffer.head.next
                node.Release()
        }</span>

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                n, err := c.c.Write(c.outputBuffer.head.buf[c.outputBuffer.head.off:c.outputBuffer.head.malloc])
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">c.outputBuffer.head.off += n
                if c.outputBuffer.head == c.outputBuffer.write </span><span class="cov8" title="1">{
                        // If the capacity of buffer is less than 8k, then just reset the node
                        if c.outputBuffer.head.recyclable() </span><span class="cov8" title="1">{
                                c.outputBuffer.head.Reset()
                                c.outputBuffer.len = cap(c.outputBuffer.head.buf)
                        }</span>
                        <span class="cov8" title="1">break</span>
                }
                // Flush next node
                <span class="cov8" title="1">node := c.outputBuffer.head
                c.outputBuffer.head = c.outputBuffer.head.next
                node.Release()</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (c *Conn) HandleSpecificError(err error, rip string) (needIgnore bool) <span class="cov8" title="1">{
        if errors.Is(err, syscall.EPIPE) || errors.Is(err, syscall.ECONNRESET) </span><span class="cov8" title="1">{
                hlog.SystemLogger().Debugf("Go net library error=%s, remoteAddr=%s", err.Error(), rip)
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

func (c *Conn) readErr() error <span class="cov8" title="1">{
        err := c.err
        c.err = nil
        return err
}</span>

func (c *TLSConn) Handshake() error <span class="cov8" title="1">{
        return c.c.(network.ConnTLSer).Handshake()
}</span>

func (c *TLSConn) ConnectionState() tls.ConnectionState <span class="cov8" title="1">{
        return c.c.(network.ConnTLSer).ConnectionState()
}</span>

func newConn(c net.Conn, size int) network.Conn <span class="cov8" title="1">{
        maxSize := defaultMallocSize
        if size &gt; maxSize </span><span class="cov8" title="1">{
                maxSize = size
        }</span>

        <span class="cov8" title="1">node := newBufferNode(maxSize)
        inputBuffer := &amp;linkBuffer{
                head:  node,
                read:  node,
                write: node,
        }
        runtime.SetFinalizer(inputBuffer, (*linkBuffer).release)

        outputNode := newBufferNode(0)
        outputBuffer := &amp;linkBuffer{
                head:  outputNode,
                write: outputNode,
        }
        runtime.SetFinalizer(outputBuffer, (*linkBuffer).release)

        return &amp;Conn{
                c:            c,
                inputBuffer:  inputBuffer,
                outputBuffer: outputBuffer,
                maxSize:      maxSize,
        }</span>
}

func newTLSConn(c net.Conn, size int) network.Conn <span class="cov8" title="1">{
        maxSize := defaultMallocSize
        if size &gt; maxSize </span><span class="cov8" title="1">{
                maxSize = size
        }</span>

        <span class="cov8" title="1">node := newBufferNode(maxSize)
        inputBuffer := &amp;linkBuffer{
                head:  node,
                read:  node,
                write: node,
        }
        runtime.SetFinalizer(inputBuffer, (*linkBuffer).release)

        outputNode := newBufferNode(0)
        outputBuffer := &amp;linkBuffer{
                head:  outputNode,
                write: outputNode,
        }
        runtime.SetFinalizer(outputBuffer, (*linkBuffer).release)

        return &amp;TLSConn{
                Conn{
                        c:            c,
                        inputBuffer:  inputBuffer,
                        outputBuffer: outputBuffer,
                        maxSize:      maxSize,
                },
        }</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package standard

import (
        "crypto/tls"
        "net"
        "time"

        "github.com/cloudwego/hertz/pkg/network"
)

type dialer struct{}

func (d *dialer) DialConnection(n, address string, timeout time.Duration, tlsConfig *tls.Config) (conn network.Conn, err error) <span class="cov8" title="1">{
        c, err := net.DialTimeout(n, address, timeout)
        if tlsConfig != nil </span><span class="cov8" title="1">{
                cTLS := tls.Client(c, tlsConfig)
                conn = newTLSConn(cTLS, defaultMallocSize)
                return
        }</span>
        <span class="cov8" title="1">conn = newConn(c, defaultMallocSize)
        return</span>
}

func (d *dialer) DialTimeout(network, address string, timeout time.Duration, tlsConfig *tls.Config) (conn net.Conn, err error) <span class="cov8" title="1">{
        conn, err = net.DialTimeout(network, address, timeout)
        return
}</span>

func (d *dialer) AddTLS(conn network.Conn, tlsConfig *tls.Config) (network.Conn, error) <span class="cov8" title="1">{
        cTlS := tls.Client(conn, tlsConfig)
        err := cTlS.Handshake()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">conn = newTLSConn(cTlS, defaultMallocSize)
        return conn, nil</span>
}

func NewDialer() network.Dialer <span class="cov8" title="1">{
        return &amp;dialer{}
}</span>
</pre>
		
		<pre class="file" id="file72" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package standard

import (
        "context"
        "crypto/tls"
        "net"
        "sync"
        "time"

        "github.com/cloudwego/hertz/pkg/common/config"
        "github.com/cloudwego/hertz/pkg/common/hlog"
        "github.com/cloudwego/hertz/pkg/network"
)

type transport struct {
        // Per-connection buffer size for requests' reading.
        // This also limits the maximum header size.
        //
        // Increase this buffer if your clients send multi-KB RequestURIs
        // and/or multi-KB headers (for example, BIG cookies).
        //
        // Default buffer size is used if not set.
        readBufferSize   int
        network          string
        addr             string
        keepAliveTimeout time.Duration
        readTimeout      time.Duration
        handler          network.OnData
        ln               net.Listener
        tls              *tls.Config
        listenConfig     *net.ListenConfig
        lock             sync.Mutex
        OnAccept         func(conn net.Conn) context.Context
        OnConnect        func(ctx context.Context, conn network.Conn) context.Context
}

func (t *transport) serve() (err error) <span class="cov8" title="1">{
        network.UnlinkUdsFile(t.network, t.addr) //nolint:errcheck
        t.lock.Lock()
        if t.listenConfig != nil </span><span class="cov0" title="0">{
                t.ln, err = t.listenConfig.Listen(context.Background(), t.network, t.addr)
        }</span> else<span class="cov8" title="1"> {
                t.ln, err = net.Listen(t.network, t.addr)
        }</span>
        <span class="cov8" title="1">t.lock.Unlock()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">hlog.SystemLogger().Infof("HTTP server listening on address=%s", t.ln.Addr().String())
        for </span><span class="cov8" title="1">{
                ctx := context.Background()
                conn, err := t.ln.Accept()
                var c network.Conn
                if err != nil </span><span class="cov8" title="1">{
                        hlog.SystemLogger().Errorf("Error=%s", err.Error())
                        return err
                }</span>

                <span class="cov8" title="1">if t.OnAccept != nil </span><span class="cov0" title="0">{
                        ctx = t.OnAccept(conn)
                }</span>

                <span class="cov8" title="1">if t.tls != nil </span><span class="cov0" title="0">{
                        c = newTLSConn(tls.Server(conn, t.tls), t.readBufferSize)
                }</span> else<span class="cov8" title="1"> {
                        c = newConn(conn, t.readBufferSize)
                }</span>

                <span class="cov8" title="1">if t.OnConnect != nil </span><span class="cov0" title="0">{
                        ctx = t.OnConnect(ctx, c)
                }</span>
                <span class="cov8" title="1">go t.handler(ctx, c)</span>
        }
}

func (t *transport) ListenAndServe(onData network.OnData) (err error) <span class="cov8" title="1">{
        t.handler = onData
        return t.serve()
}</span>

func (t *transport) Close() error <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(context.Background(), 0)
        defer cancel()
        return t.Shutdown(ctx)
}</span>

func (t *transport) Shutdown(ctx context.Context) error <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                network.UnlinkUdsFile(t.network, t.addr) //nolint:errcheck
        }</span>()
        <span class="cov8" title="1">t.lock.Lock()
        if t.ln != nil </span><span class="cov8" title="1">{
                _ = t.ln.Close()
        }</span>
        <span class="cov8" title="1">t.lock.Unlock()
        &lt;-ctx.Done()
        return nil</span>
}

// For transporter switch
func NewTransporter(options *config.Options) network.Transporter <span class="cov8" title="1">{
        return &amp;transport{
                readBufferSize:   options.ReadBufferSize,
                network:          options.Network,
                addr:             options.Addr,
                keepAliveTimeout: options.KeepAliveTimeout,
                readTimeout:      options.ReadTimeout,
                tls:              options.TLS,
                listenConfig:     options.ListenConfig,
                OnAccept:         options.OnAccept,
                OnConnect:        options.OnConnect,
        }
}</span>
</pre>
		
		<pre class="file" id="file73" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package network

import "syscall"

func UnlinkUdsFile(network, addr string) error <span class="cov8" title="1">{
        if network == "unix" </span><span class="cov8" title="1">{
                return syscall.Unlink(addr)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package network

import (
        "io"
        "sync"

        "github.com/bytedance/gopkg/lang/mcache"
)

const size4K = 1024 * 4

type node struct {
        data     []byte
        readOnly bool
}

var nodePool = sync.Pool{}

func init() <span class="cov8" title="1">{
        nodePool.New = func() interface{} </span><span class="cov8" title="1">{
                return &amp;node{}
        }</span>
}

type networkWriter struct {
        caches []*node
        w      io.Writer
}

func (w *networkWriter) release() <span class="cov8" title="1">{
        for _, n := range w.caches </span><span class="cov8" title="1">{
                if !n.readOnly </span><span class="cov8" title="1">{
                        mcache.Free(n.data)
                }</span>
                <span class="cov8" title="1">n.data = nil
                n.readOnly = false
                nodePool.Put(n)</span>
        }
        <span class="cov8" title="1">w.caches = w.caches[:0]</span>
}

func (w *networkWriter) Malloc(length int) (buf []byte, err error) <span class="cov8" title="1">{
        idx := len(w.caches)
        if idx &gt; 0 </span><span class="cov8" title="1">{
                idx -= 1
                inUse := len(w.caches[idx].data)
                if !w.caches[idx].readOnly &amp;&amp; cap(w.caches[idx].data)-inUse &gt;= length </span><span class="cov8" title="1">{
                        end := inUse + length
                        w.caches[idx].data = w.caches[idx].data[:end]
                        return w.caches[idx].data[inUse:end], nil
                }</span>
        }
        <span class="cov8" title="1">buf = mcache.Malloc(length)
        n := nodePool.Get().(*node)
        n.data = buf
        w.caches = append(w.caches, n)
        return</span>
}

func (w *networkWriter) WriteBinary(b []byte) (length int, err error) <span class="cov8" title="1">{
        length = len(b)
        if length &lt; size4K </span><span class="cov8" title="1">{
                buf, _ := w.Malloc(length)
                copy(buf, b)
                return
        }</span>
        <span class="cov8" title="1">node := nodePool.Get().(*node)
        node.readOnly = true
        node.data = b
        w.caches = append(w.caches, node)
        return</span>
}

func (w *networkWriter) Flush() (err error) <span class="cov8" title="1">{
        for _, c := range w.caches </span><span class="cov8" title="1">{
                _, err = w.w.Write(c.data)
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov8" title="1">w.release()
        return</span>
}

func NewWriter(w io.Writer) Writer <span class="cov8" title="1">{
        return &amp;networkWriter{
                w: w,
        }
}</span>

type ExtWriter interface {
        io.Writer
        Flush() error

        // Finalize will be called by framework before the writer is released.
        // Implementations must guarantee that Finalize is safe for multiple calls.
        Finalize() error
}
</pre>
		
		<pre class="file" id="file75" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015-present Aliaksandr Valialkin, VertaMedia, Kirill Danshin, Erik Dubbelboer, FastHTTP Authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This file may have been modified by CloudWeGo authors. All CloudWeGo
 * Modifications are Copyright 2022 CloudWeGo Authors.
 */

package protocol

import (
        "bytes"
        "io"

        "github.com/cloudwego/hertz/internal/bytesconv"
        "github.com/cloudwego/hertz/internal/nocopy"
)

const (
        argsNoValue  = true
        ArgsHasValue = false
)

var nilByteSlice = []byte{}

type argsScanner struct {
        b []byte
}

type Args struct {
        noCopy nocopy.NoCopy //lint:ignore U1000 until noCopy is used

        args []argsKV
        buf  []byte
}

// Set sets 'key=value' argument.
func (a *Args) Set(key, value string) <span class="cov8" title="1">{
        a.args = setArg(a.args, key, value, ArgsHasValue)
}</span>

// Reset clears query args.
func (a *Args) Reset() <span class="cov8" title="1">{
        a.args = a.args[:0]
}</span>

// CopyTo copies all args to dst.
func (a *Args) CopyTo(dst *Args) <span class="cov8" title="1">{
        dst.Reset()
        dst.args = copyArgs(dst.args, a.args)
}</span>

// Del deletes argument with the given key from query args.
func (a *Args) Del(key string) <span class="cov8" title="1">{
        a.args = delAllArgs(a.args, key)
}</span>

// DelBytes deletes argument with the given key from query args.
func (a *Args) DelBytes(key []byte) <span class="cov8" title="1">{
        a.args = delAllArgs(a.args, bytesconv.B2s(key))
}</span>

func (s *argsScanner) next(kv *argsKV) bool <span class="cov8" title="1">{
        if len(s.b) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">kv.noValue = ArgsHasValue

        isKey := true
        k := 0
        for i, c := range s.b </span><span class="cov8" title="1">{
                switch c </span>{
                case '=':<span class="cov8" title="1">
                        if isKey </span><span class="cov8" title="1">{
                                isKey = false
                                kv.key = decodeArgAppend(kv.key[:0], s.b[:i])
                                k = i + 1
                        }</span>
                case '&amp;':<span class="cov8" title="1">
                        if isKey </span><span class="cov0" title="0">{
                                kv.key = decodeArgAppend(kv.key[:0], s.b[:i])
                                kv.value = kv.value[:0]
                                kv.noValue = argsNoValue
                        }</span> else<span class="cov8" title="1"> {
                                kv.value = decodeArgAppend(kv.value[:0], s.b[k:i])
                        }</span>
                        <span class="cov8" title="1">s.b = s.b[i+1:]
                        return true</span>
                }
        }

        <span class="cov8" title="1">if isKey </span><span class="cov0" title="0">{
                kv.key = decodeArgAppend(kv.key[:0], s.b)
                kv.value = kv.value[:0]
                kv.noValue = argsNoValue
        }</span> else<span class="cov8" title="1"> {
                kv.value = decodeArgAppend(kv.value[:0], s.b[k:])
        }</span>
        <span class="cov8" title="1">s.b = s.b[len(s.b):]
        return true</span>
}

func decodeArgAppend(dst, src []byte) []byte <span class="cov8" title="1">{
        if bytes.IndexByte(src, '%') &lt; 0 &amp;&amp; bytes.IndexByte(src, '+') &lt; 0 </span><span class="cov8" title="1">{
                // fast path: src doesn't contain encoded chars
                return append(dst, src...)
        }</span>

        // slow path
        <span class="cov8" title="1">for i := 0; i &lt; len(src); i++ </span><span class="cov8" title="1">{
                c := src[i]
                if c == '%' </span><span class="cov8" title="1">{
                        if i+2 &gt;= len(src) </span><span class="cov0" title="0">{
                                return append(dst, src[i:]...)
                        }</span>
                        <span class="cov8" title="1">x2 := bytesconv.Hex2intTable[src[i+2]]
                        x1 := bytesconv.Hex2intTable[src[i+1]]
                        if x1 == 16 || x2 == 16 </span><span class="cov0" title="0">{
                                dst = append(dst, '%')
                        }</span> else<span class="cov8" title="1"> {
                                dst = append(dst, x1&lt;&lt;4|x2)
                                i += 2
                        }</span>
                } else<span class="cov0" title="0"> if c == '+' </span><span class="cov0" title="0">{
                        dst = append(dst, ' ')
                }</span> else<span class="cov0" title="0"> {
                        dst = append(dst, c)
                }</span>
        }
        <span class="cov8" title="1">return dst</span>
}

func allocArg(h []argsKV) ([]argsKV, *argsKV) <span class="cov8" title="1">{
        n := len(h)
        if cap(h) &gt; n </span><span class="cov8" title="1">{
                h = h[:n+1]
        }</span> else<span class="cov8" title="1"> {
                h = append(h, argsKV{})
        }</span>
        <span class="cov8" title="1">return h, &amp;h[n]</span>
}

func releaseArg(h []argsKV) []argsKV <span class="cov8" title="1">{
        return h[:len(h)-1]
}</span>

func updateArgBytes(h []argsKV, key, value []byte) []argsKV <span class="cov8" title="1">{
        n := len(h)
        for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                kv := &amp;h[i]
                if kv.noValue &amp;&amp; bytes.Equal(key, kv.key) </span><span class="cov8" title="1">{
                        kv.value = append(kv.value[:0], value...)
                        kv.noValue = ArgsHasValue
                        return h
                }</span>
        }
        <span class="cov8" title="1">return h</span>
}

func setArgBytes(h []argsKV, key, value []byte, noValue bool) []argsKV <span class="cov8" title="1">{
        n := len(h)
        for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                kv := &amp;h[i]
                if bytes.Equal(key, kv.key) </span><span class="cov8" title="1">{
                        if noValue </span><span class="cov8" title="1">{
                                kv.value = kv.value[:0]
                        }</span> else<span class="cov8" title="1"> {
                                kv.value = append(kv.value[:0], value...)
                        }</span>
                        <span class="cov8" title="1">kv.noValue = noValue
                        return h</span>
                }
        }
        <span class="cov8" title="1">return appendArgBytes(h, key, value, noValue)</span>
}

func setArg(h []argsKV, key, value string, noValue bool) []argsKV <span class="cov8" title="1">{
        n := len(h)
        for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                kv := &amp;h[i]
                if key == string(kv.key) </span><span class="cov0" title="0">{
                        if noValue </span><span class="cov0" title="0">{
                                kv.value = kv.value[:0]
                        }</span> else<span class="cov0" title="0"> {
                                kv.value = append(kv.value[:0], value...)
                        }</span>
                        <span class="cov0" title="0">kv.noValue = noValue
                        return h</span>
                }
        }
        <span class="cov8" title="1">return appendArg(h, key, value, noValue)</span>
}

func peekArgBytes(h []argsKV, k []byte) []byte <span class="cov8" title="1">{
        for i, n := 0, len(h); i &lt; n; i++ </span><span class="cov8" title="1">{
                kv := &amp;h[i]
                if bytes.Equal(kv.key, k) </span><span class="cov8" title="1">{
                        if kv.value != nil </span><span class="cov8" title="1">{
                                return kv.value
                        }</span>
                        <span class="cov0" title="0">return nilByteSlice</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func peekAllArgBytesToDst(dst [][]byte, h []argsKV, k []byte) [][]byte <span class="cov8" title="1">{
        for i, n := 0, len(h); i &lt; n; i++ </span><span class="cov8" title="1">{
                kv := &amp;h[i]
                if bytes.Equal(kv.key, k) </span><span class="cov8" title="1">{
                        dst = append(dst, kv.value)
                }</span>
        }
        <span class="cov8" title="1">return dst</span>
}

func delAllArgsBytes(args []argsKV, key []byte) []argsKV <span class="cov8" title="1">{
        return delAllArgs(args, bytesconv.B2s(key))
}</span>

func delAllArgs(args []argsKV, key string) []argsKV <span class="cov8" title="1">{
        for i, n := 0, len(args); i &lt; n; i++ </span><span class="cov8" title="1">{
                kv := &amp;args[i]
                if key == string(kv.key) </span><span class="cov8" title="1">{
                        tmp := *kv
                        copy(args[i:], args[i+1:])
                        n--
                        i--
                        args[n] = tmp
                        args = args[:n]
                }</span>
        }
        <span class="cov8" title="1">return args</span>
}

// Has returns true if the given key exists in Args.
func (a *Args) Has(key string) bool <span class="cov8" title="1">{
        return hasArg(a.args, key)
}</span>

func hasArg(h []argsKV, key string) bool <span class="cov8" title="1">{
        for i, n := 0, len(h); i &lt; n; i++ </span><span class="cov8" title="1">{
                kv := &amp;h[i]
                if key == string(kv.key) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// String returns string representation of query args.
func (a *Args) String() string <span class="cov8" title="1">{
        return string(a.QueryString())
}</span>

// decodeArgAppendNoPlus is almost identical to decodeArgAppend, but it doesn't
// substitute '+' with ' '.
//
// The function is copy-pasted from decodeArgAppend due to the performance
// reasons only.
func decodeArgAppendNoPlus(dst, src []byte) []byte <span class="cov8" title="1">{
        if bytes.IndexByte(src, '%') &lt; 0 </span><span class="cov8" title="1">{
                // fast path: src doesn't contain encoded chars
                return append(dst, src...)
        }</span>

        // slow path
        <span class="cov8" title="1">for i := 0; i &lt; len(src); i++ </span><span class="cov8" title="1">{
                c := src[i]
                if c == '%' </span><span class="cov8" title="1">{
                        if i+2 &gt;= len(src) </span><span class="cov0" title="0">{
                                return append(dst, src[i:]...)
                        }</span>
                        <span class="cov8" title="1">x2 := bytesconv.Hex2intTable[src[i+2]]
                        x1 := bytesconv.Hex2intTable[src[i+1]]
                        if x1 == 16 || x2 == 16 </span><span class="cov0" title="0">{
                                dst = append(dst, '%')
                        }</span> else<span class="cov8" title="1"> {
                                dst = append(dst, x1&lt;&lt;4|x2)
                                i += 2
                        }</span>
                } else<span class="cov8" title="1"> {
                        dst = append(dst, c)
                }</span>
        }
        <span class="cov8" title="1">return dst</span>
}

func peekArgStr(h []argsKV, k string) []byte <span class="cov8" title="1">{
        for i, n := 0, len(h); i &lt; n; i++ </span><span class="cov8" title="1">{
                kv := &amp;h[i]
                if string(kv.key) == k </span><span class="cov8" title="1">{
                        return kv.value
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func peekArgStrExists(h []argsKV, k string) (string, bool) <span class="cov8" title="1">{
        for i, n := 0, len(h); i &lt; n; i++ </span><span class="cov8" title="1">{
                kv := &amp;h[i]
                if string(kv.key) == k </span><span class="cov8" title="1">{
                        return string(kv.value), true
                }</span>
        }
        <span class="cov8" title="1">return "", false</span>
}

// QueryString returns query string for the args.
//
// The returned value is valid until the next call to Args methods.
func (a *Args) QueryString() []byte <span class="cov8" title="1">{
        a.buf = a.AppendBytes(a.buf[:0])
        return a.buf
}</span>

// ParseBytes parses the given b containing query args.
func (a *Args) ParseBytes(b []byte) <span class="cov8" title="1">{
        a.Reset()

        var s argsScanner
        s.b = b

        var kv *argsKV
        a.args, kv = allocArg(a.args)
        for s.next(kv) </span><span class="cov8" title="1">{
                if len(kv.key) &gt; 0 || len(kv.value) &gt; 0 </span><span class="cov8" title="1">{
                        a.args, kv = allocArg(a.args)
                }</span>
        }
        <span class="cov8" title="1">a.args = releaseArg(a.args)

        if len(a.args) == 0 </span><span class="cov8" title="1">{
                return
        }</span>
}

// Peek returns query arg value for the given key.
//
// Returned value is valid until the next Args call.
func (a *Args) Peek(key string) []byte <span class="cov8" title="1">{
        return peekArgStr(a.args, key)
}</span>

func (a *Args) PeekExists(key string) (string, bool) <span class="cov8" title="1">{
        return peekArgStrExists(a.args, key)
}</span>

// PeekAll returns all the arg values for the given key.
func (a *Args) PeekAll(key string) [][]byte <span class="cov8" title="1">{
        var values [][]byte
        a.VisitAll(func(k, v []byte) </span><span class="cov8" title="1">{
                if bytesconv.B2s(k) == key </span><span class="cov8" title="1">{
                        values = append(values, v)
                }</span>
        })
        <span class="cov8" title="1">return values</span>
}

func visitArgs(args []argsKV, f func(k, v []byte)) <span class="cov8" title="1">{
        for i, n := 0, len(args); i &lt; n; i++ </span><span class="cov8" title="1">{
                kv := &amp;args[i]
                f(kv.key, kv.value)
        }</span>
}

// Len returns the number of query args.
func (a *Args) Len() int <span class="cov8" title="1">{
        return len(a.args)
}</span>

// AppendBytes appends query string to dst and returns the extended dst.
func (a *Args) AppendBytes(dst []byte) []byte <span class="cov8" title="1">{
        for i, n := 0, len(a.args); i &lt; n; i++ </span><span class="cov8" title="1">{
                kv := &amp;a.args[i]
                dst = bytesconv.AppendQuotedArg(dst, kv.key)
                if !kv.noValue </span><span class="cov8" title="1">{
                        dst = append(dst, '=')
                        if len(kv.value) &gt; 0 </span><span class="cov8" title="1">{
                                dst = bytesconv.AppendQuotedArg(dst, kv.value)
                        }</span>
                }
                <span class="cov8" title="1">if i+1 &lt; n </span><span class="cov8" title="1">{
                        dst = append(dst, '&amp;')
                }</span>
        }
        <span class="cov8" title="1">return dst</span>
}

// VisitAll calls f for each existing arg.
//
// f must not retain references to key and value after returning.
// Make key and/or value copies if you need storing them after returning.
func (a *Args) VisitAll(f func(key, value []byte)) <span class="cov8" title="1">{
        visitArgs(a.args, f)
}</span>

// WriteTo writes query string to w.
//
// WriteTo implements io.WriterTo interface.
func (a *Args) WriteTo(w io.Writer) (int64, error) <span class="cov0" title="0">{
        n, err := w.Write(a.QueryString())
        return int64(n), err
}</span>

// Add adds 'key=value' argument.
//
// Multiple values for the same key may be added.
func (a *Args) Add(key, value string) <span class="cov8" title="1">{
        a.args = appendArg(a.args, key, value, ArgsHasValue)
}</span>
</pre>
		
		<pre class="file" id="file76" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015-present Aliaksandr Valialkin, VertaMedia, Kirill Danshin, Erik Dubbelboer, FastHTTP Authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This file may have been modified by CloudWeGo authors. All CloudWeGo
 * Modifications are Copyright 2022 CloudWeGo Authors.
 */

package protocol

import (
        "bytes"
        "sync"
        "time"

        "github.com/cloudwego/hertz/internal/bytesconv"
        "github.com/cloudwego/hertz/internal/bytestr"
        "github.com/cloudwego/hertz/internal/nocopy"
        "github.com/cloudwego/hertz/pkg/common/errors"
        "github.com/cloudwego/hertz/pkg/common/hlog"
        "github.com/cloudwego/hertz/pkg/common/utils"
)

const (
        // CookieSameSiteDisabled removes the SameSite flag
        CookieSameSiteDisabled CookieSameSite = iota
        // CookieSameSiteDefaultMode sets the SameSite flag
        CookieSameSiteDefaultMode
        // CookieSameSiteLaxMode sets the SameSite flag with the "Lax" parameter
        CookieSameSiteLaxMode
        // CookieSameSiteStrictMode sets the SameSite flag with the "Strict" parameter
        CookieSameSiteStrictMode
        // CookieSameSiteNoneMode sets the SameSite flag with the "None" parameter
        // see https://tools.ietf.org/html/draft-west-cookie-incrementalism-00
        // third-party cookies are phasing out, use Partitioned cookies instead
        // see https://developers.google.com/privacy-sandbox/3pcd
        CookieSameSiteNoneMode
)

var zeroTime time.Time

var (
        errNoCookies = errors.NewPublic("no cookies found")

        // CookieExpireDelete may be set on Cookie.Expire for expiring the given cookie.
        CookieExpireDelete = time.Date(2009, time.November, 10, 23, 0, 0, 0, time.UTC)

        // CookieExpireUnlimited indicates that the cookie doesn't expire.
        CookieExpireUnlimited = zeroTime
)

// CookieSameSite is an enum for the mode in which the SameSite flag should be set for the given cookie.
// See https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00 for details.
type CookieSameSite int

// Cookie represents HTTP response cookie.
//
// Do not copy Cookie objects. Create new object and use CopyTo instead.
//
// Cookie instance MUST NOT be used from concurrently running goroutines.
type Cookie struct {
        noCopy nocopy.NoCopy //lint:ignore U1000 until noCopy is used

        key    []byte
        value  []byte
        expire time.Time
        maxAge int
        domain []byte
        path   []byte

        httpOnly bool
        secure   bool
        // A partitioned third-party cookie is tied to the top-level site
        // where it's initially set and cannot be accessed from elsewhere.
        partitioned bool
        sameSite    CookieSameSite

        bufKV argsKV
        buf   []byte
}

var cookiePool = &amp;sync.Pool{
        New: func() interface{} <span class="cov8" title="1">{
                return &amp;Cookie{}
        }</span>,
}

// AcquireCookie returns an empty Cookie object from the pool.
//
// The returned object may be returned back to the pool with ReleaseCookie.
// This allows reducing GC load.
func AcquireCookie() *Cookie <span class="cov8" title="1">{
        return cookiePool.Get().(*Cookie)
}</span>

// ReleaseCookie returns the Cookie object acquired with AcquireCookie back
// to the pool.
//
// Do not access released Cookie object, otherwise data races may occur.
func ReleaseCookie(c *Cookie) <span class="cov8" title="1">{
        c.Reset()
        cookiePool.Put(c)
}</span>

// SetDomain sets cookie domain.
func (c *Cookie) SetDomain(domain string) <span class="cov8" title="1">{
        c.domain = append(c.domain[:0], domain...)
}</span>

// SetPath sets cookie path.
func (c *Cookie) SetPath(path string) <span class="cov8" title="1">{
        c.buf = append(c.buf[:0], path...)
        c.path = normalizePath(c.path, c.buf)
}</span>

// SetPathBytes sets cookie path.
func (c *Cookie) SetPathBytes(path []byte) <span class="cov0" title="0">{
        c.buf = append(c.buf[:0], path...)
        c.path = normalizePath(c.path, c.buf)
}</span>

// SetExpire sets cookie expiration time.
//
// Set expiration time to CookieExpireDelete for expiring (deleting)
// the cookie on the client.
//
// By default cookie lifetime is limited by browser session.
func (c *Cookie) SetExpire(expire time.Time) <span class="cov8" title="1">{
        c.expire = expire
}</span>

// SetKey sets cookie name.
func (c *Cookie) SetKey(key string) <span class="cov8" title="1">{
        c.key = append(c.key[:0], key...)
}</span>

// SetKeyBytes sets cookie name.
func (c *Cookie) SetKeyBytes(key []byte) <span class="cov8" title="1">{
        c.key = append(c.key[:0], key...)
}</span>

// SetValue sets cookie value.
func (c *Cookie) SetValue(value string) <span class="cov8" title="1">{
        warnIfInvalid(bytesconv.S2b(value))
        c.value = append(c.value[:0], value...)
}</span>

// SetValueBytes sets cookie value.
func (c *Cookie) SetValueBytes(value []byte) <span class="cov8" title="1">{
        warnIfInvalid(value)
        c.value = append(c.value[:0], value...)
}</span>

// AppendBytes appends cookie representation to dst and returns
// the extended dst.
func (c *Cookie) AppendBytes(dst []byte) []byte <span class="cov8" title="1">{
        if len(c.key) &gt; 0 </span><span class="cov8" title="1">{
                dst = append(dst, c.key...)
                dst = append(dst, '=')
        }</span>
        <span class="cov8" title="1">dst = append(dst, c.value...)

        if c.maxAge &gt; 0 </span><span class="cov8" title="1">{
                dst = append(dst, ';', ' ')
                dst = append(dst, bytestr.StrCookieMaxAge...)
                dst = append(dst, '=')
                dst = bytesconv.AppendUint(dst, c.maxAge)
        }</span> else<span class="cov8" title="1"> if !c.expire.IsZero() </span><span class="cov8" title="1">{
                c.bufKV.value = bytesconv.AppendHTTPDate(c.bufKV.value[:0], c.expire)
                dst = appendCookiePart(dst, bytestr.StrCookieExpires, c.bufKV.value)
        }</span>
        <span class="cov8" title="1">if len(c.domain) &gt; 0 </span><span class="cov8" title="1">{
                dst = appendCookiePart(dst, bytestr.StrCookieDomain, c.domain)
        }</span>
        <span class="cov8" title="1">if len(c.path) &gt; 0 </span><span class="cov8" title="1">{
                dst = appendCookiePart(dst, bytestr.StrCookiePath, c.path)
        }</span>
        <span class="cov8" title="1">if c.httpOnly </span><span class="cov8" title="1">{
                dst = append(dst, ';', ' ')
                dst = append(dst, bytestr.StrCookieHTTPOnly...)
        }</span>
        <span class="cov8" title="1">if c.secure </span><span class="cov8" title="1">{
                dst = append(dst, ';', ' ')
                dst = append(dst, bytestr.StrCookieSecure...)
        }</span>
        <span class="cov8" title="1">switch c.sameSite </span>{
        case CookieSameSiteDefaultMode:<span class="cov8" title="1">
                dst = append(dst, ';', ' ')
                dst = append(dst, bytestr.StrCookieSameSite...)</span>
        case CookieSameSiteLaxMode:<span class="cov8" title="1">
                dst = appendCookiePart(dst, bytestr.StrCookieSameSite, bytestr.StrCookieSameSiteLax)</span>
        case CookieSameSiteStrictMode:<span class="cov8" title="1">
                dst = appendCookiePart(dst, bytestr.StrCookieSameSite, bytestr.StrCookieSameSiteStrict)</span>
        case CookieSameSiteNoneMode:<span class="cov8" title="1">
                dst = appendCookiePart(dst, bytestr.StrCookieSameSite, bytestr.StrCookieSameSiteNone)</span>
        }

        <span class="cov8" title="1">if c.partitioned </span><span class="cov8" title="1">{
                dst = append(dst, ';', ' ')
                dst = append(dst, bytestr.StrCookiePartitioned...)
        }</span>

        <span class="cov8" title="1">return dst</span>
}

func appendCookiePart(dst, key, value []byte) []byte <span class="cov8" title="1">{
        dst = append(dst, ';', ' ')
        dst = append(dst, key...)
        dst = append(dst, '=')
        return append(dst, value...)
}</span>

func appendRequestCookieBytes(dst []byte, cookies []argsKV) []byte <span class="cov8" title="1">{
        for i, n := 0, len(cookies); i &lt; n; i++ </span><span class="cov8" title="1">{
                kv := &amp;cookies[i]
                if len(kv.key) &gt; 0 </span><span class="cov8" title="1">{
                        dst = append(dst, kv.key...)
                        dst = append(dst, '=')
                }</span>
                <span class="cov8" title="1">dst = append(dst, kv.value...)
                if i+1 &lt; n </span><span class="cov8" title="1">{
                        dst = append(dst, ';', ' ')
                }</span>
        }
        <span class="cov8" title="1">return dst</span>
}

// For Response we can not use the above function as response cookies
// already contain the key= in the value.
func appendResponseCookieBytes(dst []byte, cookies []argsKV) []byte <span class="cov8" title="1">{
        for i, n := 0, len(cookies); i &lt; n; i++ </span><span class="cov8" title="1">{
                kv := &amp;cookies[i]
                dst = append(dst, kv.value...)
                if i+1 &lt; n </span><span class="cov0" title="0">{
                        dst = append(dst, ';', ' ')
                }</span>
        }
        <span class="cov8" title="1">return dst</span>
}

type cookieScanner struct {
        b []byte
}

func parseRequestCookies(cookies []argsKV, src []byte) []argsKV <span class="cov8" title="1">{
        var s cookieScanner
        s.b = src
        var kv *argsKV
        cookies, kv = allocArg(cookies)
        for s.next(kv) </span><span class="cov8" title="1">{
                if len(kv.key) &gt; 0 || len(kv.value) &gt; 0 </span><span class="cov8" title="1">{
                        cookies, kv = allocArg(cookies)
                }</span>
        }
        <span class="cov8" title="1">return releaseArg(cookies)</span>
}

func (s *cookieScanner) next(kv *argsKV) bool <span class="cov8" title="1">{
        b := s.b
        if len(b) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">isKey := true
        k := 0
        for i, c := range b </span><span class="cov8" title="1">{
                switch c </span>{
                case '=':<span class="cov8" title="1">
                        if isKey </span><span class="cov8" title="1">{
                                isKey = false
                                kv.key = decodeCookieArg(kv.key, b[:i], false)
                                k = i + 1
                        }</span>
                case ';':<span class="cov8" title="1">
                        if isKey </span><span class="cov8" title="1">{
                                kv.key = kv.key[:0]
                        }</span>
                        <span class="cov8" title="1">kv.value = decodeCookieArg(kv.value, b[k:i], true)
                        s.b = b[i+1:]
                        return true</span>
                }
        }

        <span class="cov8" title="1">if isKey </span><span class="cov8" title="1">{
                kv.key = kv.key[:0]
        }</span>
        <span class="cov8" title="1">kv.value = decodeCookieArg(kv.value, b[k:], true)
        s.b = b[len(b):]
        return true</span>
}

// Key returns cookie name.
//
// The returned value is valid until the next Cookie modification method call.
func (c *Cookie) Key() []byte <span class="cov8" title="1">{
        return c.key
}</span>

// Cookie returns cookie representation.
//
// The returned value is valid until the next call to Cookie methods.
func (c *Cookie) Cookie() []byte <span class="cov8" title="1">{
        c.buf = c.AppendBytes(c.buf[:0])
        return c.buf
}</span>

// Reset clears the cookie.
func (c *Cookie) Reset() <span class="cov8" title="1">{
        c.key = c.key[:0]
        c.value = c.value[:0]
        c.expire = zeroTime
        c.maxAge = 0
        c.domain = c.domain[:0]
        c.path = c.path[:0]
        c.httpOnly = false
        c.secure = false
        c.sameSite = CookieSameSiteDisabled
        c.partitioned = false
}</span>

// Value returns cookie value.
//
// The returned value is valid until the next Cookie modification method call.
func (c *Cookie) Value() []byte <span class="cov8" title="1">{
        return c.value
}</span>

// Parse parses Set-Cookie header.
func (c *Cookie) Parse(src string) error <span class="cov8" title="1">{
        c.buf = append(c.buf[:0], src...)
        return c.ParseBytes(c.buf)
}</span>

// ParseBytes parses Set-Cookie header.
func (c *Cookie) ParseBytes(src []byte) error <span class="cov8" title="1">{
        c.Reset()

        var s cookieScanner
        s.b = src

        kv := &amp;c.bufKV
        if !s.next(kv) </span><span class="cov0" title="0">{
                return errNoCookies
        }</span>

        <span class="cov8" title="1">c.key = append(c.key[:0], kv.key...)
        c.value = append(c.value[:0], kv.value...)

        for s.next(kv) </span><span class="cov8" title="1">{
                if len(kv.key) != 0 </span><span class="cov8" title="1">{
                        // Case-insensitive switch on first char
                        switch kv.key[0] | 0x20 </span>{
                        case 'm':<span class="cov8" title="1">
                                if utils.CaseInsensitiveCompare(bytestr.StrCookieMaxAge, kv.key) </span><span class="cov8" title="1">{
                                        maxAge, err := bytesconv.ParseUint(kv.value)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov8" title="1">c.maxAge = maxAge</span>
                                }

                        case 'e':<span class="cov8" title="1"> // "expires"
                                if utils.CaseInsensitiveCompare(bytestr.StrCookieExpires, kv.key) </span><span class="cov8" title="1">{
                                        v := bytesconv.B2s(kv.value)
                                        // Try the same two formats as net/http
                                        // See: https://github.com/golang/go/blob/00379be17e63a5b75b3237819392d2dc3b313a27/src/net/http/cookie.go#L133-L135
                                        exptime, err := time.ParseInLocation(time.RFC1123, v, time.UTC)
                                        if err != nil </span><span class="cov0" title="0">{
                                                exptime, err = time.Parse("Mon, 02-Jan-2006 15:04:05 MST", v)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return err
                                                }</span>
                                        }
                                        <span class="cov8" title="1">c.expire = exptime</span>
                                }

                        case 'd':<span class="cov8" title="1"> // "domain"
                                if utils.CaseInsensitiveCompare(bytestr.StrCookieDomain, kv.key) </span><span class="cov8" title="1">{
                                        c.domain = append(c.domain[:0], kv.value...)
                                }</span>

                        case 'p':<span class="cov8" title="1"> // "path"
                                if utils.CaseInsensitiveCompare(bytestr.StrCookiePath, kv.key) </span><span class="cov8" title="1">{
                                        c.path = append(c.path[:0], kv.value...)
                                }</span>

                        case 's':<span class="cov8" title="1"> // "samesite"
                                if utils.CaseInsensitiveCompare(bytestr.StrCookieSameSite, kv.key) </span><span class="cov8" title="1">{
                                        // Case-insensitive switch on first char
                                        switch kv.value[0] | 0x20 </span>{
                                        case 'l':<span class="cov8" title="1"> // "lax"
                                                if utils.CaseInsensitiveCompare(bytestr.StrCookieSameSiteLax, kv.value) </span><span class="cov8" title="1">{
                                                        c.sameSite = CookieSameSiteLaxMode
                                                }</span>
                                        case 's':<span class="cov8" title="1"> // "strict"
                                                if utils.CaseInsensitiveCompare(bytestr.StrCookieSameSiteStrict, kv.value) </span><span class="cov8" title="1">{
                                                        c.sameSite = CookieSameSiteStrictMode
                                                }</span>
                                        case 'n':<span class="cov8" title="1"> // "none"
                                                if utils.CaseInsensitiveCompare(bytestr.StrCookieSameSiteNone, kv.value) </span><span class="cov8" title="1">{
                                                        c.sameSite = CookieSameSiteNoneMode
                                                }</span>
                                        }
                                }
                        }
                } else<span class="cov8" title="1"> if len(kv.value) != 0 </span><span class="cov8" title="1">{
                        // Case-insensitive switch on first char
                        switch kv.value[0] | 0x20 </span>{
                        case 'h':<span class="cov8" title="1"> // "httponly"
                                if utils.CaseInsensitiveCompare(bytestr.StrCookieHTTPOnly, kv.value) </span><span class="cov8" title="1">{
                                        c.httpOnly = true
                                }</span>

                        case 's':<span class="cov8" title="1"> // "secure"
                                if utils.CaseInsensitiveCompare(bytestr.StrCookieSecure, kv.value) </span><span class="cov8" title="1">{
                                        c.secure = true
                                }</span> else<span class="cov8" title="1"> if utils.CaseInsensitiveCompare(bytestr.StrCookieSameSite, kv.value) </span><span class="cov8" title="1">{
                                        c.sameSite = CookieSameSiteDefaultMode
                                }</span>
                        case 'p':<span class="cov8" title="1"> // "partitioned"
                                if utils.CaseInsensitiveCompare(bytestr.StrCookiePartitioned, kv.value) </span><span class="cov8" title="1">{
                                        c.partitioned = true
                                }</span>
                        }
                } // else empty or no match
        }

        <span class="cov8" title="1">return nil</span>
}

// MaxAge returns the seconds until the cookie is meant to expire or 0
// if no max age.
func (c *Cookie) MaxAge() int <span class="cov8" title="1">{
        return c.maxAge
}</span>

// SetMaxAge sets cookie expiration time based on seconds. This takes precedence
// over any absolute expiry set on the cookie
//
// Set max age to 0 to unset
func (c *Cookie) SetMaxAge(seconds int) <span class="cov8" title="1">{
        c.maxAge = seconds
}</span>

// Expire returns cookie expiration time.
//
// CookieExpireUnlimited is returned if cookie doesn't expire
func (c *Cookie) Expire() time.Time <span class="cov8" title="1">{
        expire := c.expire
        if expire.IsZero() </span><span class="cov0" title="0">{
                expire = CookieExpireUnlimited
        }</span>
        <span class="cov8" title="1">return expire</span>
}

// Domain returns cookie domain.
//
// The returned domain is valid until the next Cookie modification method call.
func (c *Cookie) Domain() []byte <span class="cov0" title="0">{
        return c.domain
}</span>

// Path returns cookie path.
func (c *Cookie) Path() []byte <span class="cov0" title="0">{
        return c.path
}</span>

// Secure returns true if the cookie is secure.
func (c *Cookie) Secure() bool <span class="cov8" title="1">{
        return c.secure
}</span>

// SetSecure sets cookie's secure flag to the given value.
func (c *Cookie) SetSecure(secure bool) <span class="cov8" title="1">{
        c.secure = secure
}</span>

// SameSite returns the SameSite mode.
func (c *Cookie) SameSite() CookieSameSite <span class="cov8" title="1">{
        return c.sameSite
}</span>

// Partitioned returns if cookie is partitioned.
func (c *Cookie) Partitioned() bool <span class="cov8" title="1">{
        return c.partitioned
}</span>

// SetSameSite sets the cookie's SameSite flag to the given value.
// set value CookieSameSiteNoneMode will set Secure to true also to avoid browser rejection
func (c *Cookie) SetSameSite(mode CookieSameSite) <span class="cov8" title="1">{
        c.sameSite = mode
        if mode == CookieSameSiteNoneMode </span><span class="cov8" title="1">{
                c.SetSecure(true)
        }</span>
}

// HTTPOnly returns true if the cookie is http only.
func (c *Cookie) HTTPOnly() bool <span class="cov8" title="1">{
        return c.httpOnly
}</span>

// SetHTTPOnly sets cookie's httpOnly flag to the given value.
func (c *Cookie) SetHTTPOnly(httpOnly bool) <span class="cov0" title="0">{
        c.httpOnly = httpOnly
}</span>

// SetPartitioned sets cookie as partitioned. Setting Partitioned to true will also set Secure.
func (c *Cookie) SetPartitioned(partitioned bool) <span class="cov8" title="1">{
        c.partitioned = partitioned
        if partitioned </span><span class="cov8" title="1">{
                c.SetSecure(true)
        }</span>
}

// String returns cookie representation.
func (c *Cookie) String() string <span class="cov8" title="1">{
        return string(c.Cookie())
}</span>

func decodeCookieArg(dst, src []byte, skipQuotes bool) []byte <span class="cov8" title="1">{
        for len(src) &gt; 0 &amp;&amp; src[0] == ' ' </span><span class="cov8" title="1">{
                src = src[1:]
        }</span>
        <span class="cov8" title="1">for len(src) &gt; 0 &amp;&amp; src[len(src)-1] == ' ' </span><span class="cov8" title="1">{
                src = src[:len(src)-1]
        }</span>
        <span class="cov8" title="1">if skipQuotes </span><span class="cov8" title="1">{
                if len(src) &gt; 1 &amp;&amp; src[0] == '"' &amp;&amp; src[len(src)-1] == '"' </span><span class="cov8" title="1">{
                        src = src[1 : len(src)-1]
                }</span>
        }
        <span class="cov8" title="1">return append(dst[:0], src...)</span>
}

func getCookieKey(dst, src []byte) []byte <span class="cov8" title="1">{
        n := bytes.IndexByte(src, '=')
        if n &gt;= 0 </span><span class="cov0" title="0">{
                src = src[:n]
        }</span>
        <span class="cov8" title="1">return decodeCookieArg(dst, src, false)</span>
}

func warnIfInvalid(value []byte) bool <span class="cov8" title="1">{
        for i := range value </span><span class="cov8" title="1">{
                if bytesconv.ValidCookieValueTable[value[i]] == 0 </span><span class="cov8" title="1">{
                        hlog.SystemLogger().Warnf("Invalid byte %q in Cookie.Value, "+
                                "it may cause compatibility problems with user agents", value[i])
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015-present Aliaksandr Valialkin, VertaMedia, Kirill Danshin, Erik Dubbelboer, FastHTTP Authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This file may have been modified by CloudWeGo authors. All CloudWeGo
 * Modifications are Copyright 2022 CloudWeGo Authors.
 */

package protocol

import (
        "bytes"
        "net/http"
        "sync"
        "sync/atomic"
        "time"

        "github.com/cloudwego/hertz/internal/bytesconv"
        "github.com/cloudwego/hertz/internal/bytestr"
        "github.com/cloudwego/hertz/internal/nocopy"
        errs "github.com/cloudwego/hertz/pkg/common/errors"
        "github.com/cloudwego/hertz/pkg/common/hlog"
        "github.com/cloudwego/hertz/pkg/common/utils"
        "github.com/cloudwego/hertz/pkg/protocol/consts"
)

var (
        ServerDate     atomic.Value
        ServerDateOnce sync.Once // serverDateOnce.Do(updateServerDate)
)

type RequestHeader struct {
        noCopy nocopy.NoCopy //lint:ignore U1000 until noCopy is used

        disableNormalizing   bool
        connectionClose      bool
        noDefaultContentType bool

        // These two fields have been moved close to other bool fields
        // for reducing RequestHeader object size.
        cookiesCollected bool

        contentLength      int
        contentLengthBytes []byte

        method      []byte
        requestURI  []byte
        host        []byte
        contentType []byte

        userAgent []byte
        mulHeader [][]byte
        protocol  string

        h       []argsKV
        bufKV   argsKV
        trailer *Trailer

        cookies []argsKV

        // stores an immutable copy of headers as they were received from the
        // wire.
        rawHeaders []byte
}

func (h *RequestHeader) SetRawHeaders(r []byte) <span class="cov8" title="1">{
        h.rawHeaders = r
}</span>

// ResponseHeader represents HTTP response header.
//
// It is forbidden copying ResponseHeader instances.
// Create new instances instead and use CopyTo.
//
// ResponseHeader instance MUST NOT be used from concurrently running
// goroutines.
type ResponseHeader struct {
        noCopy nocopy.NoCopy //lint:ignore U1000 until noCopy is used

        disableNormalizing   bool
        connectionClose      bool
        noDefaultContentType bool
        noDefaultDate        bool

        statusCode         int
        contentLength      int
        contentLengthBytes []byte
        contentEncoding    []byte

        contentType []byte
        server      []byte
        mulHeader   [][]byte
        protocol    string

        h       []argsKV
        bufKV   argsKV
        trailer *Trailer

        cookies []argsKV

        headerLength int
}

// SetHeaderLength sets the size of header for tracer.
func (h *ResponseHeader) SetHeaderLength(length int) <span class="cov8" title="1">{
        h.headerLength = length
}</span>

// GetHeaderLength gets the size of header for tracer.
func (h *ResponseHeader) GetHeaderLength() int <span class="cov8" title="1">{
        return h.headerLength
}</span>

// SetContentRange sets 'Content-Range: bytes startPos-endPos/contentLength'
// header.
func (h *ResponseHeader) SetContentRange(startPos, endPos, contentLength int) <span class="cov8" title="1">{
        b := h.bufKV.value[:0]
        b = append(b, bytestr.StrBytes...)
        b = append(b, ' ')
        b = bytesconv.AppendUint(b, startPos)
        b = append(b, '-')
        b = bytesconv.AppendUint(b, endPos)
        b = append(b, '/')
        b = bytesconv.AppendUint(b, contentLength)
        h.bufKV.value = b

        h.SetCanonical(bytestr.StrContentRange, h.bufKV.value)
}</span>

func (h *ResponseHeader) NoDefaultContentType() bool <span class="cov0" title="0">{
        return h.noDefaultContentType
}</span>

// SetConnectionClose sets 'Connection: close' header.
func (h *ResponseHeader) SetConnectionClose(close bool) <span class="cov8" title="1">{
        h.connectionClose = close
}</span>

func (h *ResponseHeader) PeekArgBytes(key []byte) []byte <span class="cov0" title="0">{
        return peekArgBytes(h.h, key)
}</span>

// Deprecated: Use ResponseHeader.SetProtocol(consts.HTTP11) instead
//
//        Now SetNoHTTP11(true) equal to SetProtocol(consts.HTTP10)
//                SetNoHTTP11(false) equal to SetProtocol(consts.HTTP11)
func (h *ResponseHeader) SetNoHTTP11(b bool) <span class="cov0" title="0">{
        if b </span><span class="cov0" title="0">{
                h.protocol = consts.HTTP10
                return
        }</span>

        <span class="cov0" title="0">h.protocol = consts.HTTP11</span>
}

// Cookie fills cookie for the given cookie.Key.
//
// Returns false if cookie with the given cookie.Key is missing.
func (h *ResponseHeader) Cookie(cookie *Cookie) bool <span class="cov8" title="1">{
        v := peekArgBytes(h.cookies, cookie.Key())
        if v == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">cookie.ParseBytes(v) //nolint:errcheck
        return true</span>
}

// FullCookie returns complete cookie bytes
func (h *ResponseHeader) FullCookie() []byte <span class="cov8" title="1">{
        return h.Peek(consts.HeaderSetCookie)
}</span>

// IsHTTP11 returns true if the response is HTTP/1.1.
func (h *ResponseHeader) IsHTTP11() bool <span class="cov8" title="1">{
        return h.protocol == consts.HTTP11
}</span>

// SetContentType sets Content-Type header value.
func (h *ResponseHeader) SetContentType(contentType string) <span class="cov8" title="1">{
        h.contentType = append(h.contentType[:0], contentType...)
}</span>

func (h *ResponseHeader) GetHeaders() []argsKV <span class="cov0" title="0">{
        return h.h
}</span>

// Reset clears response header.
func (h *ResponseHeader) Reset() <span class="cov8" title="1">{
        h.disableNormalizing = false
        h.Trailer().disableNormalizing = false
        h.noDefaultContentType = false
        h.noDefaultDate = false
        h.ResetSkipNormalize()
}</span>

// CopyTo copies all the headers to dst.
func (h *ResponseHeader) CopyTo(dst *ResponseHeader) <span class="cov8" title="1">{
        dst.Reset()

        dst.disableNormalizing = h.disableNormalizing
        dst.connectionClose = h.connectionClose
        dst.noDefaultContentType = h.noDefaultContentType
        dst.noDefaultDate = h.noDefaultDate

        dst.statusCode = h.statusCode
        dst.contentLength = h.contentLength
        dst.contentLengthBytes = append(dst.contentLengthBytes[:0], h.contentLengthBytes...)
        dst.contentEncoding = append(dst.contentEncoding[:0], h.contentEncoding...)
        dst.contentType = append(dst.contentType[:0], h.contentType...)
        dst.server = append(dst.server[:0], h.server...)
        dst.h = copyArgs(dst.h, h.h)
        dst.cookies = copyArgs(dst.cookies, h.cookies)
        dst.protocol = h.protocol
        dst.headerLength = h.headerLength
        h.Trailer().CopyTo(dst.Trailer())
}</span>

// Multiple headers with the same key may be added with this function.
// Use Set for setting a single header for the given key.
//
// the Content-Type, Content-Length, Connection, Cookie,
// Transfer-Encoding, Host and User-Agent headers can only be set once
// and will overwrite the previous value.
func (h *RequestHeader) Add(key, value string) <span class="cov8" title="1">{
        if h.setSpecialHeader(bytesconv.S2b(key), bytesconv.S2b(value)) </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">k := getHeaderKeyBytes(&amp;h.bufKV, key, h.disableNormalizing)
        h.h = appendArg(h.h, bytesconv.B2s(k), value, ArgsHasValue)</span>
}

// VisitAll calls f for each header.
//
// f must not retain references to key and/or value after returning.
// Copy key and/or value contents before returning if you need retaining them.
func (h *ResponseHeader) VisitAll(f func(key, value []byte)) <span class="cov8" title="1">{
        if len(h.contentLengthBytes) &gt; 0 </span><span class="cov0" title="0">{
                f(bytestr.StrContentLength, h.contentLengthBytes)
        }</span>
        <span class="cov8" title="1">contentType := h.ContentType()
        if len(contentType) &gt; 0 </span><span class="cov8" title="1">{
                f(bytestr.StrContentType, contentType)
        }</span>
        <span class="cov8" title="1">contentEncoding := h.ContentEncoding()
        if len(contentEncoding) &gt; 0 </span><span class="cov8" title="1">{
                f(bytestr.StrContentEncoding, contentEncoding)
        }</span>
        <span class="cov8" title="1">server := h.Server()
        if len(server) &gt; 0 </span><span class="cov0" title="0">{
                f(bytestr.StrServer, server)
        }</span>
        <span class="cov8" title="1">if len(h.cookies) &gt; 0 </span><span class="cov0" title="0">{
                visitArgs(h.cookies, func(k, v []byte) </span><span class="cov0" title="0">{
                        f(bytestr.StrSetCookie, v)
                }</span>)
        }
        <span class="cov8" title="1">if !h.Trailer().Empty() </span><span class="cov0" title="0">{
                f(bytestr.StrTrailer, h.Trailer().GetBytes())
        }</span>
        <span class="cov8" title="1">visitArgs(h.h, f)
        if h.ConnectionClose() </span><span class="cov0" title="0">{
                f(bytestr.StrConnection, bytestr.StrClose)
        }</span>
}

// IsHTTP11 returns true if the request is HTTP/1.1.
func (h *RequestHeader) IsHTTP11() bool <span class="cov8" title="1">{
        return h.protocol == consts.HTTP11
}</span>

func (h *RequestHeader) SetProtocol(p string) <span class="cov8" title="1">{
        h.protocol = p
}</span>

func (h *RequestHeader) GetProtocol() string <span class="cov8" title="1">{
        return h.protocol
}</span>

// Deprecated: Use RequestHeader.SetProtocol(consts.HTTP11) instead
//
//        Now SetNoHTTP11(true) equal to SetProtocol(consts.HTTP10)
//                SetNoHTTP11(false) equal to SetProtocol(consts.HTTP11)
func (h *RequestHeader) SetNoHTTP11(b bool) <span class="cov0" title="0">{
        if b </span><span class="cov0" title="0">{
                h.protocol = consts.HTTP10
                return
        }</span>

        <span class="cov0" title="0">h.protocol = consts.HTTP11</span>
}

func (h *RequestHeader) InitBufValue(size int) <span class="cov8" title="1">{
        if size &gt; cap(h.bufKV.value) </span><span class="cov8" title="1">{
                h.bufKV.value = make([]byte, 0, size)
        }</span>
}

func (h *RequestHeader) GetBufValue() []byte <span class="cov8" title="1">{
        return h.bufKV.value
}</span>

// HasAcceptEncodingBytes returns true if the header contains
// the given Accept-Encoding value.
func (h *RequestHeader) HasAcceptEncodingBytes(acceptEncoding []byte) bool <span class="cov8" title="1">{
        ae := h.peek(bytestr.StrAcceptEncoding)
        n := bytes.Index(ae, acceptEncoding)
        if n &lt; 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">b := ae[n+len(acceptEncoding):]
        if len(b) &gt; 0 &amp;&amp; b[0] != ',' </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if n == 0 </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov0" title="0">return ae[n-1] == ' '</span>
}

func (h *RequestHeader) PeekIfModifiedSinceBytes() []byte <span class="cov0" title="0">{
        return h.peek(bytestr.StrIfModifiedSince)
}</span>

// RequestURI returns RequestURI from the first HTTP request line.
func (h *RequestHeader) RequestURI() []byte <span class="cov8" title="1">{
        requestURI := h.requestURI
        if len(requestURI) == 0 </span><span class="cov8" title="1">{
                requestURI = bytestr.StrSlash
        }</span>
        <span class="cov8" title="1">return requestURI</span>
}

func (h *RequestHeader) PeekArgBytes(key []byte) []byte <span class="cov0" title="0">{
        return peekArgBytes(h.h, key)
}</span>

// RawHeaders returns raw header key/value bytes.
//
// Depending on server configuration, header keys may be normalized to
// capital-case in place.
//
// This copy is set aside during parsing, so empty slice is returned for all
// cases where parsing did not happen. Similarly, request line is not stored
// during parsing and can not be returned.
//
// The slice is not safe to use after the handler returns.
func (h *RequestHeader) RawHeaders() []byte <span class="cov0" title="0">{
        return h.rawHeaders
}</span>

// AppendBytes appends request header representation to dst and returns
// the extended dst.
func (h *RequestHeader) AppendBytes(dst []byte) []byte <span class="cov8" title="1">{
        dst = append(dst, h.Method()...)
        dst = append(dst, ' ')
        dst = append(dst, h.RequestURI()...)
        dst = append(dst, ' ')
        dst = append(dst, bytestr.StrHTTP11...)
        dst = append(dst, bytestr.StrCRLF...)

        userAgent := h.UserAgent()
        if len(userAgent) &gt; 0 </span><span class="cov0" title="0">{
                dst = appendHeaderLine(dst, bytestr.StrUserAgent, userAgent)
        }</span>

        <span class="cov8" title="1">host := h.Host()
        if len(host) &gt; 0 </span><span class="cov8" title="1">{
                dst = appendHeaderLine(dst, bytestr.StrHost, host)
        }</span>

        <span class="cov8" title="1">contentType := h.ContentType()
        if len(contentType) == 0 &amp;&amp; !h.IgnoreBody() &amp;&amp; !h.noDefaultContentType </span><span class="cov8" title="1">{
                contentType = bytestr.StrPostArgsContentType
        }</span>
        <span class="cov8" title="1">if len(contentType) &gt; 0 </span><span class="cov8" title="1">{
                dst = appendHeaderLine(dst, bytestr.StrContentType, contentType)
        }</span>
        <span class="cov8" title="1">if len(h.contentLengthBytes) &gt; 0 </span><span class="cov8" title="1">{
                dst = appendHeaderLine(dst, bytestr.StrContentLength, h.contentLengthBytes)
        }</span>

        <span class="cov8" title="1">for i, n := 0, len(h.h); i &lt; n; i++ </span><span class="cov0" title="0">{
                kv := &amp;h.h[i]
                dst = appendHeaderLine(dst, kv.key, kv.value)
        }</span>

        <span class="cov8" title="1">if !h.Trailer().Empty() </span><span class="cov0" title="0">{
                dst = appendHeaderLine(dst, bytestr.StrTrailer, h.Trailer().GetBytes())
        }</span>

        // there is no need in h.collectCookies() here, since if cookies aren't collected yet,
        // they all are located in h.h.
        <span class="cov8" title="1">n := len(h.cookies)
        if n &gt; 0 </span><span class="cov0" title="0">{
                dst = append(dst, bytestr.StrCookie...)
                dst = append(dst, bytestr.StrColonSpace...)
                dst = appendRequestCookieBytes(dst, h.cookies)
                dst = append(dst, bytestr.StrCRLF...)
        }</span>

        <span class="cov8" title="1">if h.ConnectionClose() </span><span class="cov0" title="0">{
                dst = appendHeaderLine(dst, bytestr.StrConnection, bytestr.StrClose)
        }</span>

        <span class="cov8" title="1">return append(dst, bytestr.StrCRLF...)</span>
}

// Header returns request header representation.
//
// The returned representation is valid until the next call to RequestHeader methods.
func (h *RequestHeader) Header() []byte <span class="cov8" title="1">{
        h.bufKV.value = h.AppendBytes(h.bufKV.value[:0])
        return h.bufKV.value
}</span>

// IsPut returns true if request method is PUT.
func (h *RequestHeader) IsPut() bool <span class="cov0" title="0">{
        return bytes.Equal(h.Method(), bytestr.StrPut)
}</span>

// IsHead returns true if request method is HEAD.
func (h *RequestHeader) IsHead() bool <span class="cov8" title="1">{
        return bytes.Equal(h.Method(), bytestr.StrHead)
}</span>

// IsPost returns true if request method is POST.
func (h *RequestHeader) IsPost() bool <span class="cov0" title="0">{
        return bytes.Equal(h.Method(), bytestr.StrPost)
}</span>

// IsDelete returns true if request method is DELETE.
func (h *RequestHeader) IsDelete() bool <span class="cov0" title="0">{
        return bytes.Equal(h.Method(), bytestr.StrDelete)
}</span>

// IsConnect returns true if request method is CONNECT.
func (h *RequestHeader) IsConnect() bool <span class="cov0" title="0">{
        return bytes.Equal(h.Method(), bytestr.StrConnect)
}</span>

func (h *RequestHeader) IgnoreBody() bool <span class="cov8" title="1">{
        return h.IsGet() || h.IsHead()
}</span>

// ContentLength returns Content-Length header value.
//
// It may be negative:
// -1 means Transfer-Encoding: chunked.
func (h *RequestHeader) ContentLength() int <span class="cov8" title="1">{
        return h.contentLength
}</span>

// SetHost sets Host header value.
func (h *RequestHeader) SetHost(host string) <span class="cov8" title="1">{
        h.host = append(h.host[:0], host...)
}</span>

// SetStatusCode sets response status code.
func (h *ResponseHeader) SetStatusCode(statusCode int) <span class="cov8" title="1">{
        checkWriteHeaderCode(statusCode)
        h.statusCode = statusCode
}</span>

func checkWriteHeaderCode(code int) <span class="cov8" title="1">{
        // For now, we only emit a warning for bad codes.
        // In the future we might block things over 599 or under 100
        if code &lt; 100 || code &gt; 599 </span><span class="cov8" title="1">{
                hlog.SystemLogger().Warnf("Invalid StatusCode code %v, status code should not be under 100 or over 599.\n"+
                        "For more info: https://www.rfc-editor.org/rfc/rfc9110.html#name-status-codes", code)
        }</span>
}

func (h *ResponseHeader) ResetSkipNormalize() <span class="cov8" title="1">{
        h.protocol = ""
        h.connectionClose = false

        h.statusCode = 0
        h.contentLength = 0
        h.contentLengthBytes = h.contentLengthBytes[:0]
        h.contentEncoding = h.contentEncoding[:0]

        h.contentType = h.contentType[:0]
        h.server = h.server[:0]

        h.h = h.h[:0]
        h.cookies = h.cookies[:0]
        h.Trailer().ResetSkipNormalize()
        h.mulHeader = h.mulHeader[:0]
}</span>

// ContentLength returns Content-Length header value.
//
// It may be negative:
// -1 means Transfer-Encoding: chunked.
// -2 means Transfer-Encoding: identity.
func (h *ResponseHeader) ContentLength() int <span class="cov8" title="1">{
        return h.contentLength
}</span>

// Set sets the given 'key: value' header.
//
// Use Add for setting multiple header values under the same key.
func (h *ResponseHeader) Set(key, value string) <span class="cov8" title="1">{
        initHeaderKV(&amp;h.bufKV, key, value, h.disableNormalizing)
        h.SetCanonical(h.bufKV.key, h.bufKV.value)
}</span>

// Add adds the given 'key: value' header.
//
// Multiple headers with the same key may be added with this function.
// Use Set for setting a single header for the given key.
//
// the Content-Type, Content-Length, Connection, Server, Set-Cookie,
// Transfer-Encoding and Date headers can only be set once and will
// overwrite the previous value.
func (h *ResponseHeader) Add(key, value string) <span class="cov8" title="1">{
        if h.setSpecialHeader(bytesconv.S2b(key), bytesconv.S2b(value)) </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">k := getHeaderKeyBytes(&amp;h.bufKV, key, h.disableNormalizing)
        h.h = appendArg(h.h, bytesconv.B2s(k), value, ArgsHasValue)</span>
}

// SetContentLength sets Content-Length header value.
//
// Content-Length may be negative:
// -1 means Transfer-Encoding: chunked.
// -2 means Transfer-Encoding: identity.
func (h *ResponseHeader) SetContentLength(contentLength int) <span class="cov8" title="1">{
        if h.MustSkipContentLength() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">h.contentLength = contentLength
        if contentLength &gt;= 0 </span><span class="cov8" title="1">{
                h.contentLengthBytes = bytesconv.AppendUint(h.contentLengthBytes[:0], contentLength)
                h.h = delAllArgsBytes(h.h, bytestr.StrTransferEncoding)
        }</span> else<span class="cov8" title="1"> {
                h.contentLengthBytes = h.contentLengthBytes[:0]
                value := bytestr.StrChunked
                if contentLength == -2 </span><span class="cov8" title="1">{
                        h.SetConnectionClose(true)
                        value = bytestr.StrIdentity
                }</span>
                <span class="cov8" title="1">h.h = setArgBytes(h.h, bytestr.StrTransferEncoding, value, ArgsHasValue)</span>
        }
}

func (h *ResponseHeader) ContentLengthBytes() []byte <span class="cov0" title="0">{
        return h.contentLengthBytes
}</span>

func (h *ResponseHeader) InitContentLengthWithValue(contentLength int) <span class="cov8" title="1">{
        h.contentLength = contentLength
}</span>

// VisitAllCookie calls f for each response cookie.
//
// Cookie name is passed in key and the whole Set-Cookie header value
// is passed in value on each f invocation. Value may be parsed
// with Cookie.ParseBytes().
//
// f must not retain references to key and/or value after returning.
func (h *ResponseHeader) VisitAllCookie(f func(key, value []byte)) <span class="cov0" title="0">{
        visitArgs(h.cookies, f)
}</span>

// DelAllCookies removes all the cookies from response headers.
func (h *ResponseHeader) DelAllCookies() <span class="cov8" title="1">{
        h.cookies = h.cookies[:0]
}</span>

// DelCookie removes cookie under the given key from response header.
//
// Note that DelCookie doesn't remove the cookie from the client.
// Use DelClientCookie instead.
func (h *ResponseHeader) DelCookie(key string) <span class="cov8" title="1">{
        h.cookies = delAllArgs(h.cookies, key)
}</span>

// DelCookieBytes removes cookie under the given key from response header.
//
// Note that DelCookieBytes doesn't remove the cookie from the client.
// Use DelClientCookieBytes instead.
func (h *ResponseHeader) DelCookieBytes(key []byte) <span class="cov0" title="0">{
        h.DelCookie(bytesconv.B2s(key))
}</span>

// DelBytes deletes header with the given key.
func (h *ResponseHeader) DelBytes(key []byte) <span class="cov8" title="1">{
        h.bufKV.key = append(h.bufKV.key[:0], key...)
        utils.NormalizeHeaderKey(h.bufKV.key, h.disableNormalizing)
        h.del(h.bufKV.key)
}</span>

// Header returns response header representation.
//
// The returned value is valid until the next call to ResponseHeader methods.
func (h *ResponseHeader) Header() []byte <span class="cov8" title="1">{
        h.bufKV.value = h.AppendBytes(h.bufKV.value[:0])
        return h.bufKV.value
}</span>

func (h *ResponseHeader) PeekLocation() []byte <span class="cov0" title="0">{
        return h.peek(bytestr.StrLocation)
}</span>

// DelClientCookie instructs the client to remove the given cookie.
// This doesn't work for a cookie with specific domain or path,
// you should delete it manually like:
//
//        c := AcquireCookie()
//        c.SetKey(key)
//        c.SetDomain("example.com")
//        c.SetPath("/path")
//        c.SetExpire(CookieExpireDelete)
//        h.SetCookie(c)
//        ReleaseCookie(c)
//
// Use DelCookie if you want just removing the cookie from response header.
func (h *ResponseHeader) DelClientCookie(key string) <span class="cov8" title="1">{
        h.DelCookie(key)

        c := AcquireCookie()
        c.SetKey(key)
        c.SetExpire(CookieExpireDelete)
        h.SetCookie(c)
        ReleaseCookie(c)
}</span>

// DelClientCookieBytes instructs the client to remove the given cookie.
// This doesn't work for a cookie with specific domain or path,
// you should delete it manually like:
//
//        c := AcquireCookie()
//        c.SetKey(key)
//        c.SetDomain("example.com")
//        c.SetPath("/path")
//        c.SetExpire(CookieExpireDelete)
//        h.SetCookie(c)
//        ReleaseCookie(c)
//
// Use DelCookieBytes if you want just removing the cookie from response header.
func (h *ResponseHeader) DelClientCookieBytes(key []byte) <span class="cov8" title="1">{
        h.DelClientCookie(bytesconv.B2s(key))
}</span>

// Peek returns header value for the given key.
//
// Returned value is valid until the next call to ResponseHeader.
// Do not store references to returned value. Make copies instead.
func (h *ResponseHeader) Peek(key string) []byte <span class="cov8" title="1">{
        k := getHeaderKeyBytes(&amp;h.bufKV, key, h.disableNormalizing)
        return h.peek(k)
}</span>

func (h *ResponseHeader) IsDisableNormalizing() bool <span class="cov0" title="0">{
        return h.disableNormalizing
}</span>

func (h *ResponseHeader) ParseSetCookie(value []byte) <span class="cov0" title="0">{
        var kv *argsKV
        h.cookies, kv = allocArg(h.cookies)
        kv.key = getCookieKey(kv.key, value)
        kv.value = append(kv.value[:0], value...)
}</span>

func (h *ResponseHeader) peek(key []byte) []byte <span class="cov8" title="1">{
        switch string(key) </span>{
        case consts.HeaderContentType:<span class="cov8" title="1">
                return h.ContentType()</span>
        case consts.HeaderContentEncoding:<span class="cov8" title="1">
                return h.ContentEncoding()</span>
        case consts.HeaderServer:<span class="cov8" title="1">
                return h.Server()</span>
        case consts.HeaderConnection:<span class="cov8" title="1">
                if h.ConnectionClose() </span><span class="cov8" title="1">{
                        return bytestr.StrClose
                }</span>
                <span class="cov8" title="1">return peekArgBytes(h.h, key)</span>
        case consts.HeaderContentLength:<span class="cov8" title="1">
                return h.contentLengthBytes</span>
        case consts.HeaderSetCookie:<span class="cov8" title="1">
                return appendResponseCookieBytes(nil, h.cookies)</span>
        case consts.HeaderTrailer:<span class="cov8" title="1">
                return h.Trailer().GetBytes()</span>
        default:<span class="cov8" title="1">
                return peekArgBytes(h.h, key)</span>
        }
}

// PeekAll returns all header value for the given key.
//
// The returned value is valid until the request is released,
// either though ReleaseResponse or your request handler returning.
// Any future calls to the Peek* will modify the returned value.
// Do not store references to returned value. Use ResponseHeader.GetAll(key) instead.
func (h *ResponseHeader) PeekAll(key string) [][]byte <span class="cov8" title="1">{
        k := getHeaderKeyBytes(&amp;h.bufKV, key, h.disableNormalizing)
        return h.peekAll(k)
}</span>

func (h *ResponseHeader) peekAll(key []byte) [][]byte <span class="cov8" title="1">{
        h.mulHeader = h.mulHeader[:0]
        switch string(key) </span>{
        case consts.HeaderContentType:<span class="cov8" title="1">
                if contentType := h.ContentType(); len(contentType) &gt; 0 </span><span class="cov8" title="1">{
                        h.mulHeader = append(h.mulHeader, contentType)
                }</span>
        case consts.HeaderContentEncoding:<span class="cov8" title="1">
                if contentEncoding := h.ContentEncoding(); len(contentEncoding) &gt; 0 </span><span class="cov8" title="1">{
                        h.mulHeader = append(h.mulHeader, contentEncoding)
                }</span>
        case consts.HeaderServer:<span class="cov8" title="1">
                if server := h.Server(); len(server) &gt; 0 </span><span class="cov8" title="1">{
                        h.mulHeader = append(h.mulHeader, server)
                }</span>
        case consts.HeaderConnection:<span class="cov8" title="1">
                if h.ConnectionClose() </span><span class="cov8" title="1">{
                        h.mulHeader = append(h.mulHeader, bytestr.StrClose)
                }</span> else<span class="cov0" title="0"> {
                        h.mulHeader = peekAllArgBytesToDst(h.mulHeader, h.h, key)
                }</span>
        case consts.HeaderContentLength:<span class="cov8" title="1">
                h.mulHeader = append(h.mulHeader, h.contentLengthBytes)</span>
        case consts.HeaderSetCookie:<span class="cov8" title="1">
                h.mulHeader = append(h.mulHeader, appendResponseCookieBytes(nil, h.cookies))</span>
        default:<span class="cov8" title="1">
                h.mulHeader = peekAllArgBytesToDst(h.mulHeader, h.h, key)</span>
        }
        <span class="cov8" title="1">return h.mulHeader</span>
}

// PeekAll returns all header value for the given key.
//
// The returned value is valid until the request is released,
// either though ReleaseRequest or your request handler returning.
// Any future calls to the Peek* will modify the returned value.
// Do not store references to returned value. Use RequestHeader.GetAll(key) instead.
func (h *RequestHeader) PeekAll(key string) [][]byte <span class="cov8" title="1">{
        k := getHeaderKeyBytes(&amp;h.bufKV, key, h.disableNormalizing)
        return h.peekAll(k)
}</span>

func (h *RequestHeader) peekAll(key []byte) [][]byte <span class="cov8" title="1">{
        h.mulHeader = h.mulHeader[:0]
        switch string(key) </span>{
        case consts.HeaderHost:<span class="cov8" title="1">
                if host := h.Host(); len(host) &gt; 0 </span><span class="cov8" title="1">{
                        h.mulHeader = append(h.mulHeader, host)
                }</span>
        case consts.HeaderContentType:<span class="cov8" title="1">
                if contentType := h.ContentType(); len(contentType) &gt; 0 </span><span class="cov8" title="1">{
                        h.mulHeader = append(h.mulHeader, contentType)
                }</span>
        case consts.HeaderUserAgent:<span class="cov8" title="1">
                if ua := h.UserAgent(); len(ua) &gt; 0 </span><span class="cov8" title="1">{
                        h.mulHeader = append(h.mulHeader, ua)
                }</span>
        case consts.HeaderConnection:<span class="cov8" title="1">
                if h.ConnectionClose() </span><span class="cov0" title="0">{
                        h.mulHeader = append(h.mulHeader, bytestr.StrClose)
                }</span> else<span class="cov8" title="1"> {
                        h.mulHeader = peekAllArgBytesToDst(h.mulHeader, h.h, key)
                }</span>
        case consts.HeaderContentLength:<span class="cov8" title="1">
                h.mulHeader = append(h.mulHeader, h.contentLengthBytes)</span>
        case consts.HeaderCookie:<span class="cov8" title="1">
                if h.cookiesCollected </span><span class="cov8" title="1">{
                        h.mulHeader = append(h.mulHeader, appendRequestCookieBytes(nil, h.cookies))
                }</span> else<span class="cov0" title="0"> {
                        h.mulHeader = peekAllArgBytesToDst(h.mulHeader, h.h, key)
                }</span>
        default:<span class="cov8" title="1">
                h.mulHeader = peekAllArgBytesToDst(h.mulHeader, h.h, key)</span>
        }
        <span class="cov8" title="1">return h.mulHeader</span>
}

// SetContentTypeBytes sets Content-Type header value.
func (h *ResponseHeader) SetContentTypeBytes(contentType []byte) <span class="cov8" title="1">{
        h.contentType = append(h.contentType[:0], contentType...)
}</span>

// ContentEncoding returns Content-Encoding header value.
func (h *ResponseHeader) ContentEncoding() []byte <span class="cov8" title="1">{
        return h.contentEncoding
}</span>

// SetContentEncoding sets Content-Encoding header value.
func (h *ResponseHeader) SetContentEncoding(contentEncoding string) <span class="cov8" title="1">{
        h.contentEncoding = append(h.contentEncoding[:0], contentEncoding...)
}</span>

// SetContentEncodingBytes sets Content-Encoding header value.
func (h *ResponseHeader) SetContentEncodingBytes(contentEncoding []byte) <span class="cov8" title="1">{
        h.contentEncoding = append(h.contentEncoding[:0], contentEncoding...)
}</span>

func (h *ResponseHeader) SetContentLengthBytes(contentLength []byte) <span class="cov8" title="1">{
        h.contentLengthBytes = append(h.contentLengthBytes[:0], contentLength...)
}</span>

// SetCanonical sets the given 'key: value' header assuming that
// key is in canonical form.
func (h *ResponseHeader) SetCanonical(key, value []byte) <span class="cov8" title="1">{
        if h.setSpecialHeader(key, value) </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">h.h = setArgBytes(h.h, key, value, ArgsHasValue)</span>
}

// ResetConnectionClose clears 'Connection: close' header if it exists.
func (h *ResponseHeader) ResetConnectionClose() <span class="cov8" title="1">{
        if h.connectionClose </span><span class="cov8" title="1">{
                h.connectionClose = false
                h.h = delAllArgsBytes(h.h, bytestr.StrConnection)
        }</span>
}

// Server returns Server header value.
func (h *ResponseHeader) Server() []byte <span class="cov8" title="1">{
        return h.server
}</span>

func (h *ResponseHeader) AddArgBytes(key, value []byte, noValue bool) <span class="cov0" title="0">{
        h.h = appendArgBytes(h.h, key, value, noValue)
}</span>

func (h *ResponseHeader) SetArgBytes(key, value []byte, noValue bool) <span class="cov0" title="0">{
        h.h = setArgBytes(h.h, key, value, noValue)
}</span>

// AppendBytes appends response header representation to dst and returns
// the extended dst.
func (h *ResponseHeader) AppendBytes(dst []byte) []byte <span class="cov8" title="1">{
        statusCode := h.StatusCode()
        if statusCode &lt; 0 </span><span class="cov0" title="0">{
                statusCode = consts.StatusOK
        }</span>
        <span class="cov8" title="1">dst = append(dst, consts.StatusLine(statusCode)...)

        server := h.Server()
        if len(server) != 0 </span><span class="cov8" title="1">{
                dst = appendHeaderLine(dst, bytestr.StrServer, server)
        }</span>

        <span class="cov8" title="1">if !h.noDefaultDate </span><span class="cov8" title="1">{
                ServerDateOnce.Do(UpdateServerDate)
                dst = appendHeaderLine(dst, bytestr.StrDate, ServerDate.Load().([]byte))
        }</span>

        // Append Content-Type only for non-zero responses
        // or if it is explicitly set.
        <span class="cov8" title="1">if h.ContentLength() != 0 || len(h.contentType) &gt; 0 </span><span class="cov8" title="1">{
                contentType := h.ContentType()
                if len(contentType) &gt; 0 </span><span class="cov8" title="1">{
                        dst = appendHeaderLine(dst, bytestr.StrContentType, contentType)
                }</span>
        }
        <span class="cov8" title="1">contentEncoding := h.ContentEncoding()
        if len(contentEncoding) &gt; 0 </span><span class="cov8" title="1">{
                dst = appendHeaderLine(dst, bytestr.StrContentEncoding, contentEncoding)
        }</span>
        <span class="cov8" title="1">if len(h.contentLengthBytes) &gt; 0 </span><span class="cov8" title="1">{
                dst = appendHeaderLine(dst, bytestr.StrContentLength, h.contentLengthBytes)
        }</span>

        <span class="cov8" title="1">for i, n := 0, len(h.h); i &lt; n; i++ </span><span class="cov8" title="1">{
                kv := &amp;h.h[i]
                if h.noDefaultDate || !bytes.Equal(kv.key, bytestr.StrDate) </span><span class="cov8" title="1">{
                        dst = appendHeaderLine(dst, kv.key, kv.value)
                }</span>
        }

        <span class="cov8" title="1">if !h.Trailer().Empty() </span><span class="cov8" title="1">{
                dst = appendHeaderLine(dst, bytestr.StrTrailer, h.Trailer().GetBytes())
        }</span>

        <span class="cov8" title="1">n := len(h.cookies)
        if n &gt; 0 </span><span class="cov8" title="1">{
                for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                        kv := &amp;h.cookies[i]
                        dst = appendHeaderLine(dst, bytestr.StrSetCookie, kv.value)
                }</span>
        }

        <span class="cov8" title="1">if h.ConnectionClose() </span><span class="cov8" title="1">{
                dst = appendHeaderLine(dst, bytestr.StrConnection, bytestr.StrClose)
        }</span>

        <span class="cov8" title="1">return append(dst, bytestr.StrCRLF...)</span>
}

// ConnectionClose returns true if 'Connection: close' header is set.
func (h *ResponseHeader) ConnectionClose() bool <span class="cov8" title="1">{
        return h.connectionClose
}</span>

func (h *ResponseHeader) GetCookies() []argsKV <span class="cov0" title="0">{
        return h.cookies
}</span>

// ContentType returns Content-Type header value.
func (h *ResponseHeader) ContentType() []byte <span class="cov8" title="1">{
        contentType := h.contentType
        if !h.noDefaultContentType &amp;&amp; len(h.contentType) == 0 </span><span class="cov8" title="1">{
                contentType = bytestr.DefaultContentType
        }</span>
        <span class="cov8" title="1">return contentType</span>
}

// SetNoDefaultContentType set noDefaultContentType value of ResponseHeader.
func (h *ResponseHeader) SetNoDefaultContentType(b bool) <span class="cov8" title="1">{
        h.noDefaultContentType = b
}</span>

// SetNoDefaultDate set noDefaultDate value of ResponseHeader.
func (h *ResponseHeader) SetNoDefaultDate(b bool) <span class="cov0" title="0">{
        h.noDefaultDate = b
}</span>

// SetServerBytes sets Server header value.
func (h *ResponseHeader) SetServerBytes(server []byte) <span class="cov8" title="1">{
        h.server = append(h.server[:0], server...)
}</span>

func (h *ResponseHeader) MustSkipContentLength() bool <span class="cov8" title="1">{
        // From http/1.1 specs:
        // All 1xx (informational), 204 (no content), and 304 (not modified) responses MUST NOT include a message-body
        statusCode := h.StatusCode()

        // Fast path.
        if statusCode &lt; 100 || statusCode == consts.StatusOK </span><span class="cov8" title="1">{
                return false
        }</span>

        // Slow path.
        <span class="cov8" title="1">return statusCode == consts.StatusNotModified || statusCode == consts.StatusNoContent || statusCode &lt; 200</span>
}

// StatusCode returns response status code.
func (h *ResponseHeader) StatusCode() int <span class="cov8" title="1">{
        if h.statusCode == 0 </span><span class="cov8" title="1">{
                return consts.StatusOK
        }</span>
        <span class="cov8" title="1">return h.statusCode</span>
}

// Del deletes header with the given key.
func (h *ResponseHeader) Del(key string) <span class="cov8" title="1">{
        k := getHeaderKeyBytes(&amp;h.bufKV, key, h.disableNormalizing)
        h.del(k)
}</span>

func (h *ResponseHeader) del(key []byte) <span class="cov8" title="1">{
        switch string(key) </span>{
        case consts.HeaderContentType:<span class="cov8" title="1">
                h.contentType = h.contentType[:0]</span>
        case consts.HeaderContentEncoding:<span class="cov8" title="1">
                h.contentEncoding = h.contentEncoding[:0]</span>
        case consts.HeaderServer:<span class="cov8" title="1">
                h.server = h.server[:0]</span>
        case consts.HeaderSetCookie:<span class="cov8" title="1">
                h.cookies = h.cookies[:0]</span>
        case consts.HeaderContentLength:<span class="cov8" title="1">
                h.contentLength = 0
                h.contentLengthBytes = h.contentLengthBytes[:0]</span>
        case consts.HeaderConnection:<span class="cov8" title="1">
                h.connectionClose = false</span>
        case consts.HeaderTrailer:<span class="cov8" title="1">
                h.Trailer().ResetSkipNormalize()</span>
        }
        <span class="cov8" title="1">h.h = delAllArgsBytes(h.h, key)</span>
}

// SetBytesV sets the given 'key: value' header.
//
// Use AddBytesV for setting multiple header values under the same key.
func (h *ResponseHeader) SetBytesV(key string, value []byte) <span class="cov8" title="1">{
        k := getHeaderKeyBytes(&amp;h.bufKV, key, h.disableNormalizing)
        h.SetCanonical(k, value)
}</span>

// Len returns the number of headers set,
// i.e. the number of times f is called in VisitAll.
func (h *ResponseHeader) Len() int <span class="cov8" title="1">{
        n := 0
        h.VisitAll(func(k, v []byte) </span><span class="cov8" title="1">{ n++ }</span>)
        <span class="cov8" title="1">return n</span>
}

// Len returns the number of headers set,
// i.e. the number of times f is called in VisitAll.
func (h *RequestHeader) Len() int <span class="cov8" title="1">{
        n := 0
        h.VisitAll(func(k, v []byte) </span><span class="cov8" title="1">{ n++ }</span>)
        <span class="cov8" title="1">return n</span>
}

// Reset clears request header.
func (h *RequestHeader) Reset() <span class="cov8" title="1">{
        h.disableNormalizing = false
        h.Trailer().disableNormalizing = false
        h.ResetSkipNormalize()
}</span>

// SetByteRange sets 'Range: bytes=startPos-endPos' header.
//
//   - If startPos is negative, then 'bytes=-startPos' value is set.
//   - If endPos is negative, then 'bytes=startPos-' value is set.
func (h *RequestHeader) SetByteRange(startPos, endPos int) <span class="cov8" title="1">{
        b := h.bufKV.value[:0]
        b = append(b, bytestr.StrBytes...)
        b = append(b, '=')
        if startPos &gt;= 0 </span><span class="cov8" title="1">{
                b = bytesconv.AppendUint(b, startPos)
        }</span> else<span class="cov0" title="0"> {
                endPos = -startPos
        }</span>
        <span class="cov8" title="1">b = append(b, '-')
        if endPos &gt;= 0 </span><span class="cov8" title="1">{
                b = bytesconv.AppendUint(b, endPos)
        }</span>
        <span class="cov8" title="1">h.bufKV.value = b

        h.SetCanonical(bytestr.StrRange, h.bufKV.value)</span>
}

// DelBytes deletes header with the given key.
func (h *RequestHeader) DelBytes(key []byte) <span class="cov8" title="1">{
        h.bufKV.key = append(h.bufKV.key[:0], key...)
        utils.NormalizeHeaderKey(h.bufKV.key, h.disableNormalizing)
        h.del(h.bufKV.key)
}</span>

// Del deletes header with the given key.
func (h *RequestHeader) Del(key string) <span class="cov8" title="1">{
        k := getHeaderKeyBytes(&amp;h.bufKV, key, h.disableNormalizing)
        h.del(k)
}</span>

func (h *RequestHeader) SetArgBytes(key, value []byte, noValue bool) <span class="cov0" title="0">{
        h.h = setArgBytes(h.h, key, value, noValue)
}</span>

func (h *RequestHeader) del(key []byte) <span class="cov8" title="1">{
        switch string(key) </span>{
        case consts.HeaderHost:<span class="cov8" title="1">
                h.host = h.host[:0]</span>
        case consts.HeaderContentType:<span class="cov8" title="1">
                h.contentType = h.contentType[:0]</span>
        case consts.HeaderUserAgent:<span class="cov8" title="1">
                h.userAgent = h.userAgent[:0]</span>
        case consts.HeaderCookie:<span class="cov0" title="0">
                h.cookies = h.cookies[:0]</span>
        case consts.HeaderContentLength:<span class="cov8" title="1">
                h.contentLength = 0
                h.contentLengthBytes = h.contentLengthBytes[:0]</span>
        case consts.HeaderConnection:<span class="cov8" title="1">
                h.connectionClose = false</span>
        case consts.HeaderTrailer:<span class="cov8" title="1">
                h.Trailer().ResetSkipNormalize()</span>
        }
        <span class="cov8" title="1">h.h = delAllArgsBytes(h.h, key)</span>
}

// CopyTo copies all the headers to dst.
func (h *RequestHeader) CopyTo(dst *RequestHeader) <span class="cov8" title="1">{
        dst.Reset()

        dst.disableNormalizing = h.disableNormalizing
        dst.connectionClose = h.connectionClose
        dst.noDefaultContentType = h.noDefaultContentType

        dst.contentLength = h.contentLength
        dst.contentLengthBytes = append(dst.contentLengthBytes[:0], h.contentLengthBytes...)
        dst.method = append(dst.method[:0], h.method...)
        dst.requestURI = append(dst.requestURI[:0], h.requestURI...)
        dst.host = append(dst.host[:0], h.host...)
        dst.contentType = append(dst.contentType[:0], h.contentType...)
        dst.userAgent = append(dst.userAgent[:0], h.userAgent...)
        h.Trailer().CopyTo(dst.Trailer())
        dst.h = copyArgs(dst.h, h.h)
        dst.cookies = copyArgs(dst.cookies, h.cookies)
        dst.cookiesCollected = h.cookiesCollected
        dst.rawHeaders = append(dst.rawHeaders[:0], h.rawHeaders...)
        dst.protocol = h.protocol
}</span>

// Peek returns header value for the given key.
//
// Returned value is valid until the next call to RequestHeader.
// Do not store references to returned value. Make copies instead.
func (h *RequestHeader) Peek(key string) []byte <span class="cov8" title="1">{
        k := getHeaderKeyBytes(&amp;h.bufKV, key, h.disableNormalizing)
        return h.peek(k)
}</span>

// SetMultipartFormBoundary sets the following Content-Type:
// 'multipart/form-data; boundary=...'
// where ... is substituted by the given boundary.
func (h *RequestHeader) SetMultipartFormBoundary(boundary string) <span class="cov8" title="1">{
        b := h.bufKV.value[:0]
        b = append(b, bytestr.StrMultipartFormData...)
        b = append(b, ';', ' ')
        b = append(b, bytestr.StrBoundary...)
        b = append(b, '=')
        b = append(b, boundary...)
        h.bufKV.value = b

        h.SetContentTypeBytes(h.bufKV.value)
}</span>

func (h *RequestHeader) ContentLengthBytes() []byte <span class="cov0" title="0">{
        return h.contentLengthBytes
}</span>

func (h *RequestHeader) SetContentLengthBytes(contentLength []byte) <span class="cov8" title="1">{
        h.contentLengthBytes = append(h.contentLengthBytes[:0], contentLength...)
}</span>

// SetContentTypeBytes sets Content-Type header value.
func (h *RequestHeader) SetContentTypeBytes(contentType []byte) <span class="cov8" title="1">{
        h.contentType = append(h.contentType[:0], contentType...)
}</span>

// ContentType returns Content-Type header value.
func (h *RequestHeader) ContentType() []byte <span class="cov8" title="1">{
        return h.contentType
}</span>

// SetNoDefaultContentType controls the default Content-Type header behaviour.
//
// When set to false, the Content-Type header is sent with a default value if no Content-Type value is specified.
// When set to true, no Content-Type header is sent if no Content-Type value is specified.
func (h *RequestHeader) SetNoDefaultContentType(b bool) <span class="cov8" title="1">{
        h.noDefaultContentType = b
}</span>

// SetContentLength sets Content-Length header value.
//
// Negative content-length sets 'Transfer-Encoding: chunked' header.
func (h *RequestHeader) SetContentLength(contentLength int) <span class="cov8" title="1">{
        h.contentLength = contentLength
        if contentLength &gt;= 0 </span><span class="cov8" title="1">{
                h.contentLengthBytes = bytesconv.AppendUint(h.contentLengthBytes[:0], contentLength)
                h.h = delAllArgsBytes(h.h, bytestr.StrTransferEncoding)
        }</span> else<span class="cov8" title="1"> {
                h.contentLengthBytes = h.contentLengthBytes[:0]
                h.h = setArgBytes(h.h, bytestr.StrTransferEncoding, bytestr.StrChunked, ArgsHasValue)
        }</span>
}

func (h *RequestHeader) InitContentLengthWithValue(contentLength int) <span class="cov8" title="1">{
        h.contentLength = contentLength
}</span>

// MultipartFormBoundary returns boundary part
// from 'multipart/form-data; boundary=...' Content-Type.
func (h *RequestHeader) MultipartFormBoundary() []byte <span class="cov8" title="1">{
        b := h.ContentType()
        if !bytes.HasPrefix(b, bytestr.StrMultipartFormData) </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">b = b[len(bytestr.StrMultipartFormData):]
        if len(b) == 0 || b[0] != ';' </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">var n int
        for len(b) &gt; 0 </span><span class="cov8" title="1">{
                n++
                for len(b) &gt; n &amp;&amp; b[n] == ' ' </span><span class="cov8" title="1">{
                        n++
                }</span>
                <span class="cov8" title="1">b = b[n:]
                if !bytes.HasPrefix(b, bytestr.StrBoundary) </span><span class="cov0" title="0">{
                        if n = bytes.IndexByte(b, ';'); n &lt; 0 </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov8" title="1">b = b[len(bytestr.StrBoundary):]
                if len(b) == 0 || b[0] != '=' </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">b = b[1:]
                if n = bytes.IndexByte(b, ';'); n &gt;= 0 </span><span class="cov0" title="0">{
                        b = b[:n]
                }</span>
                <span class="cov8" title="1">if len(b) &gt; 1 &amp;&amp; b[0] == '"' &amp;&amp; b[len(b)-1] == '"' </span><span class="cov0" title="0">{
                        b = b[1 : len(b)-1]
                }</span>
                <span class="cov8" title="1">return b</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// ConnectionClose returns true if 'Connection: close' header is set.
func (h *RequestHeader) ConnectionClose() bool <span class="cov8" title="1">{
        return h.connectionClose
}</span>

// Method returns HTTP request method.
func (h *RequestHeader) Method() []byte <span class="cov8" title="1">{
        if len(h.method) == 0 </span><span class="cov8" title="1">{
                return bytestr.StrGet
        }</span>
        <span class="cov8" title="1">return h.method</span>
}

// IsGet returns true if request method is GET.
func (h *RequestHeader) IsGet() bool <span class="cov8" title="1">{
        return bytes.Equal(h.Method(), bytestr.StrGet)
}</span>

// IsOptions returns true if request method is Options.
func (h *RequestHeader) IsOptions() bool <span class="cov0" title="0">{
        return bytes.Equal(h.Method(), bytestr.StrOptions)
}</span>

// IsTrace returns true if request method is Trace.
func (h *RequestHeader) IsTrace() bool <span class="cov0" title="0">{
        return bytes.Equal(h.Method(), bytestr.StrTrace)
}</span>

// SetHostBytes sets Host header value.
func (h *RequestHeader) SetHostBytes(host []byte) <span class="cov8" title="1">{
        h.host = append(h.host[:0], host...)
}</span>

// SetRequestURIBytes sets RequestURI for the first HTTP request line.
// RequestURI must be properly encoded.
// Use URI.RequestURI for constructing proper RequestURI if unsure.
func (h *RequestHeader) SetRequestURIBytes(requestURI []byte) <span class="cov8" title="1">{
        h.requestURI = append(h.requestURI[:0], requestURI...)
}</span>

// SetBytesKV sets the given 'key: value' header.
//
// Use AddBytesKV for setting multiple header values under the same key.
func (h *RequestHeader) SetBytesKV(key, value []byte) <span class="cov8" title="1">{
        h.bufKV.key = append(h.bufKV.key[:0], key...)
        utils.NormalizeHeaderKey(h.bufKV.key, h.disableNormalizing)
        h.SetCanonical(h.bufKV.key, value)
}</span>

func (h *RequestHeader) AddArgBytes(key, value []byte, noValue bool) <span class="cov0" title="0">{
        h.h = appendArgBytes(h.h, key, value, noValue)
}</span>

// SetUserAgentBytes sets User-Agent header value.
func (h *RequestHeader) SetUserAgentBytes(userAgent []byte) <span class="cov8" title="1">{
        h.userAgent = append(h.userAgent[:0], userAgent...)
}</span>

// SetCookie sets 'key: value' cookies.
func (h *RequestHeader) SetCookie(key, value string) <span class="cov8" title="1">{
        h.collectCookies()
        h.cookies = setArg(h.cookies, key, value, ArgsHasValue)
}</span>

// SetCookie sets the given response cookie.
// It is save re-using the cookie after the function returns.
func (h *ResponseHeader) SetCookie(cookie *Cookie) <span class="cov8" title="1">{
        h.cookies = setArgBytes(h.cookies, cookie.Key(), cookie.Cookie(), ArgsHasValue)
}</span>

// Cookie returns cookie for the given key.
func (h *RequestHeader) Cookie(key string) []byte <span class="cov8" title="1">{
        h.collectCookies()
        return peekArgStr(h.cookies, key)
}</span>

// Cookies returns all the request cookies.
//
// It's a good idea to call protocol.ReleaseCookie to reduce GC load after the cookie used.
func (h *RequestHeader) Cookies() []*Cookie <span class="cov8" title="1">{
        var cookies []*Cookie
        h.VisitAllCookie(func(key, value []byte) </span><span class="cov8" title="1">{
                cookie := AcquireCookie()
                cookie.SetKeyBytes(key)
                cookie.SetValueBytes(value)
                cookies = append(cookies, cookie)
        }</span>)
        <span class="cov8" title="1">return cookies</span>
}

func (h *RequestHeader) PeekRange() []byte <span class="cov0" title="0">{
        return h.peek(bytestr.StrRange)
}</span>

func (h *RequestHeader) PeekContentEncoding() []byte <span class="cov0" title="0">{
        return h.peek(bytestr.StrContentEncoding)
}</span>

// FullCookie returns complete cookie bytes
func (h *RequestHeader) FullCookie() []byte <span class="cov8" title="1">{
        return h.Peek(consts.HeaderCookie)
}</span>

// DelCookie removes cookie under the given key.
func (h *RequestHeader) DelCookie(key string) <span class="cov8" title="1">{
        h.collectCookies()
        h.cookies = delAllArgs(h.cookies, key)
}</span>

// DelAllCookies removes all the cookies from request headers.
func (h *RequestHeader) DelAllCookies() <span class="cov8" title="1">{
        h.collectCookies()
        h.cookies = h.cookies[:0]
}</span>

// VisitAllCookie calls f for each request cookie.
//
// f must not retain references to key and/or value after returning.
func (h *RequestHeader) VisitAllCookie(f func(key, value []byte)) <span class="cov8" title="1">{
        h.collectCookies()
        visitArgs(h.cookies, f)
}</span>

func (h *RequestHeader) collectCookies() <span class="cov8" title="1">{
        if h.cookiesCollected </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">for i, n := 0, len(h.h); i &lt; n; i++ </span><span class="cov8" title="1">{
                kv := &amp;h.h[i]
                if bytes.Equal(kv.key, bytestr.StrCookie) </span><span class="cov0" title="0">{
                        h.cookies = parseRequestCookies(h.cookies, kv.value)
                        tmp := *kv
                        copy(h.h[i:], h.h[i+1:])
                        n--
                        i--
                        h.h[n] = tmp
                        h.h = h.h[:n]
                }</span>
        }
        <span class="cov8" title="1">h.cookiesCollected = true</span>
}

func (h *RequestHeader) SetConnectionClose(close bool) <span class="cov8" title="1">{
        h.connectionClose = close
}</span>

// ResetConnectionClose clears 'Connection: close' header if it exists.
func (h *RequestHeader) ResetConnectionClose() <span class="cov8" title="1">{
        if h.connectionClose </span><span class="cov8" title="1">{
                h.connectionClose = false
                h.h = delAllArgsBytes(h.h, bytestr.StrConnection)
        }</span>
}

// SetMethod sets HTTP request method.
func (h *RequestHeader) SetMethod(method string) <span class="cov8" title="1">{
        h.method = append(h.method[:0], method...)
}</span>

// SetRequestURI sets RequestURI for the first HTTP request line.
// RequestURI must be properly encoded.
// Use URI.RequestURI for constructing proper RequestURI if unsure.
func (h *RequestHeader) SetRequestURI(requestURI string) <span class="cov8" title="1">{
        h.requestURI = append(h.requestURI[:0], requestURI...)
}</span>

// Set sets the given 'key: value' header.
//
// Use Add for setting multiple header values under the same key.
func (h *RequestHeader) Set(key, value string) <span class="cov8" title="1">{
        initHeaderKV(&amp;h.bufKV, key, value, h.disableNormalizing)
        h.SetCanonical(h.bufKV.key, h.bufKV.value)
}</span>

func initHeaderKV(kv *argsKV, key, value string, disableNormalizing bool) <span class="cov8" title="1">{
        kv.key = getHeaderKeyBytes(kv, key, disableNormalizing)
        kv.value = append(kv.value[:0], value...)
}</span>

// SetCanonical sets the given 'key: value' header assuming that
// key is in canonical form.
func (h *RequestHeader) SetCanonical(key, value []byte) <span class="cov8" title="1">{
        if h.setSpecialHeader(key, value) </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">h.h = setArgBytes(h.h, key, value, ArgsHasValue)</span>
}

func (h *RequestHeader) ResetSkipNormalize() <span class="cov8" title="1">{
        h.connectionClose = false
        h.protocol = ""
        h.noDefaultContentType = false

        h.contentLength = 0
        h.contentLengthBytes = h.contentLengthBytes[:0]

        h.method = h.method[:0]
        h.requestURI = h.requestURI[:0]
        h.host = h.host[:0]
        h.contentType = h.contentType[:0]
        h.userAgent = h.userAgent[:0]

        h.h = h.h[:0]
        h.cookies = h.cookies[:0]
        h.cookiesCollected = false

        h.rawHeaders = h.rawHeaders[:0]
        h.mulHeader = h.mulHeader[:0]
        h.Trailer().ResetSkipNormalize()
}</span>

func peekRawHeader(buf, key []byte) []byte <span class="cov8" title="1">{
        n := bytes.Index(buf, key)
        if n &lt; 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">if n &gt; 0 &amp;&amp; buf[n-1] != '\n' </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">n += len(key)
        if n &gt;= len(buf) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">if buf[n] != ':' </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">n++
        if buf[n] != ' ' </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">n++
        buf = buf[n:]
        n = bytes.IndexByte(buf, '\n')
        if n &lt; 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">if n &gt; 0 &amp;&amp; buf[n-1] == '\r' </span><span class="cov8" title="1">{
                n--
        }</span>
        <span class="cov8" title="1">return buf[:n]</span>
}

// Host returns Host header value.
func (h *RequestHeader) Host() []byte <span class="cov8" title="1">{
        return h.host
}</span>

// UserAgent returns User-Agent header value.
func (h *RequestHeader) UserAgent() []byte <span class="cov8" title="1">{
        return h.userAgent
}</span>

// DisableNormalizing disables header names' normalization.
//
// By default all the header names are normalized by uppercasing
// the first letter and all the first letters following dashes,
// while lowercasing all the other letters.
// Examples:
//
//   - CONNECTION -&gt; Connection
//   - conteNT-tYPE -&gt; Content-Type
//   - foo-bar-baz -&gt; Foo-Bar-Baz
//
// Disable header names' normalization only if you know what are you doing.
func (h *RequestHeader) DisableNormalizing() <span class="cov0" title="0">{
        h.disableNormalizing = true
        h.Trailer().DisableNormalizing()
}</span>

func (h *RequestHeader) IsDisableNormalizing() bool <span class="cov0" title="0">{
        return h.disableNormalizing
}</span>

// String returns request header representation.
func (h *RequestHeader) String() string <span class="cov8" title="1">{
        return string(h.Header())
}</span>

// VisitAll calls f for each header.
//
// f must not retain references to key and/or value after returning.
// Copy key and/or value contents before returning if you need retaining them.
//
// To get the headers in order they were received use VisitAllInOrder.
func (h *RequestHeader) VisitAll(f func(key, value []byte)) <span class="cov8" title="1">{
        host := h.Host()
        if len(host) &gt; 0 </span><span class="cov8" title="1">{
                f(bytestr.StrHost, host)
        }</span>
        <span class="cov8" title="1">if len(h.contentLengthBytes) &gt; 0 </span><span class="cov8" title="1">{
                f(bytestr.StrContentLength, h.contentLengthBytes)
        }</span>
        <span class="cov8" title="1">contentType := h.ContentType()
        if len(contentType) &gt; 0 </span><span class="cov8" title="1">{
                f(bytestr.StrContentType, contentType)
        }</span>
        <span class="cov8" title="1">userAgent := h.UserAgent()
        if len(userAgent) &gt; 0 </span><span class="cov8" title="1">{
                f(bytestr.StrUserAgent, userAgent)
        }</span>
        <span class="cov8" title="1">if !h.Trailer().Empty() </span><span class="cov8" title="1">{
                f(bytestr.StrTrailer, h.Trailer().GetBytes())
        }</span>

        <span class="cov8" title="1">h.collectCookies()
        if len(h.cookies) &gt; 0 </span><span class="cov8" title="1">{
                h.bufKV.value = appendRequestCookieBytes(h.bufKV.value[:0], h.cookies)
                f(bytestr.StrCookie, h.bufKV.value)
        }</span>
        <span class="cov8" title="1">visitArgs(h.h, f)
        if h.ConnectionClose() </span><span class="cov8" title="1">{
                f(bytestr.StrConnection, bytestr.StrClose)
        }</span>
}

// VisitAllCustomHeader calls f for each header in header.h which contains all headers
// except cookie, host, content-length, content-type, user-agent and connection.
//
// f must not retain references to key and/or value after returning.
// Copy key and/or value contents before returning if you need retaining them.
//
// To get the headers in order they were received use VisitAllInOrder.
func (h *RequestHeader) VisitAllCustomHeader(f func(key, value []byte)) <span class="cov0" title="0">{
        visitArgs(h.h, f)
}</span>

func ParseContentLength(b []byte) (int, error) <span class="cov8" title="1">{
        v, n, err := bytesconv.ParseUintBuf(b)
        if err != nil </span><span class="cov0" title="0">{
                return -1, err
        }</span>
        <span class="cov8" title="1">if n != len(b) </span><span class="cov0" title="0">{
                return -1, errs.NewPublic("non-numeric chars at the end of Content-Length")
        }</span>
        <span class="cov8" title="1">return v, nil</span>
}

func appendArgBytes(args []argsKV, key, value []byte, noValue bool) []argsKV <span class="cov8" title="1">{
        var kv *argsKV
        args, kv = allocArg(args)
        kv.key = append(kv.key[:0], key...)
        if noValue </span><span class="cov8" title="1">{
                kv.value = kv.value[:0]
        }</span> else<span class="cov8" title="1"> {
                kv.value = append(kv.value[:0], value...)
        }</span>
        <span class="cov8" title="1">kv.noValue = noValue
        return args</span>
}

func appendArg(args []argsKV, key, value string, noValue bool) []argsKV <span class="cov8" title="1">{
        var kv *argsKV
        args, kv = allocArg(args)
        kv.key = append(kv.key[:0], key...)
        if noValue </span><span class="cov8" title="1">{
                kv.value = kv.value[:0]
        }</span> else<span class="cov8" title="1"> {
                kv.value = append(kv.value[:0], value...)
        }</span>
        <span class="cov8" title="1">kv.noValue = noValue
        return args</span>
}

func (h *RequestHeader) peek(key []byte) []byte <span class="cov8" title="1">{
        switch string(key) </span>{
        case consts.HeaderHost:<span class="cov0" title="0">
                return h.Host()</span>
        case consts.HeaderContentType:<span class="cov8" title="1">
                return h.ContentType()</span>
        case consts.HeaderUserAgent:<span class="cov8" title="1">
                return h.UserAgent()</span>
        case consts.HeaderConnection:<span class="cov8" title="1">
                if h.ConnectionClose() </span><span class="cov8" title="1">{
                        return bytestr.StrClose
                }</span>
                <span class="cov8" title="1">return peekArgBytes(h.h, key)</span>
        case consts.HeaderContentLength:<span class="cov8" title="1">
                return h.contentLengthBytes</span>
        case consts.HeaderCookie:<span class="cov8" title="1">
                if h.cookiesCollected </span><span class="cov8" title="1">{
                        return appendRequestCookieBytes(nil, h.cookies)
                }</span>
                <span class="cov0" title="0">return peekArgBytes(h.h, key)</span>
        case consts.HeaderTrailer:<span class="cov8" title="1">
                return h.Trailer().GetBytes()</span>
        default:<span class="cov8" title="1">
                return peekArgBytes(h.h, key)</span>
        }
}

func (h *RequestHeader) Get(key string) string <span class="cov8" title="1">{
        return string(h.Peek(key))
}</span>

func (h *ResponseHeader) Get(key string) string <span class="cov8" title="1">{
        return string(h.Peek(key))
}</span>

// GetAll returns all header value for the given key
// it is concurrent safety and long lifetime.
func (h *RequestHeader) GetAll(key string) []string <span class="cov8" title="1">{
        res := make([]string, 0)
        headers := h.PeekAll(key)
        for _, header := range headers </span><span class="cov8" title="1">{
                res = append(res, string(header))
        }</span>
        <span class="cov8" title="1">return res</span>
}

// GetAll returns all header value for the given key and is concurrent safety.
// it is concurrent safety and long lifetime.
func (h *ResponseHeader) GetAll(key string) []string <span class="cov8" title="1">{
        res := make([]string, 0)
        headers := h.PeekAll(key)
        for _, header := range headers </span><span class="cov8" title="1">{
                res = append(res, string(header))
        }</span>
        <span class="cov8" title="1">return res</span>
}

func appendHeaderLine(dst, key, value []byte) []byte <span class="cov8" title="1">{
        for _, k := range key </span><span class="cov8" title="1">{
                // if header field contains invalid key, just skip it.
                if bytesconv.ValidHeaderFieldNameTable[k] == 0 </span><span class="cov0" title="0">{
                        return dst
                }</span>
        }
        <span class="cov8" title="1">dst = append(dst, key...)
        dst = append(dst, bytestr.StrColonSpace...)
        dst = append(dst, newlineToSpace(value)...)
        return append(dst, bytestr.StrCRLF...)</span>
}

// newlineToSpace will return a copy of the original byte slice.
func newlineToSpace(val []byte) []byte <span class="cov8" title="1">{
        filteredVal := make([]byte, len(val))
        copy(filteredVal, val)
        for i := 0; i &lt; len(filteredVal); i++ </span><span class="cov8" title="1">{
                filteredVal[i] = bytesconv.NewlineToSpaceTable[filteredVal[i]]
        }</span>
        <span class="cov8" title="1">return filteredVal</span>
}

func UpdateServerDate() <span class="cov8" title="1">{
        refreshServerDate()
        go func() </span><span class="cov8" title="1">{
                for </span><span class="cov8" title="1">{
                        time.Sleep(time.Second)
                        refreshServerDate()
                }</span>
        }()
}

func refreshServerDate() <span class="cov8" title="1">{
        b := bytesconv.AppendHTTPDate(make([]byte, 0, len(http.TimeFormat)), time.Now())
        ServerDate.Store(b)
}</span>

func getHeaderKeyBytes(kv *argsKV, key string, disableNormalizing bool) []byte <span class="cov8" title="1">{
        kv.key = append(kv.key[:0], key...)
        utils.NormalizeHeaderKey(kv.key, disableNormalizing)
        return kv.key
}</span>

// SetMethodBytes sets HTTP request method.
func (h *RequestHeader) SetMethodBytes(method []byte) <span class="cov8" title="1">{
        h.method = append(h.method[:0], method...)
}</span>

// DisableNormalizing disables header names' normalization.
//
// By default all the header names are normalized by uppercasing
// the first letter and all the first letters following dashes,
// while lowercasing all the other letters.
// Examples:
//
//   - CONNECTION -&gt; Connection
//   - conteNT-tYPE -&gt; Content-Type
//   - foo-bar-baz -&gt; Foo-Bar-Baz
//
// Disable header names' normalization only if you know what are you doing.
func (h *ResponseHeader) DisableNormalizing() <span class="cov0" title="0">{
        h.disableNormalizing = true
        h.Trailer().DisableNormalizing()
}</span>

// setSpecialHeader handles special headers and return true when a header is processed.
func (h *ResponseHeader) setSpecialHeader(key, value []byte) bool <span class="cov8" title="1">{
        if len(key) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">switch key[0] | 0x20 </span>{
        case 'c':<span class="cov8" title="1">
                if utils.CaseInsensitiveCompare(bytestr.StrContentType, key) </span><span class="cov8" title="1">{
                        h.SetContentTypeBytes(value)
                        return true
                }</span> else<span class="cov8" title="1"> if utils.CaseInsensitiveCompare(bytestr.StrContentLength, key) </span><span class="cov8" title="1">{
                        if contentLength, err := ParseContentLength(value); err == nil </span><span class="cov8" title="1">{
                                h.contentLength = contentLength
                                h.contentLengthBytes = append(h.contentLengthBytes[:0], value...)
                        }</span>
                        <span class="cov8" title="1">return true</span>
                } else<span class="cov8" title="1"> if utils.CaseInsensitiveCompare(bytestr.StrContentEncoding, key) </span><span class="cov8" title="1">{
                        h.SetContentEncodingBytes(value)
                        return true
                }</span> else<span class="cov8" title="1"> if utils.CaseInsensitiveCompare(bytestr.StrConnection, key) </span><span class="cov8" title="1">{
                        if bytes.Equal(bytestr.StrClose, value) </span><span class="cov8" title="1">{
                                h.SetConnectionClose(true)
                        }</span> else<span class="cov8" title="1"> {
                                h.ResetConnectionClose()
                                h.h = setArgBytes(h.h, key, value, ArgsHasValue)
                        }</span>
                        <span class="cov8" title="1">return true</span>
                }
        case 's':<span class="cov8" title="1">
                if utils.CaseInsensitiveCompare(bytestr.StrServer, key) </span><span class="cov8" title="1">{
                        h.SetServerBytes(value)
                        return true
                }</span> else<span class="cov8" title="1"> if utils.CaseInsensitiveCompare(bytestr.StrSetCookie, key) </span><span class="cov8" title="1">{
                        var kv *argsKV
                        h.cookies, kv = allocArg(h.cookies)
                        kv.key = getCookieKey(kv.key, value)
                        kv.value = append(kv.value[:0], value...)
                        return true
                }</span>
        case 't':<span class="cov8" title="1">
                if utils.CaseInsensitiveCompare(bytestr.StrTransferEncoding, key) </span><span class="cov8" title="1">{
                        // Transfer-Encoding is managed automatically.
                        return true
                }</span> else<span class="cov8" title="1"> if utils.CaseInsensitiveCompare(bytestr.StrTrailer, key) </span><span class="cov8" title="1">{
                        // copy value to avoid panic
                        value = append(h.bufKV.value[:0], value...)
                        h.Trailer().SetTrailers(value)
                        return true
                }</span>
        case 'd':<span class="cov0" title="0">
                if utils.CaseInsensitiveCompare(bytestr.StrDate, key) </span><span class="cov0" title="0">{
                        // Date is managed automatically.
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// setSpecialHeader handles special headers and return true when a header is processed.
func (h *RequestHeader) setSpecialHeader(key, value []byte) bool <span class="cov8" title="1">{
        if len(key) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">switch key[0] | 0x20 </span>{
        case 'c':<span class="cov8" title="1">
                if utils.CaseInsensitiveCompare(bytestr.StrContentType, key) </span><span class="cov8" title="1">{
                        h.SetContentTypeBytes(value)
                        return true
                }</span> else<span class="cov8" title="1"> if utils.CaseInsensitiveCompare(bytestr.StrContentLength, key) </span><span class="cov8" title="1">{
                        if contentLength, err := ParseContentLength(value); err == nil </span><span class="cov8" title="1">{
                                h.contentLength = contentLength
                                h.contentLengthBytes = append(h.contentLengthBytes[:0], value...)
                        }</span>
                        <span class="cov8" title="1">return true</span>
                } else<span class="cov8" title="1"> if utils.CaseInsensitiveCompare(bytestr.StrConnection, key) </span><span class="cov8" title="1">{
                        if bytes.Equal(bytestr.StrClose, value) </span><span class="cov8" title="1">{
                                h.SetConnectionClose(true)
                        }</span> else<span class="cov8" title="1"> {
                                h.ResetConnectionClose()
                                h.h = setArgBytes(h.h, key, value, ArgsHasValue)
                        }</span>
                        <span class="cov8" title="1">return true</span>
                } else<span class="cov8" title="1"> if utils.CaseInsensitiveCompare(bytestr.StrCookie, key) </span><span class="cov8" title="1">{
                        h.collectCookies()
                        h.cookies = parseRequestCookies(h.cookies, value)
                        return true
                }</span>
        case 't':<span class="cov8" title="1">
                if utils.CaseInsensitiveCompare(bytestr.StrTransferEncoding, key) </span><span class="cov0" title="0">{
                        // Transfer-Encoding is managed automatically.
                        return true
                }</span> else<span class="cov8" title="1"> if utils.CaseInsensitiveCompare(bytestr.StrTrailer, key) </span><span class="cov8" title="1">{
                        // copy value to avoid panic
                        value = append(h.bufKV.value[:0], value...)
                        h.Trailer().SetTrailers(value)
                        return true
                }</span>
        case 'h':<span class="cov8" title="1">
                if utils.CaseInsensitiveCompare(bytestr.StrHost, key) </span><span class="cov8" title="1">{
                        h.SetHostBytes(value)
                        return true
                }</span>
        case 'u':<span class="cov8" title="1">
                if utils.CaseInsensitiveCompare(bytestr.StrUserAgent, key) </span><span class="cov8" title="1">{
                        h.SetUserAgentBytes(value)
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// Trailer returns the Trailer of HTTP Header.
func (h *ResponseHeader) Trailer() *Trailer <span class="cov8" title="1">{
        if h.trailer == nil </span><span class="cov8" title="1">{
                h.trailer = new(Trailer)
        }</span>
        <span class="cov8" title="1">return h.trailer</span>
}

// Trailer returns the Trailer of HTTP Header.
func (h *RequestHeader) Trailer() *Trailer <span class="cov8" title="1">{
        if h.trailer == nil </span><span class="cov8" title="1">{
                h.trailer = new(Trailer)
        }</span>
        <span class="cov8" title="1">return h.trailer</span>
}

func (h *ResponseHeader) SetProtocol(p string) <span class="cov8" title="1">{
        h.protocol = p
}</span>

func (h *ResponseHeader) GetProtocol() string <span class="cov8" title="1">{
        return h.protocol
}</span>
</pre>
		
		<pre class="file" id="file78" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015-present Aliaksandr Valialkin, VertaMedia, Kirill Danshin, Erik Dubbelboer, FastHTTP Authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This file may have been modified by CloudWeGo authors. All CloudWeGo
 * Modifications are Copyright 2022 CloudWeGo Authors.
 */

package http1

import (
        "bytes"
        "context"
        "crypto/tls"
        "errors"
        "io"
        "net"
        "strings"
        "sync"
        "sync/atomic"
        "syscall"
        "time"

        "github.com/cloudwego/hertz/internal/bytesconv"
        "github.com/cloudwego/hertz/internal/bytestr"
        "github.com/cloudwego/hertz/internal/nocopy"
        "github.com/cloudwego/hertz/pkg/app/client/retry"
        "github.com/cloudwego/hertz/pkg/common/config"
        errs "github.com/cloudwego/hertz/pkg/common/errors"
        "github.com/cloudwego/hertz/pkg/common/hlog"
        "github.com/cloudwego/hertz/pkg/common/timer"
        "github.com/cloudwego/hertz/pkg/network"
        "github.com/cloudwego/hertz/pkg/network/dialer"
        "github.com/cloudwego/hertz/pkg/protocol"
        "github.com/cloudwego/hertz/pkg/protocol/client"
        "github.com/cloudwego/hertz/pkg/protocol/consts"
        "github.com/cloudwego/hertz/pkg/protocol/http1/proxy"
        reqI "github.com/cloudwego/hertz/pkg/protocol/http1/req"
        respI "github.com/cloudwego/hertz/pkg/protocol/http1/resp"
)

var (
        errConnectionClosed = errs.NewPublic("the server closed connection before returning the first response byte. " +
                "Make sure the server returns 'Connection: close' response header before closing the connection")

        errTimeout = errs.New(errs.ErrTimeout, errs.ErrorTypePublic, "host client")
)

// HostClient balances http requests among hosts listed in Addr.
//
// HostClient may be used for balancing load among multiple upstream hosts.
// While multiple addresses passed to HostClient.Addr may be used for balancing
// load among them, it would be better using LBClient instead, since HostClient
// may unevenly balance load among upstream hosts.
//
// It is forbidden copying HostClient instances. Create new instances instead.
//
// It is safe calling HostClient methods from concurrently running goroutines.
type HostClient struct {
        noCopy nocopy.NoCopy //lint:ignore U1000 until noCopy is used

        *ClientOptions

        // Comma-separated list of upstream HTTP server host addresses,
        // which are passed to Dialer in a round-robin manner.
        //
        // Each address may contain port if default dialer is used.
        // For example,
        //
        //    - foobar.com:80
        //    - foobar.com:443
        //    - foobar.com:8080
        Addr     string
        IsTLS    bool
        ProxyURI *protocol.URI

        clientName  atomic.Value
        lastUseTime uint32

        connsLock  sync.Mutex
        connsCount int
        conns      []*clientConn
        connsWait  *wantConnQueue

        addrsLock sync.Mutex
        addrs     []string
        addrIdx   uint32

        tlsConfigMap     map[string]*tls.Config
        tlsConfigMapLock sync.Mutex

        pendingRequests int32

        connsCleanerRun bool

        closed chan struct{}
}

func (c *HostClient) SetDynamicConfig(dc *client.DynamicConfig) <span class="cov8" title="1">{
        c.Addr = dc.Addr
        c.ProxyURI = dc.ProxyURI
        c.IsTLS = dc.IsTLS

        // start observation after setting addr to avoid race
        if c.StateObserve != nil </span><span class="cov8" title="1">{
                go func() </span><span class="cov8" title="1">{
                        t := time.NewTicker(c.ObservationInterval)
                        for </span><span class="cov8" title="1">{
                                select </span>{
                                case &lt;-c.closed:<span class="cov8" title="1">
                                        return</span>
                                case &lt;-t.C:<span class="cov8" title="1">
                                        c.StateObserve(c)</span>
                                }
                        }
                }()
        }
}

type clientConn struct {
        c network.Conn

        createdTime time.Time
        lastUseTime time.Time
}

var startTimeUnix = time.Now().Unix()

// LastUseTime returns time the client was last used
func (c *HostClient) LastUseTime() time.Time <span class="cov0" title="0">{
        n := atomic.LoadUint32(&amp;c.lastUseTime)
        return time.Unix(startTimeUnix+int64(n), 0)
}</span>

// Get returns the status code and body of url.
//
// The contents of dst will be replaced by the body and returned, if the dst
// is too small a new slice will be allocated.
//
// The function follows redirects. Use Do* for manually handling redirects.
func (c *HostClient) Get(ctx context.Context, dst []byte, url string) (statusCode int, body []byte, err error) <span class="cov0" title="0">{
        return client.GetURL(ctx, dst, url, c)
}</span>

func (c *HostClient) ConnectionCount() (count int) <span class="cov8" title="1">{
        c.connsLock.Lock()
        count = len(c.conns)
        c.connsLock.Unlock()
        return
}</span>

func (c *HostClient) WantConnectionCount() (count int) <span class="cov8" title="1">{
        return c.connsWait.len()
}</span>

func (c *HostClient) ConnPoolState() config.ConnPoolState <span class="cov8" title="1">{
        c.connsLock.Lock()
        defer c.connsLock.Unlock()
        cps := config.ConnPoolState{
                PoolConnNum:  len(c.conns),
                TotalConnNum: c.connsCount,
                Addr:         c.Addr,
        }

        if c.connsWait != nil </span><span class="cov0" title="0">{
                cps.WaitConnNum = c.connsWait.len()
        }</span>
        <span class="cov8" title="1">return cps</span>
}

// GetTimeout returns the status code and body of url.
//
// The contents of dst will be replaced by the body and returned, if the dst
// is too small a new slice will be allocated.
//
// The function follows redirects. Use Do* for manually handling redirects.
//
// errTimeout error is returned if url contents couldn't be fetched
// during the given timeout.
func (c *HostClient) GetTimeout(ctx context.Context, dst []byte, url string, timeout time.Duration) (statusCode int, body []byte, err error) <span class="cov0" title="0">{
        return client.GetURLTimeout(ctx, dst, url, timeout, c)
}</span>

// GetDeadline returns the status code and body of url.
//
// The contents of dst will be replaced by the body and returned, if the dst
// is too small a new slice will be allocated.
//
// The function follows redirects. Use Do* for manually handling redirects.
//
// errTimeout error is returned if url contents couldn't be fetched
// until the given deadline.
func (c *HostClient) GetDeadline(ctx context.Context, dst []byte, url string, deadline time.Time) (statusCode int, body []byte, err error) <span class="cov0" title="0">{
        return client.GetURLDeadline(ctx, dst, url, deadline, c)
}</span>

// Post sends POST request to the given url with the given POST arguments.
//
// The contents of dst will be replaced by the body and returned, if the dst
// is too small a new slice will be allocated.
//
// The function follows redirects. Use Do* for manually handling redirects.
//
// Empty POST body is sent if postArgs is nil.
func (c *HostClient) Post(ctx context.Context, dst []byte, url string, postArgs *protocol.Args) (statusCode int, body []byte, err error) <span class="cov0" title="0">{
        return client.PostURL(ctx, dst, url, postArgs, c)
}</span>

// A wantConnQueue is a queue of wantConns.
//
// inspired by net/http/transport.go
type wantConnQueue struct {
        // This is a queue, not a deque.
        // It is split into two stages - head[headPos:] and tail.
        // popFront is trivial (headPos++) on the first stage, and
        // pushBack is trivial (append) on the second stage.
        // If the first stage is empty, popFront can swap the
        // first and second stages to remedy the situation.
        //
        // This two-stage split is analogous to the use of two lists
        // in Okasaki's purely functional queue but without the
        // overhead of reversing the list when swapping stages.
        head    []*wantConn
        headPos int
        tail    []*wantConn
}

// A wantConn records state about a wanted connection
// (that is, an active call to getConn).
// The conn may be gotten by dialing or by finding an idle connection,
// or a cancellation may make the conn no longer wanted.
// These three options are racing against each other and use
// wantConn to coordinate and agree about the winning outcome.
//
// inspired by net/http/transport.go
type wantConn struct {
        ready chan struct{}
        mu    sync.Mutex // protects conn, err, close(ready)
        conn  *clientConn
        err   error
}

// DoTimeout performs the given request and waits for response during
// the given timeout duration.
//
// Request must contain at least non-zero RequestURI with full url (including
// scheme and host) or non-zero Host header + RequestURI.
//
// The function doesn't follow redirects. Use Get* for following redirects.
//
// Response is ignored if resp is nil.
//
// errTimeout is returned if the response wasn't returned during
// the given timeout.
//
// ErrNoFreeConns is returned if all HostClient.MaxConns connections
// to the host are busy.
//
// It is recommended obtaining req and resp via AcquireRequest
// and AcquireResponse in performance-critical code.
//
// Warning: DoTimeout does not terminate the request itself. The request will
// continue in the background and the response will be discarded.
// If requests take too long and the connection pool gets filled up please
// try setting a ReadTimeout.
func (c *HostClient) DoTimeout(ctx context.Context, req *protocol.Request, resp *protocol.Response, timeout time.Duration) error <span class="cov0" title="0">{
        return client.DoTimeout(ctx, req, resp, timeout, c)
}</span>

// DoDeadline performs the given request and waits for response until
// the given deadline.
//
// Request must contain at least non-zero RequestURI with full url (including
// scheme and host) or non-zero Host header + RequestURI.
//
// The function doesn't follow redirects. Use Get* for following redirects.
//
// Response is ignored if resp is nil.
//
// errTimeout is returned if the response wasn't returned until
// the given deadline.
//
// ErrNoFreeConns is returned if all HostClient.MaxConns connections
// to the host are busy.
//
// It is recommended obtaining req and resp via AcquireRequest
// and AcquireResponse in performance-critical code.
func (c *HostClient) DoDeadline(ctx context.Context, req *protocol.Request, resp *protocol.Response, deadline time.Time) error <span class="cov8" title="1">{
        return client.DoDeadline(ctx, req, resp, deadline, c)
}</span>

// DoRedirects performs the given http request and fills the given http response,
// following up to maxRedirectsCount redirects. When the redirect count exceeds
// maxRedirectsCount, ErrTooManyRedirects is returned.
//
// Request must contain at least non-zero RequestURI with full url (including
// scheme and host) or non-zero Host header + RequestURI.
//
// Client determines the server to be requested in the following order:
//
//   - from RequestURI if it contains full url with scheme and host;
//   - from Host header otherwise.
//
// Response is ignored if resp is nil.
//
// ErrNoFreeConns is returned if all DefaultMaxConnsPerHost connections
// to the requested host are busy.
//
// It is recommended obtaining req and resp via AcquireRequest
// and AcquireResponse in performance-critical code.
func (c *HostClient) DoRedirects(ctx context.Context, req *protocol.Request, resp *protocol.Response, maxRedirectsCount int) error <span class="cov0" title="0">{
        _, _, err := client.DoRequestFollowRedirects(ctx, req, resp, req.URI().String(), maxRedirectsCount, c)
        return err
}</span>

// Do performs the given http request and sets the corresponding response.
//
// Request must contain at least non-zero RequestURI with full url (including
// scheme and host) or non-zero Host header + RequestURI.
//
// The function doesn't follow redirects. Use Get* for following redirects.
//
// Response is ignored if resp is nil.
//
// ErrNoFreeConns is returned if all HostClient.MaxConns connections
// to the host are busy.
//
// It is recommended obtaining req and resp via AcquireRequest
// and AcquireResponse in performance-critical code.
func (c *HostClient) Do(ctx context.Context, req *protocol.Request, resp *protocol.Response) error <span class="cov8" title="1">{
        var (
                err                error
                canIdempotentRetry bool
                isDefaultRetryFunc                    = true
                attempts           uint               = 0
                connAttempts       uint               = 0
                maxAttempts        uint               = 1
                isRequestRetryable client.RetryIfFunc = client.DefaultRetryIf
        )
        retryCfg := c.ClientOptions.RetryConfig
        if retryCfg != nil </span><span class="cov8" title="1">{
                maxAttempts = retryCfg.MaxAttemptTimes
        }</span>

        <span class="cov8" title="1">if c.ClientOptions.RetryIfFunc != nil </span><span class="cov8" title="1">{
                isRequestRetryable = c.ClientOptions.RetryIfFunc
                // if the user has provided a custom retry function, the canIdempotentRetry has no meaning anymore.
                // User will have full control over the retry logic through the custom retry function.
                isDefaultRetryFunc = false
        }</span>

        <span class="cov8" title="1">atomic.AddInt32(&amp;c.pendingRequests, 1)
        req.Options().StartRequest()
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        req.CloseBodyStream() //nolint:errcheck
                        return ctx.Err()</span>
                default:<span class="cov8" title="1"></span>
                }

                <span class="cov8" title="1">canIdempotentRetry, err = c.do(req, resp)
                // If there is no custom retry and err is equal to nil, the loop simply exits.
                if err == nil &amp;&amp; isDefaultRetryFunc </span><span class="cov8" title="1">{
                        if connAttempts != 0 </span><span class="cov8" title="1">{
                                hlog.SystemLogger().Warnf("Client connection attempt times: %d, url: %s. "+
                                        "This is mainly because the connection in pool is closed by peer in advance. "+
                                        "If this number is too high which indicates that long-connection are basically unavailable, "+
                                        "try to change the request to short-connection.\n", connAttempts, req.URI().FullURI())
                        }</span>
                        <span class="cov8" title="1">break</span>
                }

                // This connection is closed by the peer when it is in the connection pool.
                //
                // This case is possible if the server closes the idle
                // keep-alive connection on timeout.
                //
                // Apache and nginx usually do this.
                <span class="cov8" title="1">if canIdempotentRetry &amp;&amp; client.DefaultRetryIf(req, resp, err) &amp;&amp; errors.Is(err, errs.ErrBadPoolConn) </span><span class="cov8" title="1">{
                        connAttempts++
                        continue</span>
                }

                <span class="cov8" title="1">if isDefaultRetryFunc </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">attempts++
                if attempts &gt;= maxAttempts </span><span class="cov0" title="0">{
                        break</span>
                }

                // Check whether this request should be retried
                <span class="cov8" title="1">if !isRequestRetryable(req, resp, err) </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">wait := retry.Delay(attempts, err, retryCfg)
                // Retry after wait time
                time.Sleep(wait)</span>
        }
        <span class="cov8" title="1">atomic.AddInt32(&amp;c.pendingRequests, -1)

        if err == io.EOF </span><span class="cov0" title="0">{
                err = errConnectionClosed
        }</span>
        <span class="cov8" title="1">return err</span>
}

// PendingRequests returns the current number of requests the client
// is executing.
//
// This function may be used for balancing load among multiple HostClient
// instances.
func (c *HostClient) PendingRequests() int <span class="cov0" title="0">{
        return int(atomic.LoadInt32(&amp;c.pendingRequests))
}</span>

func (c *HostClient) do(req *protocol.Request, resp *protocol.Response) (bool, error) <span class="cov8" title="1">{
        nilResp := false
        if resp == nil </span><span class="cov0" title="0">{
                nilResp = true
                resp = protocol.AcquireResponse()
        }</span>

        <span class="cov8" title="1">canIdempotentRetry, err := c.doNonNilReqResp(req, resp)

        if nilResp </span><span class="cov0" title="0">{
                protocol.ReleaseResponse(resp)
        }</span>

        <span class="cov8" title="1">return canIdempotentRetry, err</span>
}

type requestConfig struct {
        dialTimeout  time.Duration
        readTimeout  time.Duration
        writeTimeout time.Duration
}

func (c *HostClient) preHandleConfig(o *config.RequestOptions) requestConfig <span class="cov8" title="1">{
        rc := requestConfig{
                dialTimeout:  c.DialTimeout,
                readTimeout:  c.ReadTimeout,
                writeTimeout: c.WriteTimeout,
        }
        if o.ReadTimeout() &gt; 0 </span><span class="cov8" title="1">{
                rc.readTimeout = o.ReadTimeout()
        }</span>

        <span class="cov8" title="1">if o.WriteTimeout() &gt; 0 </span><span class="cov8" title="1">{
                rc.writeTimeout = o.WriteTimeout()
        }</span>

        <span class="cov8" title="1">if o.DialTimeout() &gt; 0 </span><span class="cov8" title="1">{
                rc.dialTimeout = o.DialTimeout()
        }</span>

        <span class="cov8" title="1">return rc</span>
}

func updateReqTimeout(reqTimeout, compareTimeout time.Duration, before time.Time) (shouldCloseConn bool, timeout time.Duration) <span class="cov8" title="1">{
        if reqTimeout &lt;= 0 </span><span class="cov8" title="1">{
                return false, compareTimeout
        }</span>
        <span class="cov8" title="1">left := reqTimeout - time.Since(before)
        if left &lt;= 0 </span><span class="cov8" title="1">{
                return true, 0
        }</span>

        <span class="cov8" title="1">if compareTimeout &lt;= 0 </span><span class="cov8" title="1">{
                return false, left
        }</span>

        <span class="cov0" title="0">if left &gt; compareTimeout </span><span class="cov0" title="0">{
                return false, compareTimeout
        }</span>

        <span class="cov0" title="0">return false, left</span>
}

func (c *HostClient) doNonNilReqResp(req *protocol.Request, resp *protocol.Response) (bool, error) <span class="cov8" title="1">{
        if req == nil </span><span class="cov0" title="0">{
                panic("BUG: req cannot be nil")</span>
        }
        <span class="cov8" title="1">if resp == nil </span><span class="cov0" title="0">{
                panic("BUG: resp cannot be nil")</span>
        }

        <span class="cov8" title="1">atomic.StoreUint32(&amp;c.lastUseTime, uint32(time.Now().Unix()-startTimeUnix))

        rc := c.preHandleConfig(req.Options())

        // Free up resources occupied by response before sending the request,
        // so the GC may reclaim these resources (e.g. response body).
        // backing up SkipBody in case it was set explicitly
        customSkipBody := resp.SkipBody
        resp.Reset()
        resp.SkipBody = customSkipBody

        if c.DisablePathNormalizing </span><span class="cov0" title="0">{
                req.URI().DisablePathNormalizing = true
        }</span>
        <span class="cov8" title="1">reqTimeout := req.Options().RequestTimeout()
        begin := req.Options().StartTime()

        dialTimeout := rc.dialTimeout
        if (reqTimeout &gt; 0 &amp;&amp; reqTimeout &lt; dialTimeout) || dialTimeout == 0 </span><span class="cov8" title="1">{
                dialTimeout = reqTimeout
        }</span>
        <span class="cov8" title="1">cc, inPool, err := c.acquireConn(dialTimeout)
        // if getting connection error, fast fail
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>
        <span class="cov8" title="1">conn := cc.c

        usingProxy := false
        if c.ProxyURI != nil &amp;&amp; bytes.Equal(req.Scheme(), bytestr.StrHTTP) </span><span class="cov0" title="0">{
                usingProxy = true
                proxy.SetProxyAuthHeader(&amp;req.Header, c.ProxyURI)
        }</span>

        <span class="cov8" title="1">resp.ParseNetAddr(conn)

        shouldClose, timeout := updateReqTimeout(reqTimeout, rc.writeTimeout, begin)
        if shouldClose </span><span class="cov8" title="1">{
                c.closeConn(cc)
                return false, errTimeout
        }</span>

        <span class="cov8" title="1">if err = conn.SetWriteTimeout(timeout); err != nil </span><span class="cov8" title="1">{
                c.closeConn(cc)
                // try another connection if retry is enabled
                return true, err
        }</span>

        <span class="cov8" title="1">resetConnection := false
        if c.MaxConnDuration &gt; 0 &amp;&amp; time.Since(cc.createdTime) &gt; c.MaxConnDuration &amp;&amp; !req.ConnectionClose() </span><span class="cov0" title="0">{
                req.SetConnectionClose()
                resetConnection = true
        }</span>

        <span class="cov8" title="1">userAgentOld := req.Header.UserAgent()
        if len(userAgentOld) == 0 </span><span class="cov8" title="1">{
                req.Header.SetUserAgentBytes(c.getClientName())
        }</span>
        <span class="cov8" title="1">zw := c.acquireWriter(conn)

        if !usingProxy </span><span class="cov8" title="1">{
                err = reqI.Write(req, zw)
        }</span> else<span class="cov0" title="0"> {
                err = reqI.ProxyWrite(req, zw)
        }</span>
        <span class="cov8" title="1">if resetConnection </span><span class="cov0" title="0">{
                req.Header.ResetConnectionClose()
        }</span>

        <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                err = zw.Flush()
        }</span>
        // error happened when writing request, close the connection, and try another connection if retry is enabled
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                defer c.closeConn(cc)

                errNorm, ok := conn.(network.ErrorNormalization)
                if ok </span><span class="cov0" title="0">{
                        err = errNorm.ToHertzError(err)
                }</span>

                <span class="cov8" title="1">if !errors.Is(err, errs.ErrConnectionClosed) </span><span class="cov8" title="1">{
                        return true, err
                }</span>

                // set a protection timeout to avoid infinite loop.
                <span class="cov8" title="1">if conn.SetReadTimeout(time.Second) != nil </span><span class="cov0" title="0">{
                        return true, err
                }</span>

                // Only if the connection is closed while writing the request. Try to parse the response and return.
                // In this case, the request/response is considered as successful.
                // Otherwise, return the former error.
                <span class="cov8" title="1">zr := c.acquireReader(conn)
                defer zr.Release()
                if respI.ReadHeaderAndLimitBody(resp, zr, c.MaxResponseBodySize) == nil </span><span class="cov8" title="1">{
                        return false, nil
                }</span>

                <span class="cov8" title="1">if inPool </span><span class="cov8" title="1">{
                        err = errs.ErrBadPoolConn
                }</span>

                <span class="cov8" title="1">return true, err</span>
        }

        <span class="cov8" title="1">shouldClose, timeout = updateReqTimeout(reqTimeout, rc.readTimeout, begin)
        if shouldClose </span><span class="cov0" title="0">{
                c.closeConn(cc)
                return false, errTimeout
        }</span>

        // Set Deadline every time, since golang has fixed the performance issue
        // See https://github.com/golang/go/issues/15133#issuecomment-271571395 for details
        <span class="cov8" title="1">if err = conn.SetReadTimeout(timeout); err != nil </span><span class="cov0" title="0">{
                c.closeConn(cc)
                // try another connection if retry is enabled
                return true, err
        }</span>

        <span class="cov8" title="1">if customSkipBody || req.Header.IsHead() || req.Header.IsConnect() </span><span class="cov0" title="0">{
                resp.SkipBody = true
        }</span>
        <span class="cov8" title="1">if c.DisableHeaderNamesNormalizing </span><span class="cov0" title="0">{
                resp.Header.DisableNormalizing()
        }</span>
        <span class="cov8" title="1">zr := c.acquireReader(conn)

        // errs.ErrBadPoolConn error are returned when the
        // 1 byte peek read fails, and we're actually anticipating a response.
        // Usually this is just due to the inherent keep-alive shut down race,
        // where the server closed the connection at the same time the client
        // wrote. The underlying err field is usually io.EOF or some
        // ECONNRESET sort of thing which varies by platform.
        _, err = zr.Peek(1)
        if err != nil </span><span class="cov8" title="1">{
                zr.Release() //nolint:errcheck
                c.closeConn(cc)
                if inPool &amp;&amp; (err == io.EOF || err == syscall.ECONNRESET) </span><span class="cov0" title="0">{
                        return true, errs.ErrBadPoolConn
                }</span>
                // if this is not a pooled connection,
                // we should not retry to avoid getting stuck in an endless retry loop.
                <span class="cov8" title="1">errNorm, ok := conn.(network.ErrorNormalization)
                if ok </span><span class="cov0" title="0">{
                        err = errNorm.ToHertzError(err)
                }</span>
                <span class="cov8" title="1">return false, err</span>
        }

        // init here for passing in ReadBodyStream's closure
        // and this value will be assigned after reading Response's Header
        //
        // This is to solve the circular dependency problem of Response and BodyStream
        <span class="cov8" title="1">shouldCloseConn := false

        if !c.ResponseBodyStream </span><span class="cov8" title="1">{
                err = respI.ReadHeaderAndLimitBody(resp, zr, c.MaxResponseBodySize)
        }</span> else<span class="cov8" title="1"> {
                err = respI.ReadBodyStream(resp, zr, c.MaxResponseBodySize, func(shouldClose bool) error </span><span class="cov8" title="1">{
                        if shouldCloseConn || shouldClose </span><span class="cov0" title="0">{
                                c.closeConn(cc)
                        }</span> else<span class="cov8" title="1"> {
                                c.releaseConn(cc)
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                })
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                zr.Release() //nolint:errcheck
                c.closeConn(cc)
                // Don't retry in case of ErrBodyTooLarge since we will just get the same again.
                retry := !errors.Is(err, errs.ErrBodyTooLarge)
                return retry, err
        }</span>

        <span class="cov8" title="1">zr.Release() //nolint:errcheck

        shouldCloseConn = resetConnection || req.ConnectionClose() || resp.ConnectionClose()

        // In stream mode, we still can close/release the connection immediately if there is no content on the wire.
        if c.ResponseBodyStream &amp;&amp; resp.BodyStream() != protocol.NoResponseBody </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">if shouldCloseConn </span><span class="cov8" title="1">{
                c.closeConn(cc)
        }</span> else<span class="cov8" title="1"> {
                c.releaseConn(cc)
        }</span>

        <span class="cov8" title="1">return false, err</span>
}

func (c *HostClient) Close() error <span class="cov8" title="1">{
        close(c.closed)
        return nil
}</span>

// SetMaxConns sets up the maximum number of connections which may be established to all hosts listed in Addr.
func (c *HostClient) SetMaxConns(newMaxConns int) <span class="cov0" title="0">{
        c.connsLock.Lock()
        c.MaxConns = newMaxConns
        c.connsLock.Unlock()
}</span>

func (c *HostClient) acquireConn(dialTimeout time.Duration) (cc *clientConn, inPool bool, err error) <span class="cov8" title="1">{
        createConn := false
        startCleaner := false

        var n int
        c.connsLock.Lock()
        n = len(c.conns)
        if n == 0 </span><span class="cov8" title="1">{
                maxConns := c.MaxConns
                if maxConns &lt;= 0 </span><span class="cov8" title="1">{
                        maxConns = consts.DefaultMaxConnsPerHost
                }</span>
                <span class="cov8" title="1">if c.connsCount &lt; maxConns </span><span class="cov8" title="1">{
                        c.connsCount++
                        createConn = true
                        if !c.connsCleanerRun </span><span class="cov8" title="1">{
                                startCleaner = true
                                c.connsCleanerRun = true
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                n--
                cc = c.conns[n]
                c.conns[n] = nil
                c.conns = c.conns[:n]
        }</span>
        <span class="cov8" title="1">c.connsLock.Unlock()

        if cc != nil </span><span class="cov8" title="1">{
                return cc, true, nil
        }</span>
        <span class="cov8" title="1">if !createConn </span><span class="cov8" title="1">{
                if c.MaxConnWaitTimeout &lt;= 0 </span><span class="cov0" title="0">{
                        return nil, true, errs.ErrNoFreeConns
                }</span>

                <span class="cov8" title="1">timeout := c.MaxConnWaitTimeout

                // wait for a free connection
                tc := timer.AcquireTimer(timeout)
                defer timer.ReleaseTimer(tc)

                w := &amp;wantConn{
                        ready: make(chan struct{}, 1),
                }
                defer func() </span><span class="cov8" title="1">{
                        if err != nil </span><span class="cov8" title="1">{
                                w.cancel(c, err)
                        }</span>
                }()

                // Note: In the case of setting MaxConnWaitTimeout, if the number
                // of connections in the connection pool exceeds the maximum
                // number of connections and needs to establish a connection while
                // waiting, the dialtimeout on the hostclient is used instead of
                // the dialtimeout in request options.
                <span class="cov8" title="1">c.queueForIdle(w)

                select </span>{
                case &lt;-w.ready:<span class="cov8" title="1">
                        return w.conn, true, w.err</span>
                case &lt;-tc.C:<span class="cov8" title="1">
                        return nil, true, errs.ErrNoFreeConns</span>
                }
        }

        <span class="cov8" title="1">if startCleaner </span><span class="cov8" title="1">{
                go c.connsCleaner()
        }</span>

        <span class="cov8" title="1">conn, err := c.dialHostHard(dialTimeout)
        if err != nil </span><span class="cov8" title="1">{
                c.decConnsCount()
                return nil, false, err
        }</span>
        <span class="cov8" title="1">cc = acquireClientConn(conn)

        return cc, false, nil</span>
}

func (c *HostClient) queueForIdle(w *wantConn) <span class="cov8" title="1">{
        c.connsLock.Lock()
        defer c.connsLock.Unlock()
        if c.connsWait == nil </span><span class="cov8" title="1">{
                c.connsWait = &amp;wantConnQueue{}
        }</span>
        <span class="cov8" title="1">c.connsWait.clearFront()
        c.connsWait.pushBack(w)</span>
}

func (c *HostClient) dialConnFor(w *wantConn) <span class="cov8" title="1">{
        conn, err := c.dialHostHard(c.DialTimeout)
        if err != nil </span><span class="cov0" title="0">{
                w.tryDeliver(nil, err)
                c.decConnsCount()
                return
        }</span>

        <span class="cov8" title="1">cc := acquireClientConn(conn)
        delivered := w.tryDeliver(cc, nil)
        if !delivered </span><span class="cov0" title="0">{
                // not delivered, return idle connection
                c.releaseConn(cc)
        }</span>
}

// CloseIdleConnections closes any connections which were previously
// connected from previous requests but are now sitting idle in a
// "keep-alive" state. It does not interrupt any connections currently
// in use.
func (c *HostClient) CloseIdleConnections() <span class="cov8" title="1">{
        c.connsLock.Lock()
        scratch := append([]*clientConn{}, c.conns...)
        for i := range c.conns </span><span class="cov8" title="1">{
                c.conns[i] = nil
        }</span>
        <span class="cov8" title="1">c.conns = c.conns[:0]
        c.connsLock.Unlock()

        for _, cc := range scratch </span><span class="cov8" title="1">{
                c.closeConn(cc)
        }</span>
}

func (c *HostClient) ShouldRemove() bool <span class="cov0" title="0">{
        c.connsLock.Lock()
        defer c.connsLock.Unlock()
        return c.connsCount == 0
}</span>

func (c *HostClient) connsCleaner() <span class="cov8" title="1">{
        var (
                scratch             []*clientConn
                maxIdleConnDuration = c.MaxIdleConnDuration
        )
        if maxIdleConnDuration &lt;= 0 </span><span class="cov8" title="1">{
                maxIdleConnDuration = consts.DefaultMaxIdleConnDuration
        }</span>
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                currentTime := time.Now()

                // Determine idle connections to be closed.
                c.connsLock.Lock()
                conns := c.conns
                n := len(conns)
                i := 0

                for i &lt; n &amp;&amp; currentTime.Sub(conns[i].lastUseTime) &gt; maxIdleConnDuration </span><span class="cov0" title="0">{
                        i++
                }</span>
                <span class="cov8" title="1">sleepFor := maxIdleConnDuration
                if i &lt; n </span><span class="cov8" title="1">{
                        // + 1 so we actually sleep past the expiration time and not up to it.
                        // Otherwise the &gt; check above would still fail.
                        sleepFor = maxIdleConnDuration - currentTime.Sub(conns[i].lastUseTime) + 1
                }</span>
                <span class="cov8" title="1">scratch = append(scratch[:0], conns[:i]...)
                if i &gt; 0 </span><span class="cov0" title="0">{
                        m := copy(conns, conns[i:])
                        for i = m; i &lt; n; i++ </span><span class="cov0" title="0">{
                                conns[i] = nil
                        }</span>
                        <span class="cov0" title="0">c.conns = conns[:m]</span>
                }
                <span class="cov8" title="1">c.connsLock.Unlock()

                // Close idle connections.
                for i, cc := range scratch </span><span class="cov0" title="0">{
                        c.closeConn(cc)
                        scratch[i] = nil
                }</span>

                // Determine whether to stop the connsCleaner.
                <span class="cov8" title="1">c.connsLock.Lock()
                mustStop := c.connsCount == 0
                if mustStop </span><span class="cov8" title="1">{
                        c.connsCleanerRun = false
                }</span>
                <span class="cov8" title="1">c.connsLock.Unlock()
                if mustStop </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">time.Sleep(sleepFor)</span>
        }
}

func (c *HostClient) closeConn(cc *clientConn) <span class="cov8" title="1">{
        c.decConnsCount()
        cc.c.Close()
        releaseClientConn(cc)
}</span>

func (c *HostClient) decConnsCount() <span class="cov8" title="1">{
        if c.MaxConnWaitTimeout &lt;= 0 </span><span class="cov8" title="1">{
                c.connsLock.Lock()
                c.connsCount--
                c.connsLock.Unlock()
                return
        }</span>

        <span class="cov8" title="1">c.connsLock.Lock()
        defer c.connsLock.Unlock()
        dialed := false
        if q := c.connsWait; q != nil &amp;&amp; q.len() &gt; 0 </span><span class="cov8" title="1">{
                for q.len() &gt; 0 </span><span class="cov8" title="1">{
                        w := q.popFront()
                        if w.waiting() </span><span class="cov8" title="1">{
                                go c.dialConnFor(w)
                                dialed = true
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">if !dialed </span><span class="cov8" title="1">{
                c.connsCount--
        }</span>
}

func acquireClientConn(conn network.Conn) *clientConn <span class="cov8" title="1">{
        v := clientConnPool.Get()
        if v == nil </span><span class="cov8" title="1">{
                v = &amp;clientConn{}
        }</span>
        <span class="cov8" title="1">cc := v.(*clientConn)
        cc.c = conn
        cc.createdTime = time.Now()
        return cc</span>
}

func releaseClientConn(cc *clientConn) <span class="cov8" title="1">{
        // Reset all fields.
        *cc = clientConn{}
        clientConnPool.Put(cc)
}</span>

var clientConnPool sync.Pool

func (c *HostClient) releaseConn(cc *clientConn) <span class="cov8" title="1">{
        cc.lastUseTime = time.Now()
        if c.MaxConnWaitTimeout &lt;= 0 </span><span class="cov8" title="1">{
                c.connsLock.Lock()
                c.conns = append(c.conns, cc)
                c.connsLock.Unlock()
                return
        }</span>

        // try to deliver an idle connection to a *wantConn
        <span class="cov8" title="1">c.connsLock.Lock()
        defer c.connsLock.Unlock()
        delivered := false
        if q := c.connsWait; q != nil &amp;&amp; q.len() &gt; 0 </span><span class="cov8" title="1">{
                for q.len() &gt; 0 </span><span class="cov8" title="1">{
                        w := q.popFront()
                        if w.waiting() </span><span class="cov0" title="0">{
                                delivered = w.tryDeliver(cc, nil)
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">if !delivered </span><span class="cov8" title="1">{
                c.conns = append(c.conns, cc)
        }</span>
}

func (c *HostClient) acquireWriter(conn network.Conn) network.Writer <span class="cov8" title="1">{
        return conn
}</span>

func (c *HostClient) acquireReader(conn network.Conn) network.Reader <span class="cov8" title="1">{
        return conn
}</span>

func newClientTLSConfig(c *tls.Config, addr string) *tls.Config <span class="cov8" title="1">{
        if c == nil </span><span class="cov0" title="0">{
                c = &amp;tls.Config{}
        }</span> else<span class="cov8" title="1"> {
                c = c.Clone()
        }</span>

        <span class="cov8" title="1">if c.ClientSessionCache == nil </span><span class="cov8" title="1">{
                c.ClientSessionCache = tls.NewLRUClientSessionCache(0)
        }</span>

        <span class="cov8" title="1">if len(c.ServerName) == 0 </span><span class="cov8" title="1">{
                serverName := tlsServerName(addr)
                if serverName == "*" </span><span class="cov0" title="0">{
                        c.InsecureSkipVerify = true
                }</span> else<span class="cov8" title="1"> {
                        c.ServerName = serverName
                }</span>
        }
        <span class="cov8" title="1">return c</span>
}

func tlsServerName(addr string) string <span class="cov8" title="1">{
        if !strings.Contains(addr, ":") </span><span class="cov8" title="1">{
                return addr
        }</span>
        <span class="cov0" title="0">host, _, err := net.SplitHostPort(addr)
        if err != nil </span><span class="cov0" title="0">{
                return "*"
        }</span>
        <span class="cov0" title="0">return host</span>
}

func (c *HostClient) nextAddr() string <span class="cov8" title="1">{
        c.addrsLock.Lock()
        if c.addrs == nil </span><span class="cov8" title="1">{
                c.addrs = strings.Split(c.Addr, ",")
        }</span>
        <span class="cov8" title="1">addr := c.addrs[0]
        if len(c.addrs) &gt; 1 </span><span class="cov0" title="0">{
                addr = c.addrs[c.addrIdx%uint32(len(c.addrs))]
                c.addrIdx++
        }</span>
        <span class="cov8" title="1">c.addrsLock.Unlock()
        return addr</span>
}

func (c *HostClient) dialHostHard(dialTimeout time.Duration) (conn network.Conn, err error) <span class="cov8" title="1">{
        // attempt to dial all the available hosts before giving up.

        c.addrsLock.Lock()
        n := len(c.addrs)
        c.addrsLock.Unlock()

        if n == 0 </span><span class="cov8" title="1">{
                // It looks like c.addrs isn't initialized yet.
                n = 1
        }</span>

        <span class="cov8" title="1">deadline := time.Now().Add(dialTimeout)
        for n &gt; 0 </span><span class="cov8" title="1">{
                addr := c.nextAddr()
                tlsConfig := c.cachedTLSConfig(addr)
                conn, err = dialAddr(addr, c.Dialer, c.DialDualStack, tlsConfig, dialTimeout, c.ProxyURI, c.IsTLS)
                if err == nil </span><span class="cov8" title="1">{
                        return conn, nil
                }</span>
                <span class="cov8" title="1">if time.Since(deadline) &gt;= 0 </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">n--</span>
        }
        <span class="cov8" title="1">return nil, err</span>
}

func (c *HostClient) cachedTLSConfig(addr string) *tls.Config <span class="cov8" title="1">{
        var cfgAddr string
        if c.ProxyURI != nil &amp;&amp; bytes.Equal(c.ProxyURI.Scheme(), bytestr.StrHTTPS) </span><span class="cov0" title="0">{
                cfgAddr = bytesconv.B2s(c.ProxyURI.Host())
        }</span>

        <span class="cov8" title="1">if c.IsTLS &amp;&amp; cfgAddr == "" </span><span class="cov8" title="1">{
                cfgAddr = addr
        }</span>

        <span class="cov8" title="1">if cfgAddr == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">c.tlsConfigMapLock.Lock()
        if c.tlsConfigMap == nil </span><span class="cov8" title="1">{
                c.tlsConfigMap = make(map[string]*tls.Config)
        }</span>
        <span class="cov8" title="1">cfg := c.tlsConfigMap[cfgAddr]
        if cfg == nil </span><span class="cov8" title="1">{
                cfg = newClientTLSConfig(c.TLSConfig, cfgAddr)
                c.tlsConfigMap[cfgAddr] = cfg
        }</span>
        <span class="cov8" title="1">c.tlsConfigMapLock.Unlock()

        return cfg</span>
}

func dialAddr(addr string, dial network.Dialer, dialDualStack bool, tlsConfig *tls.Config, timeout time.Duration, proxyURI *protocol.URI, isTLS bool) (network.Conn, error) <span class="cov8" title="1">{
        var conn network.Conn
        var err error
        if dial == nil </span><span class="cov0" title="0">{
                hlog.SystemLogger().Warn("HostClient: no dialer specified, trying to use default dialer")
                dial = dialer.DefaultDialer()
        }</span>
        <span class="cov8" title="1">dialFunc := dial.DialConnection

        // addr has already been added port, no need to do it here
        if proxyURI != nil </span><span class="cov0" title="0">{
                // use tcp connection first, proxy will AddTLS to it
                conn, err = dialFunc("tcp", string(proxyURI.Host()), timeout, nil)
        }</span> else<span class="cov8" title="1"> {
                conn, err = dialFunc("tcp", addr, timeout, tlsConfig)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if conn == nil </span><span class="cov0" title="0">{
                panic("BUG: dial.DialConnection returned (nil, nil)")</span>
        }

        <span class="cov8" title="1">if proxyURI != nil </span><span class="cov0" title="0">{
                conn, err = proxy.SetupProxy(conn, addr, proxyURI, tlsConfig, isTLS, dial)
        }</span>

        // conn must be nil when got error, so doesn't need to close it
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return conn, nil</span>
}

func (c *HostClient) getClientName() []byte <span class="cov8" title="1">{
        v := c.clientName.Load()
        var clientName []byte
        if v == nil </span><span class="cov8" title="1">{
                clientName = []byte(c.Name)
                if len(clientName) == 0 &amp;&amp; !c.NoDefaultUserAgentHeader </span><span class="cov8" title="1">{
                        clientName = bytestr.DefaultUserAgent
                }</span>
                <span class="cov8" title="1">c.clientName.Store(clientName)</span>
        } else<span class="cov8" title="1"> {
                clientName = v.([]byte)
        }</span>
        <span class="cov8" title="1">return clientName</span>
}

// waiting reports whether w is still waiting for an answer (connection or error).
func (w *wantConn) waiting() bool <span class="cov8" title="1">{
        select </span>{
        case &lt;-w.ready:<span class="cov8" title="1">
                return false</span>
        default:<span class="cov8" title="1">
                return true</span>
        }
}

// tryDeliver attempts to deliver conn, err to w and reports whether it succeeded.
func (w *wantConn) tryDeliver(conn *clientConn, err error) bool <span class="cov8" title="1">{
        w.mu.Lock()
        defer w.mu.Unlock()

        if w.conn != nil || w.err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">w.conn = conn
        w.err = err
        if w.conn == nil &amp;&amp; w.err == nil </span><span class="cov0" title="0">{
                panic("hertz: internal error: misuse of tryDeliver")</span>
        }
        <span class="cov8" title="1">close(w.ready)
        return true</span>
}

// cancel marks w as no longer wanting a result (for example, due to cancellation).
// If a connection has been delivered already, cancel returns it with c.releaseConn.
func (w *wantConn) cancel(c *HostClient, err error) <span class="cov8" title="1">{
        w.mu.Lock()
        if w.conn == nil &amp;&amp; w.err == nil </span><span class="cov8" title="1">{
                close(w.ready) // catch misbehavior in future delivery
        }</span>

        <span class="cov8" title="1">conn := w.conn
        w.conn = nil
        w.err = err
        w.mu.Unlock()

        if conn != nil </span><span class="cov0" title="0">{
                c.releaseConn(conn)
        }</span>
}

// len returns the number of items in the queue.
func (q *wantConnQueue) len() int <span class="cov8" title="1">{
        return len(q.head) - q.headPos + len(q.tail)
}</span>

// pushBack adds w to the back of the queue.
func (q *wantConnQueue) pushBack(w *wantConn) <span class="cov8" title="1">{
        q.tail = append(q.tail, w)
}</span>

// popFront removes and returns the wantConn at the front of the queue.
func (q *wantConnQueue) popFront() *wantConn <span class="cov8" title="1">{
        if q.headPos &gt;= len(q.head) </span><span class="cov8" title="1">{
                if len(q.tail) == 0 </span><span class="cov8" title="1">{
                        return nil
                }</span>
                // Pick up tail as new head, clear tail.
                <span class="cov8" title="1">q.head, q.headPos, q.tail = q.tail, 0, q.head[:0]</span>
        }

        <span class="cov8" title="1">w := q.head[q.headPos]
        q.head[q.headPos] = nil
        q.headPos++
        return w</span>
}

// peekFront returns the wantConn at the front of the queue without removing it.
func (q *wantConnQueue) peekFront() *wantConn <span class="cov8" title="1">{
        if q.headPos &lt; len(q.head) </span><span class="cov0" title="0">{
                return q.head[q.headPos]
        }</span>
        <span class="cov8" title="1">if len(q.tail) &gt; 0 </span><span class="cov8" title="1">{
                return q.tail[0]
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// cleanFront pops any wantConns that are no longer waiting from the head of the
// queue, reporting whether any were popped.
func (q *wantConnQueue) clearFront() (cleaned bool) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                w := q.peekFront()
                if w == nil || w.waiting() </span><span class="cov8" title="1">{
                        return cleaned
                }</span>
                <span class="cov0" title="0">q.popFront()
                cleaned = true</span>
        }
}

func NewHostClient(c *ClientOptions) client.HostClient <span class="cov0" title="0">{
        hc := &amp;HostClient{
                ClientOptions: c,
                closed:        make(chan struct{}),
        }

        return hc
}</span>

type ClientOptions struct {
        // Client name. Used in User-Agent request header.
        Name string

        // NoDefaultUserAgentHeader when set to true, causes the default
        // User-Agent header to be excluded from the Request.
        NoDefaultUserAgentHeader bool

        // Callback for establishing new connection to the host.
        //
        // Default Dialer is used if not set.
        Dialer network.Dialer

        // Timeout for establishing new connections to hosts.
        //
        // Default DialTimeout is used if not set.
        DialTimeout time.Duration

        // Attempt to connect to both ipv4 and ipv6 host addresses
        // if set to true.
        //
        // This option is used only if default TCP dialer is used,
        // i.e. if Dialer is blank.
        //
        // By default client connects only to ipv4 addresses,
        // since unfortunately ipv6 remains broken in many networks worldwide :)
        DialDualStack bool

        // Whether to use TLS (aka SSL or HTTPS) for host connections.
        // Optional TLS config.
        TLSConfig *tls.Config

        // Maximum number of connections which may be established to all hosts
        // listed in Addr.
        //
        // You can change this value while the HostClient is being used
        // using HostClient.SetMaxConns(value)
        //
        // DefaultMaxConnsPerHost is used if not set.
        MaxConns int

        // Keep-alive connections are closed after this duration.
        //
        // By default connection duration is unlimited.
        MaxConnDuration time.Duration

        // Idle keep-alive connections are closed after this duration.
        //
        // By default idle connections are closed
        // after DefaultMaxIdleConnDuration.
        MaxIdleConnDuration time.Duration

        // Maximum duration for full response reading (including body).
        //
        // By default response read timeout is unlimited.
        ReadTimeout time.Duration

        // Maximum duration for full request writing (including body).
        //
        // By default request write timeout is unlimited.
        WriteTimeout time.Duration

        // Maximum response body size.
        //
        // The client returns errBodyTooLarge if this limit is greater than 0
        // and response body is greater than the limit.
        //
        // By default response body size is unlimited.
        MaxResponseBodySize int

        // Header names are passed as-is without normalization
        // if this option is set.
        //
        // Disabled header names' normalization may be useful only for proxying
        // responses to other clients expecting case-sensitive header names.
        //
        // By default request and response header names are normalized, i.e.
        // The first letter and the first letters following dashes
        // are uppercased, while all the other letters are lowercased.
        // Examples:
        //
        //     * HOST -&gt; Host
        //     * content-type -&gt; Content-Type
        //     * cONTENT-lenGTH -&gt; Content-Length
        DisableHeaderNamesNormalizing bool

        // Path values are sent as-is without normalization
        //
        // Disabled path normalization may be useful for proxying incoming requests
        // to servers that are expecting paths to be forwarded as-is.
        //
        // By default path values are normalized, i.e.
        // extra slashes are removed, special characters are encoded.
        DisablePathNormalizing bool

        // Maximum duration for waiting for a free connection.
        //
        // By default will not wait, return ErrNoFreeConns immediately
        MaxConnWaitTimeout time.Duration

        // ResponseBodyStream enables response body streaming
        ResponseBodyStream bool

        // All configurations related to retry
        RetryConfig *retry.Config

        RetryIfFunc client.RetryIfFunc

        // Observe hostclient state
        StateObserve config.HostClientStateFunc

        // StateObserve execution interval
        ObservationInterval time.Duration
}
</pre>
		
		<pre class="file" id="file79" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015-present Aliaksandr Valialkin, VertaMedia, Kirill Danshin, Erik Dubbelboer, FastHTTP Authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This file may have been modified by CloudWeGo authors. All CloudWeGo
 * Modifications are Copyright 2022 CloudWeGo Authors.
 */

package ext

import (
        "bytes"
        "errors"
        "fmt"
        "io"
        "strings"

        "github.com/cloudwego/hertz/internal/bytesconv"
        "github.com/cloudwego/hertz/internal/bytestr"
        errs "github.com/cloudwego/hertz/pkg/common/errors"
        "github.com/cloudwego/hertz/pkg/common/hlog"
        "github.com/cloudwego/hertz/pkg/common/utils"
        "github.com/cloudwego/hertz/pkg/network"
        "github.com/cloudwego/hertz/pkg/protocol"
        "github.com/cloudwego/hertz/pkg/protocol/consts"
)

const maxContentLengthInStream = 8 * 1024

var errBrokenChunk = errs.NewPublic("cannot find crlf at the end of chunk").SetMeta("when read body chunk")

func MustPeekBuffered(r network.Reader) []byte <span class="cov8" title="1">{
        l := r.Len()
        buf, err := r.Peek(l)
        if len(buf) == 0 || err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("bufio.Reader.Peek() returned unexpected data (%q, %v)", buf, err))</span>
        }

        <span class="cov8" title="1">return buf</span>
}

func MustDiscard(r network.Reader, n int) <span class="cov8" title="1">{
        if err := r.Skip(n); err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("bufio.Reader.Discard(%d) failed: %s", n, err))</span>
        }
}

func ReadRawHeaders(dst, buf []byte) ([]byte, int, error) <span class="cov8" title="1">{
        n := bytes.IndexByte(buf, '\n')
        if n &lt; 0 </span><span class="cov0" title="0">{
                return dst[:0], 0, errNeedMore
        }</span>
        <span class="cov8" title="1">if (n == 1 &amp;&amp; buf[0] == '\r') || n == 0 </span><span class="cov0" title="0">{
                // empty headers
                return dst, n + 1, nil
        }</span>

        <span class="cov8" title="1">n++
        b := buf
        m := n
        for </span><span class="cov8" title="1">{
                b = b[m:]
                m = bytes.IndexByte(b, '\n')
                if m &lt; 0 </span><span class="cov0" title="0">{
                        return dst, 0, errNeedMore
                }</span>
                <span class="cov8" title="1">m++
                n += m
                if (m == 2 &amp;&amp; b[0] == '\r') || m == 1 </span><span class="cov8" title="1">{
                        dst = append(dst, buf[:n]...)
                        return dst, n, nil
                }</span>
        }
}

func WriteBodyChunked(w network.Writer, r io.Reader) error <span class="cov8" title="1">{
        vbuf := utils.CopyBufPool.Get()
        buf := vbuf.([]byte)

        var err error
        var n int
        for </span><span class="cov8" title="1">{
                n, err = r.Read(buf)
                if n == 0 </span><span class="cov8" title="1">{
                        if err == nil </span><span class="cov0" title="0">{
                                panic("BUG: io.Reader returned 0, nil")</span>
                        }

                        <span class="cov8" title="1">if !errors.Is(err, io.EOF) </span><span class="cov8" title="1">{
                                hlog.SystemLogger().Warnf("writing chunked response body encountered an error from the reader, "+
                                        "this may cause the short of the content in response body, error: %s", err.Error())
                        }</span>

                        <span class="cov8" title="1">if err = WriteChunk(w, buf[:0], true); err != nil </span><span class="cov0" title="0">{
                                break</span>
                        }

                        <span class="cov8" title="1">err = nil
                        break</span>
                }
                <span class="cov8" title="1">if err = WriteChunk(w, buf[:n], true); err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov8" title="1">utils.CopyBufPool.Put(vbuf)
        return err</span>
}

func WriteBodyFixedSize(w network.Writer, r io.Reader, size int64) error <span class="cov8" title="1">{
        if size == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if size &gt; consts.MaxSmallFileSize </span><span class="cov0" title="0">{
                if err := w.Flush(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">if size &gt; 0 </span><span class="cov8" title="1">{
                r = io.LimitReader(r, size)
        }</span>

        <span class="cov8" title="1">n, err := utils.CopyZeroAlloc(w, r)

        if n != size &amp;&amp; err == nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("copied %d bytes from body stream instead of %d bytes", n, size)
        }</span>
        <span class="cov8" title="1">return err</span>
}

func appendBodyFixedSize(r network.Reader, dst []byte, n int) ([]byte, error) <span class="cov8" title="1">{
        if n == 0 </span><span class="cov0" title="0">{
                return dst, nil
        }</span>

        <span class="cov8" title="1">offset := len(dst)
        dstLen := offset + n
        if cap(dst) &lt; dstLen </span><span class="cov8" title="1">{
                b := make([]byte, round2(dstLen))
                copy(b, dst)
                dst = b
        }</span>
        <span class="cov8" title="1">dst = dst[:dstLen]

        // Peek can get all data, otherwise it will through error
        buf, err := r.Peek(n)
        if err != nil </span><span class="cov0" title="0">{
                if err == io.EOF </span><span class="cov0" title="0">{
                        err = io.ErrUnexpectedEOF
                }</span>
                <span class="cov0" title="0">return dst[:offset], err</span>
        }
        <span class="cov8" title="1">copy(dst[offset:], buf)
        r.Skip(len(buf)) // nolint: errcheck
        return dst, nil</span>
}

func readBodyIdentity(r network.Reader, maxBodySize int, dst []byte) ([]byte, error) <span class="cov8" title="1">{
        dst = dst[:cap(dst)]
        if len(dst) == 0 </span><span class="cov8" title="1">{
                dst = make([]byte, 1024)
        }</span>
        <span class="cov8" title="1">offset := 0
        for </span><span class="cov8" title="1">{
                nn := r.Len()

                if nn == 0 </span><span class="cov8" title="1">{
                        _, err := r.Peek(1)
                        if err != nil </span><span class="cov8" title="1">{
                                return dst[:offset], nil
                        }</span>
                        <span class="cov8" title="1">nn = r.Len()</span>
                }
                <span class="cov8" title="1">if nn &gt;= (len(dst) - offset) </span><span class="cov8" title="1">{
                        nn = len(dst) - offset
                }</span>

                <span class="cov8" title="1">buf, err := r.Peek(nn)
                if err != nil </span><span class="cov0" title="0">{
                        return dst[:offset], err
                }</span>
                <span class="cov8" title="1">copy(dst[offset:], buf)
                r.Skip(nn) // nolint: errcheck

                offset += nn
                if maxBodySize &gt; 0 &amp;&amp; offset &gt; maxBodySize </span><span class="cov8" title="1">{
                        return dst[:offset], errBodyTooLarge
                }</span>
                <span class="cov8" title="1">if len(dst) == offset </span><span class="cov8" title="1">{
                        n := round2(2 * offset)
                        if maxBodySize &gt; 0 &amp;&amp; n &gt; maxBodySize </span><span class="cov8" title="1">{
                                n = maxBodySize + 1
                        }</span>
                        <span class="cov8" title="1">b := make([]byte, n)
                        copy(b, dst)
                        dst = b</span>
                }
        }
}

func ReadBody(r network.Reader, contentLength, maxBodySize int, dst []byte) ([]byte, error) <span class="cov8" title="1">{
        dst = dst[:0]
        if contentLength &gt;= 0 </span><span class="cov8" title="1">{
                if maxBodySize &gt; 0 &amp;&amp; contentLength &gt; maxBodySize </span><span class="cov0" title="0">{
                        return dst, errBodyTooLarge
                }</span>
                <span class="cov8" title="1">return appendBodyFixedSize(r, dst, contentLength)</span>
        }
        <span class="cov8" title="1">if contentLength == -1 </span><span class="cov8" title="1">{
                return readBodyChunked(r, maxBodySize, dst)
        }</span>
        <span class="cov8" title="1">return readBodyIdentity(r, maxBodySize, dst)</span>
}

func LimitedReaderSize(r io.Reader) int64 <span class="cov0" title="0">{
        lr, ok := r.(*io.LimitedReader)
        if !ok </span><span class="cov0" title="0">{
                return -1
        }</span>
        <span class="cov0" title="0">return lr.N</span>
}

func readBodyChunked(r network.Reader, maxBodySize int, dst []byte) ([]byte, error) <span class="cov8" title="1">{
        if len(dst) &gt; 0 </span><span class="cov0" title="0">{
                panic("BUG: expected zero-length buffer")</span>
        }

        <span class="cov8" title="1">strCRLFLen := len(bytestr.StrCRLF)
        for </span><span class="cov8" title="1">{
                chunkSize, err := utils.ParseChunkSize(r)
                if err != nil </span><span class="cov0" title="0">{
                        return dst, err
                }</span>
                // If it is the end of chunk, Read CRLF after reading trailer
                <span class="cov8" title="1">if chunkSize == 0 </span><span class="cov8" title="1">{
                        return dst, nil
                }</span>
                <span class="cov8" title="1">if maxBodySize &gt; 0 &amp;&amp; len(dst)+chunkSize &gt; maxBodySize </span><span class="cov0" title="0">{
                        return dst, errBodyTooLarge
                }</span>
                <span class="cov8" title="1">dst, err = appendBodyFixedSize(r, dst, chunkSize+strCRLFLen)
                if err != nil </span><span class="cov0" title="0">{
                        return dst, err
                }</span>
                <span class="cov8" title="1">if !bytes.Equal(dst[len(dst)-strCRLFLen:], bytestr.StrCRLF) </span><span class="cov0" title="0">{
                        return dst, errBrokenChunk
                }</span>
                <span class="cov8" title="1">dst = dst[:len(dst)-strCRLFLen]</span>
        }
}

func round2(n int) int <span class="cov8" title="1">{
        if n &lt;= 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">n--
        x := uint(0)
        for n &gt; 0 </span><span class="cov8" title="1">{
                n &gt;&gt;= 1
                x++
        }</span>
        <span class="cov8" title="1">return 1 &lt;&lt; x</span>
}

func WriteChunk(w network.Writer, b []byte, withFlush bool) (err error) <span class="cov8" title="1">{
        n := len(b)
        if err = bytesconv.WriteHexInt(w, n); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">w.WriteBinary(bytestr.StrCRLF) //nolint:errcheck
        if _, err = w.WriteBinary(b); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // If it is the end of chunk, write CRLF after writing trailer
        <span class="cov8" title="1">if n &gt; 0 </span><span class="cov8" title="1">{
                w.WriteBinary(bytestr.StrCRLF) //nolint:errcheck
        }</span>

        <span class="cov8" title="1">if !withFlush </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">err = w.Flush()
        return</span>
}

func isOnlyCRLF(b []byte) bool <span class="cov8" title="1">{
        for _, ch := range b </span><span class="cov8" title="1">{
                if ch != '\r' &amp;&amp; ch != '\n' </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func BufferSnippet(b []byte) string <span class="cov8" title="1">{
        n := len(b)
        start := 20
        end := n - start
        if start &gt;= end </span><span class="cov8" title="1">{
                start = n
                end = n
        }</span>
        <span class="cov8" title="1">bStart, bEnd := b[:start], b[end:]
        if len(bEnd) == 0 </span><span class="cov8" title="1">{
                return fmt.Sprintf("%q", b)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%q...%q", bStart, bEnd)</span>
}

func normalizeHeaderValue(ov, ob []byte, headerLength int) (nv, nb []byte, nhl int) <span class="cov8" title="1">{
        nv = ov
        length := len(ov)
        if length &lt;= 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">write := 0
        shrunk := 0
        lineStart := false
        for read := 0; read &lt; length; read++ </span><span class="cov8" title="1">{
                c := ov[read]
                if c == '\r' || c == '\n' </span><span class="cov8" title="1">{
                        shrunk++
                        if c == '\n' </span><span class="cov8" title="1">{
                                lineStart = true
                        }</span>
                        <span class="cov8" title="1">continue</span>
                } else<span class="cov8" title="1"> if lineStart &amp;&amp; c == '\t' </span><span class="cov8" title="1">{
                        c = ' '
                }</span> else<span class="cov8" title="1"> {
                        lineStart = false
                }</span>
                <span class="cov8" title="1">nv[write] = c
                write++</span>
        }

        <span class="cov8" title="1">nv = nv[:write]
        copy(ob[write:], ob[write+shrunk:])

        // Check if we need to skip \r\n or just \n
        skip := 0
        if ob[write] == '\r' </span><span class="cov8" title="1">{
                if ob[write+1] == '\n' </span><span class="cov8" title="1">{
                        skip += 2
                }</span> else<span class="cov0" title="0"> {
                        skip++
                }</span>
        } else<span class="cov0" title="0"> if ob[write] == '\n' </span><span class="cov0" title="0">{
                skip++
        }</span>

        <span class="cov8" title="1">nb = ob[write+skip : len(ob)-shrunk]
        nhl = headerLength - shrunk
        return</span>
}

func stripSpace(b []byte) []byte <span class="cov8" title="1">{
        for len(b) &gt; 0 &amp;&amp; b[0] == ' ' </span><span class="cov8" title="1">{
                b = b[1:]
        }</span>
        <span class="cov8" title="1">for len(b) &gt; 0 &amp;&amp; b[len(b)-1] == ' ' </span><span class="cov8" title="1">{
                b = b[:len(b)-1]
        }</span>
        <span class="cov8" title="1">return b</span>
}

func SkipTrailer(r network.Reader) error <span class="cov8" title="1">{
        n := 1
        for </span><span class="cov8" title="1">{
                err := trySkipTrailer(r, n)
                if err == nil </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">if !errors.Is(err, errs.ErrNeedMore) </span><span class="cov8" title="1">{
                        return err
                }</span>
                // No more data available on the wire, try block peek(by netpoll)
                <span class="cov0" title="0">if n == r.Len() </span><span class="cov0" title="0">{
                        n++

                        continue</span>
                }
                <span class="cov0" title="0">n = r.Len()</span>
        }
}

func trySkipTrailer(r network.Reader, n int) error <span class="cov8" title="1">{
        b, err := r.Peek(n)
        if len(b) == 0 </span><span class="cov8" title="1">{
                // Return ErrTimeout on any timeout.
                if err != nil &amp;&amp; strings.Contains(err.Error(), "timeout") </span><span class="cov8" title="1">{
                        return errs.New(errs.ErrTimeout, errs.ErrorTypePublic, "read response header")
                }</span>

                <span class="cov8" title="1">if n == 1 || err == io.EOF </span><span class="cov8" title="1">{
                        return io.EOF
                }</span>

                <span class="cov0" title="0">return errs.NewPublicf("error when reading request trailer: %w", err)</span>
        }
        <span class="cov8" title="1">b = MustPeekBuffered(r)
        headersLen, errParse := skipTrailer(b)
        if errParse != nil </span><span class="cov0" title="0">{
                if err == io.EOF </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return HeaderError("response", err, errParse, b)</span>
        }
        <span class="cov8" title="1">MustDiscard(r, headersLen)
        return nil</span>
}

func skipTrailer(buf []byte) (int, error) <span class="cov8" title="1">{
        skip := 0
        strCRLFLen := len(bytestr.StrCRLF)
        for </span><span class="cov8" title="1">{
                index := bytes.Index(buf, bytestr.StrCRLF)
                if index == -1 </span><span class="cov0" title="0">{
                        return 0, errs.ErrNeedMore
                }</span>

                <span class="cov8" title="1">buf = buf[index+strCRLFLen:]
                skip += index + strCRLFLen

                if index == 0 </span><span class="cov8" title="1">{
                        return skip, nil
                }</span>
        }
}

func ReadTrailer(t *protocol.Trailer, r network.Reader) error <span class="cov8" title="1">{
        n := 1
        for </span><span class="cov8" title="1">{
                err := tryReadTrailer(t, r, n)
                if err == nil </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">if !errors.Is(err, errs.ErrNeedMore) </span><span class="cov8" title="1">{
                        t.ResetSkipNormalize()
                        return err
                }</span>
                // No more data available on the wire, try block peek(by netpoll)
                <span class="cov0" title="0">if n == r.Len() </span><span class="cov0" title="0">{
                        n++

                        continue</span>
                }
                <span class="cov0" title="0">n = r.Len()</span>
        }
}

func tryReadTrailer(t *protocol.Trailer, r network.Reader, n int) error <span class="cov8" title="1">{
        b, err := r.Peek(n)
        if len(b) == 0 </span><span class="cov8" title="1">{
                // Return ErrTimeout on any timeout.
                if err != nil &amp;&amp; strings.Contains(err.Error(), "timeout") </span><span class="cov0" title="0">{
                        return errs.New(errs.ErrTimeout, errs.ErrorTypePublic, "read response header")
                }</span>

                <span class="cov8" title="1">if n == 1 || err == io.EOF </span><span class="cov8" title="1">{
                        return io.EOF
                }</span>

                <span class="cov0" title="0">return errs.NewPublicf("error when reading request trailer: %w", err)</span>
        }
        <span class="cov8" title="1">b = MustPeekBuffered(r)
        headersLen, errParse := parseTrailer(t, b)
        if errParse != nil </span><span class="cov8" title="1">{
                if err == io.EOF </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return HeaderError("response", err, errParse, b)</span>
        }
        <span class="cov8" title="1">MustDiscard(r, headersLen)
        return nil</span>
}

func parseTrailer(t *protocol.Trailer, buf []byte) (int, error) <span class="cov8" title="1">{
        // Skip any 0 length chunk.
        if buf[0] == '0' </span><span class="cov8" title="1">{
                skip := len(bytestr.StrCRLF) + 1
                if len(buf) &lt; skip </span><span class="cov0" title="0">{
                        return 0, io.EOF
                }</span>
                <span class="cov8" title="1">buf = buf[skip:]</span>
        }

        <span class="cov8" title="1">var s HeaderScanner
        s.B = buf
        s.DisableNormalizing = t.IsDisableNormalizing()
        var err error
        for s.Next() </span><span class="cov8" title="1">{
                if len(s.Key) &gt; 0 </span><span class="cov8" title="1">{
                        if bytes.IndexByte(s.Key, ' ') != -1 || bytes.IndexByte(s.Key, '\t') != -1 </span><span class="cov0" title="0">{
                                err = fmt.Errorf("invalid trailer key %q", s.Key)
                                continue</span>
                        }
                        <span class="cov8" title="1">err = t.UpdateArgBytes(s.Key, s.Value)</span>
                }
        }
        <span class="cov8" title="1">if s.Err != nil </span><span class="cov0" title="0">{
                return 0, s.Err
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return s.HLen, nil</span>
}

// writeTrailer writes response trailer to w
func WriteTrailer(t *protocol.Trailer, w network.Writer) error <span class="cov0" title="0">{
        _, err := w.WriteBinary(t.Header())
        return err
}</span>
</pre>
		
		<pre class="file" id="file80" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015-present Aliaksandr Valialkin, VertaMedia, Kirill Danshin, Erik Dubbelboer, FastHTTP Authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This file may have been modified by CloudWeGo authors. All CloudWeGo
 * Modifications are Copyright 2022 CloudWeGo Authors.
 */

package ext

import (
        "errors"
        "fmt"
        "io"

        errs "github.com/cloudwego/hertz/pkg/common/errors"
)

var (
        errNeedMore     = errs.New(errs.ErrNeedMore, errs.ErrorTypePublic, "cannot find trailing lf")
        errBodyTooLarge = errs.New(errs.ErrBodyTooLarge, errs.ErrorTypePublic, "ext")
)

func HeaderError(typ string, err, errParse error, b []byte) error <span class="cov8" title="1">{
        if !errors.Is(errParse, errs.ErrNeedMore) </span><span class="cov8" title="1">{
                return headerErrorMsg(typ, errParse, b)
        }</span>
        <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                return errNeedMore
        }</span>

        // Buggy servers may leave trailing CRLFs after http body.
        // Treat this case as EOF.
        <span class="cov0" title="0">if isOnlyCRLF(b) </span><span class="cov0" title="0">{
                return io.EOF
        }</span>

        <span class="cov0" title="0">return headerErrorMsg(typ, err, b)</span>
}

func headerErrorMsg(typ string, err error, b []byte) error <span class="cov8" title="1">{
        return errs.NewPublic(fmt.Sprintf("error when reading %s headers: %s. Buffer size=%d, contents: %s", typ, err, len(b), BufferSnippet(b)))
}</span>
</pre>
		
		<pre class="file" id="file81" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015-present Aliaksandr Valialkin, VertaMedia, Kirill Danshin, Erik Dubbelboer, FastHTTP Authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This file may have been modified by CloudWeGo authors. All CloudWeGo
 * Modifications are Copyright 2022 CloudWeGo Authors.
 */

package ext

import (
        "bytes"

        errs "github.com/cloudwego/hertz/pkg/common/errors"
        "github.com/cloudwego/hertz/pkg/common/utils"
)

var errInvalidName = errs.NewPublic("invalid header name")

type HeaderScanner struct {
        B     []byte
        Key   []byte
        Value []byte
        Err   error

        // HLen stores header subslice len
        HLen int

        DisableNormalizing bool

        // by checking whether the Next line contains a colon or not to tell
        // it's a header entry or a multi line value of current header entry.
        // the side effect of this operation is that we know the index of the
        // Next colon and new line, so this can be used during Next iteration,
        // instead of find them again.
        nextColon   int
        nextNewLine int

        initialized bool
}

type HeaderValueScanner struct {
        B     []byte
        Value []byte
}

func (s *HeaderScanner) Next() bool <span class="cov8" title="1">{
        if !s.initialized </span><span class="cov8" title="1">{
                s.nextColon = -1
                s.nextNewLine = -1
                s.initialized = true
        }</span>
        <span class="cov8" title="1">bLen := len(s.B)
        if bLen &gt;= 2 &amp;&amp; s.B[0] == '\r' &amp;&amp; s.B[1] == '\n' </span><span class="cov8" title="1">{
                s.B = s.B[2:]
                s.HLen += 2
                return false
        }</span>
        <span class="cov8" title="1">if bLen &gt;= 1 &amp;&amp; s.B[0] == '\n' </span><span class="cov0" title="0">{
                s.B = s.B[1:]
                s.HLen++
                return false
        }</span>
        <span class="cov8" title="1">var n int
        if s.nextColon &gt;= 0 </span><span class="cov0" title="0">{
                n = s.nextColon
                s.nextColon = -1
        }</span> else<span class="cov8" title="1"> {
                n = bytes.IndexByte(s.B, ':')

                // There can't be a \n inside the header name, check for this.
                x := bytes.IndexByte(s.B, '\n')
                if x &lt; 0 </span><span class="cov8" title="1">{
                        // A header name should always at some point be followed by a \n
                        // even if it's the one that terminates the header block.
                        s.Err = errNeedMore
                        return false
                }</span>
                <span class="cov8" title="1">if x &lt; n </span><span class="cov8" title="1">{
                        // There was a \n before the :
                        s.Err = errInvalidName
                        return false
                }</span>
        }
        <span class="cov8" title="1">if n &lt; 0 </span><span class="cov8" title="1">{
                s.Err = errNeedMore
                return false
        }</span>
        <span class="cov8" title="1">s.Key = s.B[:n]
        utils.NormalizeHeaderKey(s.Key, s.DisableNormalizing)
        n++
        for len(s.B) &gt; n &amp;&amp; s.B[n] == ' ' </span><span class="cov8" title="1">{
                n++
                // the newline index is a relative index, and lines below trimmed `s.b` by `n`,
                // so the relative newline index also shifted forward. it's safe to decrease
                // to a minus value, it means it's invalid, and will find the newline again.
                s.nextNewLine--
        }</span>
        <span class="cov8" title="1">s.HLen += n
        s.B = s.B[n:]
        if s.nextNewLine &gt;= 0 </span><span class="cov0" title="0">{
                n = s.nextNewLine
                s.nextNewLine = -1
        }</span> else<span class="cov8" title="1"> {
                n = bytes.IndexByte(s.B, '\n')
        }</span>
        <span class="cov8" title="1">if n &lt; 0 </span><span class="cov0" title="0">{
                s.Err = errNeedMore
                return false
        }</span>
        <span class="cov8" title="1">isMultiLineValue := false
        for </span><span class="cov8" title="1">{
                if n+1 &gt;= len(s.B) </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">if s.B[n+1] != ' ' &amp;&amp; s.B[n+1] != '\t' </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">d := bytes.IndexByte(s.B[n+1:], '\n')
                if d &lt;= 0 </span><span class="cov0" title="0">{
                        break</span>
                } else<span class="cov8" title="1"> if d == 1 &amp;&amp; s.B[n+1] == '\r' </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">e := n + d + 1
                if c := bytes.IndexByte(s.B[n+1:e], ':'); c &gt;= 0 </span><span class="cov0" title="0">{
                        s.nextColon = c
                        s.nextNewLine = d - c - 1
                        break</span>
                }
                <span class="cov8" title="1">isMultiLineValue = true
                n = e</span>
        }
        <span class="cov8" title="1">if n &gt;= len(s.B) </span><span class="cov0" title="0">{
                s.Err = errNeedMore
                return false
        }</span>
        <span class="cov8" title="1">oldB := s.B
        s.Value = s.B[:n]
        s.HLen += n + 1
        s.B = s.B[n+1:]

        if n &gt; 0 &amp;&amp; s.Value[n-1] == '\r' </span><span class="cov8" title="1">{
                n--
        }</span>
        <span class="cov8" title="1">for n &gt; 0 &amp;&amp; s.Value[n-1] == ' ' </span><span class="cov0" title="0">{
                n--
        }</span>
        <span class="cov8" title="1">s.Value = s.Value[:n]
        if isMultiLineValue </span><span class="cov8" title="1">{
                s.Value, s.B, s.HLen = normalizeHeaderValue(s.Value, oldB, s.HLen)
        }</span>
        <span class="cov8" title="1">return true</span>
}

func (s *HeaderValueScanner) next() bool <span class="cov8" title="1">{
        b := s.B
        if len(b) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">n := bytes.IndexByte(b, ',')
        if n &lt; 0 </span><span class="cov8" title="1">{
                s.Value = stripSpace(b)
                s.B = b[len(b):]
                return true
        }</span>
        <span class="cov8" title="1">s.Value = stripSpace(b[:n])
        s.B = b[n+1:]
        return true</span>
}

func HasHeaderValue(s, value []byte) bool <span class="cov8" title="1">{
        var vs HeaderValueScanner
        vs.B = s
        for vs.next() </span><span class="cov8" title="1">{
                if utils.CaseInsensitiveCompare(vs.Value, value) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file82" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015-present Aliaksandr Valialkin, VertaMedia, Kirill Danshin, Erik Dubbelboer, FastHTTP Authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This file may have been modified by CloudWeGo authors. All CloudWeGo
 * Modifications are Copyright 2022 CloudWeGo Authors.
 */

package ext

import (
        "bytes"
        "io"
        "sync"

        "github.com/cloudwego/hertz/internal/bytestr"
        "github.com/cloudwego/hertz/pkg/common/bytebufferpool"
        errs "github.com/cloudwego/hertz/pkg/common/errors"
        "github.com/cloudwego/hertz/pkg/common/utils"
        "github.com/cloudwego/hertz/pkg/network"
        "github.com/cloudwego/hertz/pkg/protocol"
)

var (
        errChunkedStream = errs.New(errs.ErrChunkedStream, errs.ErrorTypePublic, nil)

        bodyStreamPool = sync.Pool{
                New: func() interface{} <span class="cov8" title="1">{
                        return &amp;bodyStream{}
                }</span>,
        }
)

// Deprecated: Use github.com/cloudwego/hertz/pkg/protocol.NoBody instead.
var NoBody = protocol.NoBody

type bodyStream struct {
        prefetchedBytes *bytes.Reader
        reader          network.Reader
        trailer         *protocol.Trailer
        offset          int
        contentLength   int
        chunkLeft       int
        // whether the chunk has reached the EOF
        chunkEOF bool
}

func ReadBodyWithStreaming(zr network.Reader, contentLength, maxBodySize int, dst []byte) (b []byte, err error) <span class="cov8" title="1">{
        if contentLength == -1 </span><span class="cov8" title="1">{
                // handled in requestStream.Read()
                return b, errChunkedStream
        }</span>
        <span class="cov8" title="1">dst = dst[:0]

        if maxBodySize &lt;= 0 </span><span class="cov8" title="1">{
                maxBodySize = maxContentLengthInStream
        }</span>
        <span class="cov8" title="1">readN := maxBodySize
        if readN &gt; contentLength </span><span class="cov8" title="1">{
                readN = contentLength
        }</span>
        <span class="cov8" title="1">if readN &gt; maxContentLengthInStream </span><span class="cov8" title="1">{
                readN = maxContentLengthInStream
        }</span>

        <span class="cov8" title="1">if contentLength &gt;= 0 &amp;&amp; maxBodySize &gt;= contentLength </span><span class="cov8" title="1">{
                b, err = appendBodyFixedSize(zr, dst, readN)
        }</span> else<span class="cov8" title="1"> {
                b, err = readBodyIdentity(zr, readN, dst)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return b, err
        }</span>
        <span class="cov8" title="1">if contentLength &gt; maxBodySize </span><span class="cov0" title="0">{
                return b, errBodyTooLarge
        }</span>
        <span class="cov8" title="1">return b, nil</span>
}

func AcquireBodyStream(b *bytebufferpool.ByteBuffer, r network.Reader, t *protocol.Trailer, contentLength int) io.Reader <span class="cov8" title="1">{
        rs := bodyStreamPool.Get().(*bodyStream)
        rs.prefetchedBytes = bytes.NewReader(b.B)
        rs.reader = r
        rs.contentLength = contentLength
        rs.trailer = t
        rs.chunkEOF = false

        return rs
}</span>

func (rs *bodyStream) Read(p []byte) (int, error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if rs.reader != nil </span><span class="cov8" title="1">{
                        rs.reader.Release() //nolint:errcheck
                }</span>
        }()
        <span class="cov8" title="1">if rs.contentLength == -1 </span><span class="cov8" title="1">{
                if rs.chunkEOF </span><span class="cov0" title="0">{
                        return 0, io.EOF
                }</span>

                <span class="cov8" title="1">if rs.chunkLeft == 0 </span><span class="cov8" title="1">{
                        chunkSize, err := utils.ParseChunkSize(rs.reader)
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, err
                        }</span>
                        <span class="cov8" title="1">if chunkSize == 0 </span><span class="cov8" title="1">{
                                err = ReadTrailer(rs.trailer, rs.reader)
                                if err == nil </span><span class="cov8" title="1">{
                                        rs.chunkEOF = true
                                        err = io.EOF
                                }</span>
                                <span class="cov8" title="1">return 0, err</span>
                        }

                        <span class="cov8" title="1">rs.chunkLeft = chunkSize</span>
                }
                <span class="cov8" title="1">bytesToRead := len(p)

                if bytesToRead &gt; rs.chunkLeft </span><span class="cov8" title="1">{
                        bytesToRead = rs.chunkLeft
                }</span>

                <span class="cov8" title="1">src, err := rs.reader.Peek(bytesToRead)
                copied := copy(p, src)
                rs.reader.Skip(copied) // nolint: errcheck
                rs.chunkLeft -= copied

                if err != nil </span><span class="cov0" title="0">{
                        if err == io.EOF </span><span class="cov0" title="0">{
                                err = io.ErrUnexpectedEOF
                        }</span>
                        <span class="cov0" title="0">return copied, err</span>
                }

                <span class="cov8" title="1">if rs.chunkLeft == 0 </span><span class="cov8" title="1">{
                        err = utils.SkipCRLF(rs.reader)
                        if err == io.EOF </span><span class="cov0" title="0">{
                                err = io.ErrUnexpectedEOF
                        }</span>
                }

                <span class="cov8" title="1">return copied, err</span>
        }
        <span class="cov8" title="1">if rs.offset == rs.contentLength </span><span class="cov0" title="0">{
                return 0, io.EOF
        }</span>
        <span class="cov8" title="1">var n int
        var err error
        // read from the pre-read buffer
        if int(rs.prefetchedBytes.Size()) &gt; rs.offset </span><span class="cov8" title="1">{
                n, err = rs.prefetchedBytes.Read(p)
                rs.offset += n
                if rs.offset == rs.contentLength </span><span class="cov8" title="1">{
                        return n, io.EOF
                }</span>
                <span class="cov8" title="1">if err != nil || len(p) == n </span><span class="cov8" title="1">{
                        return n, err
                }</span>
        }

        // read from the wire
        <span class="cov8" title="1">m := len(p) - n
        remain := rs.contentLength - rs.offset

        if m &gt; remain </span><span class="cov8" title="1">{
                m = remain
        }</span>

        <span class="cov8" title="1">if conn, ok := rs.reader.(io.Reader); ok </span><span class="cov8" title="1">{
                m, err = conn.Read(p[n:])
        }</span> else<span class="cov0" title="0"> {
                var tmp []byte
                tmp, err = rs.reader.Peek(m)
                m = copy(p[n:], tmp)
                rs.reader.Skip(m) // nolint: errcheck
        }</span>
        <span class="cov8" title="1">rs.offset += m
        n += m

        if err != nil </span><span class="cov8" title="1">{
                // the data on stream may be incomplete
                if err == io.EOF </span><span class="cov8" title="1">{
                        if rs.offset != rs.contentLength &amp;&amp; rs.contentLength != -2 </span><span class="cov0" title="0">{
                                err = io.ErrUnexpectedEOF
                        }</span>
                        // ensure that skipRest works fine
                        <span class="cov8" title="1">rs.offset = rs.contentLength</span>
                }
                <span class="cov8" title="1">return n, err</span>
        }
        <span class="cov0" title="0">if rs.offset == rs.contentLength </span><span class="cov0" title="0">{
                err = io.EOF
        }</span>
        <span class="cov0" title="0">return n, err</span>
}

func (rs *bodyStream) skipRest() error <span class="cov8" title="1">{
        // The body length doesn't exceed the maxContentLengthInStream or
        // the bodyStream has been skip rest
        if rs.prefetchedBytes == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // the request is chunked encoding
        <span class="cov8" title="1">if rs.contentLength == -1 </span><span class="cov8" title="1">{
                if rs.chunkEOF </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">strCRLFLen := len(bytestr.StrCRLF)
                for </span><span class="cov8" title="1">{
                        chunkSize, err := utils.ParseChunkSize(rs.reader)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">if chunkSize == 0 </span><span class="cov8" title="1">{
                                rs.chunkEOF = true
                                return SkipTrailer(rs.reader)
                        }</span>

                        <span class="cov8" title="1">err = rs.reader.Skip(chunkSize)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">crlf, err := rs.reader.Peek(strCRLFLen)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">if !bytes.Equal(crlf, bytestr.StrCRLF) </span><span class="cov0" title="0">{
                                return errBrokenChunk
                        }</span>

                        <span class="cov8" title="1">err = rs.reader.Skip(strCRLFLen)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        // max value of pSize is 8193, it's safe.
        <span class="cov8" title="1">pSize := int(rs.prefetchedBytes.Size())
        if rs.contentLength &lt;= pSize || rs.offset == rs.contentLength </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">needSkipLen := 0
        if rs.offset &gt; pSize </span><span class="cov0" title="0">{
                needSkipLen = rs.contentLength - rs.offset
        }</span> else<span class="cov8" title="1"> {
                needSkipLen = rs.contentLength - pSize
        }</span>

        // must skip size
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                skip := rs.reader.Len()
                if skip == 0 </span><span class="cov8" title="1">{
                        _, err := rs.reader.Peek(1)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">skip = rs.reader.Len()</span>
                }
                <span class="cov8" title="1">if skip &gt; needSkipLen </span><span class="cov0" title="0">{
                        skip = needSkipLen
                }</span>
                <span class="cov8" title="1">rs.reader.Skip(skip)
                needSkipLen -= skip
                if needSkipLen == 0 </span><span class="cov8" title="1">{
                        return nil
                }</span>
        }
}

// ReleaseBodyStream releases the body stream.
// Error of skipRest may be returned if there is one.
//
// NOTE: Be careful to use this method unless you know what it's for.
func ReleaseBodyStream(requestReader io.Reader) (err error) <span class="cov8" title="1">{
        if rs, ok := requestReader.(*bodyStream); ok </span><span class="cov8" title="1">{
                err = rs.skipRest()
                rs.reset()
                bodyStreamPool.Put(rs)
        }</span>
        <span class="cov8" title="1">return</span>
}

func (rs *bodyStream) reset() <span class="cov8" title="1">{
        rs.prefetchedBytes = nil
        rs.offset = 0
        rs.reader = nil
        rs.trailer = nil
        rs.chunkEOF = false
        rs.chunkLeft = 0
        rs.contentLength = 0
}</span>
</pre>
		
		<pre class="file" id="file83" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015-present Aliaksandr Valialkin, VertaMedia, Kirill Danshin, Erik Dubbelboer, FastHTTP Authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This file may have been modified by CloudWeGo authors. All CloudWeGo
 * Modifications are Copyright 2022 CloudWeGo Authors.
 */

package req

import (
        "bytes"
        "errors"
        "fmt"
        "io"

        "github.com/cloudwego/hertz/internal/bytesconv"
        "github.com/cloudwego/hertz/internal/bytestr"
        errs "github.com/cloudwego/hertz/pkg/common/errors"
        "github.com/cloudwego/hertz/pkg/common/utils"
        "github.com/cloudwego/hertz/pkg/network"
        "github.com/cloudwego/hertz/pkg/protocol"
        "github.com/cloudwego/hertz/pkg/protocol/consts"
        "github.com/cloudwego/hertz/pkg/protocol/http1/ext"
)

var errEOFReadHeader = errs.NewPublic("error when reading request headers: EOF")

// Write writes request header to w.
func WriteHeader(h *protocol.RequestHeader, w network.Writer) error <span class="cov8" title="1">{
        header := h.Header()
        _, err := w.WriteBinary(header)
        return err
}</span>

func ReadHeader(h *protocol.RequestHeader, r network.Reader) error <span class="cov8" title="1">{
        n := 1
        for </span><span class="cov8" title="1">{
                err := tryRead(h, r, n)
                if err == nil </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">if !errors.Is(err, errs.ErrNeedMore) </span><span class="cov8" title="1">{
                        h.ResetSkipNormalize()
                        return err
                }</span>

                // No more data available on the wire, try block peek
                <span class="cov8" title="1">if n == r.Len() </span><span class="cov8" title="1">{
                        n++
                        continue</span>
                }
                <span class="cov0" title="0">n = r.Len()</span>
        }
}

func tryRead(h *protocol.RequestHeader, r network.Reader, n int) error <span class="cov8" title="1">{
        h.ResetSkipNormalize()
        b, err := r.Peek(n)
        if len(b) == 0 </span><span class="cov8" title="1">{
                if err != io.EOF </span><span class="cov8" title="1">{
                        return err
                }</span>

                // n == 1 on the first read for the request.
                <span class="cov8" title="1">if n == 1 </span><span class="cov8" title="1">{
                        // We didn't read a single byte.
                        return errs.New(errs.ErrNothingRead, errs.ErrorTypePrivate, err)
                }</span>

                <span class="cov0" title="0">return errEOFReadHeader</span>
        }
        <span class="cov8" title="1">b = ext.MustPeekBuffered(r)
        headersLen, errParse := parse(h, b)
        if errParse != nil </span><span class="cov8" title="1">{
                return ext.HeaderError("request", err, errParse, b)
        }</span>
        <span class="cov8" title="1">ext.MustDiscard(r, headersLen)
        return nil</span>
}

func parse(h *protocol.RequestHeader, buf []byte) (int, error) <span class="cov8" title="1">{
        m, err := parseFirstLine(h, buf)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>

        <span class="cov8" title="1">rawHeaders, _, err := ext.ReadRawHeaders(h.RawHeaders()[:0], buf[m:])
        h.SetRawHeaders(rawHeaders)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>
        <span class="cov8" title="1">var n int
        n, err = parseHeaders(h, buf[m:])
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return m + n, nil</span>
}

func parseFirstLine(h *protocol.RequestHeader, buf []byte) (int, error) <span class="cov8" title="1">{
        bNext := buf
        var b []byte
        var err error
        for len(b) == 0 </span><span class="cov8" title="1">{
                if b, bNext, err = utils.NextLine(bNext); err != nil </span><span class="cov8" title="1">{
                        return 0, err
                }</span>
        }

        // parse method
        <span class="cov8" title="1">n := bytes.IndexByte(b, ' ')
        if n &lt;= 0 </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("cannot find http request method in %q", ext.BufferSnippet(buf))
        }</span>
        <span class="cov8" title="1">h.SetMethodBytes(b[:n])
        b = b[n+1:]

        // Set default protocol
        h.SetProtocol(consts.HTTP11)
        // parse requestURI
        n = bytes.LastIndexByte(b, ' ')
        if n &lt; 0 </span><span class="cov0" title="0">{
                h.SetProtocol(consts.HTTP10)
                n = len(b)
        }</span> else<span class="cov8" title="1"> if n == 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("requestURI cannot be empty in %q", buf)
        }</span> else<span class="cov8" title="1"> if !bytes.Equal(b[n+1:], bytestr.StrHTTP11) </span><span class="cov8" title="1">{
                h.SetProtocol(consts.HTTP10)
        }</span>
        <span class="cov8" title="1">h.SetRequestURIBytes(b[:n])

        return len(buf) - len(bNext), nil</span>
}

// validHeaderFieldValue is equal to httpguts.ValidHeaderFieldValueï¼shares the same contextï¼
func validHeaderFieldValue(val []byte) bool <span class="cov8" title="1">{
        for _, v := range val </span><span class="cov8" title="1">{
                if bytesconv.ValidHeaderFieldValueTable[v] == 0 </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func parseHeaders(h *protocol.RequestHeader, buf []byte) (int, error) <span class="cov8" title="1">{
        h.InitContentLengthWithValue(-2)

        var s ext.HeaderScanner
        s.B = buf
        s.DisableNormalizing = h.IsDisableNormalizing()
        var err error
        for s.Next() </span><span class="cov8" title="1">{
                if len(s.Key) &gt; 0 </span><span class="cov8" title="1">{
                        // Spaces between the header key and colon are not allowed.
                        // See RFC 7230, Section 3.2.4.
                        if bytes.IndexByte(s.Key, ' ') != -1 || bytes.IndexByte(s.Key, '\t') != -1 </span><span class="cov0" title="0">{
                                err = fmt.Errorf("invalid header key %q", s.Key)
                                return 0, err
                        }</span>

                        // Check the invalid chars in header value
                        <span class="cov8" title="1">if !validHeaderFieldValue(s.Value) </span><span class="cov0" title="0">{
                                err = fmt.Errorf("invalid header value %q", s.Value)
                                return 0, err
                        }</span>

                        <span class="cov8" title="1">switch s.Key[0] | 0x20 </span>{
                        case 'h':<span class="cov8" title="1">
                                if utils.CaseInsensitiveCompare(s.Key, bytestr.StrHost) </span><span class="cov8" title="1">{
                                        h.SetHostBytes(s.Value)
                                        continue</span>
                                }
                        case 'u':<span class="cov8" title="1">
                                if utils.CaseInsensitiveCompare(s.Key, bytestr.StrUserAgent) </span><span class="cov8" title="1">{
                                        h.SetUserAgentBytes(s.Value)
                                        continue</span>
                                }
                        case 'c':<span class="cov8" title="1">
                                if utils.CaseInsensitiveCompare(s.Key, bytestr.StrContentType) </span><span class="cov8" title="1">{
                                        h.SetContentTypeBytes(s.Value)
                                        continue</span>
                                }
                                <span class="cov8" title="1">if utils.CaseInsensitiveCompare(s.Key, bytestr.StrContentLength) </span><span class="cov8" title="1">{
                                        if h.ContentLength() != -1 </span><span class="cov8" title="1">{
                                                var nerr error
                                                var contentLength int
                                                if contentLength, nerr = protocol.ParseContentLength(s.Value); nerr != nil </span><span class="cov0" title="0">{
                                                        if err == nil </span><span class="cov0" title="0">{
                                                                err = nerr
                                                        }</span>
                                                        <span class="cov0" title="0">h.InitContentLengthWithValue(-2)</span>
                                                } else<span class="cov8" title="1"> {
                                                        h.InitContentLengthWithValue(contentLength)
                                                        h.SetContentLengthBytes(s.Value)
                                                }</span>
                                        }
                                        <span class="cov8" title="1">continue</span>
                                }
                                <span class="cov8" title="1">if utils.CaseInsensitiveCompare(s.Key, bytestr.StrConnection) </span><span class="cov8" title="1">{
                                        if bytes.Equal(s.Value, bytestr.StrClose) </span><span class="cov8" title="1">{
                                                h.SetConnectionClose(true)
                                        }</span> else<span class="cov8" title="1"> {
                                                h.SetConnectionClose(false)
                                                h.AddArgBytes(s.Key, s.Value, protocol.ArgsHasValue)
                                        }</span>
                                        <span class="cov8" title="1">continue</span>
                                }
                        case 't':<span class="cov8" title="1">
                                if utils.CaseInsensitiveCompare(s.Key, bytestr.StrTransferEncoding) </span><span class="cov8" title="1">{
                                        if !bytes.Equal(s.Value, bytestr.StrIdentity) </span><span class="cov8" title="1">{
                                                h.InitContentLengthWithValue(-1)
                                                h.SetArgBytes(bytestr.StrTransferEncoding, bytestr.StrChunked, protocol.ArgsHasValue)
                                        }</span>
                                        <span class="cov8" title="1">continue</span>
                                }
                                <span class="cov8" title="1">if utils.CaseInsensitiveCompare(s.Key, bytestr.StrTrailer) </span><span class="cov8" title="1">{
                                        if nerr := h.Trailer().SetTrailers(s.Value); nerr != nil </span><span class="cov0" title="0">{
                                                if err == nil </span><span class="cov0" title="0">{
                                                        err = nerr
                                                }</span>
                                        }
                                        <span class="cov8" title="1">continue</span>
                                }
                        }
                }
                <span class="cov8" title="1">h.AddArgBytes(s.Key, s.Value, protocol.ArgsHasValue)</span>
        }

        <span class="cov8" title="1">if s.Err != nil &amp;&amp; err == nil </span><span class="cov8" title="1">{
                err = s.Err
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                h.SetConnectionClose(true)
                return 0, err
        }</span>

        <span class="cov8" title="1">if h.ContentLength() &lt; 0 </span><span class="cov8" title="1">{
                h.SetContentLengthBytes(h.ContentLengthBytes()[:0])
        }</span>
        <span class="cov8" title="1">if !h.IsHTTP11() &amp;&amp; !h.ConnectionClose() </span><span class="cov8" title="1">{
                // close connection for non-http/1.1 request unless 'Connection: keep-alive' is set.
                v := h.PeekArgBytes(bytestr.StrConnection)
                h.SetConnectionClose(!ext.HasHeaderValue(v, bytestr.StrKeepAlive))
        }</span>
        <span class="cov8" title="1">return s.HLen, nil</span>
}
</pre>
		
		<pre class="file" id="file84" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015-present Aliaksandr Valialkin, VertaMedia, Kirill Danshin, Erik Dubbelboer, FastHTTP Authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This file may have been modified by CloudWeGo authors. All CloudWeGo
 * Modifications are Copyright 2022 CloudWeGo Authors.
 */

package req

import (
        "bytes"
        "encoding/base64"
        "errors"
        "fmt"
        "io"
        "mime/multipart"

        "github.com/cloudwego/hertz/internal/bytestr"
        "github.com/cloudwego/hertz/pkg/common/bytebufferpool"
        errs "github.com/cloudwego/hertz/pkg/common/errors"
        "github.com/cloudwego/hertz/pkg/network"
        "github.com/cloudwego/hertz/pkg/protocol"
        "github.com/cloudwego/hertz/pkg/protocol/consts"
        "github.com/cloudwego/hertz/pkg/protocol/http1/ext"
)

var (
        errRequestHostRequired = errs.NewPublic("missing required Host header in request")
        errGetOnly             = errs.NewPublic("non-GET request received")
        errBodyTooLarge        = errs.New(errs.ErrBodyTooLarge, errs.ErrorTypePublic, "http1/req")
)

type h1Request struct {
        *protocol.Request
}

// String returns request representation.
//
// Returns error message instead of request representation on error.
//
// Use Write instead of String for performance-critical code.
func (h1Req *h1Request) String() string <span class="cov8" title="1">{
        w := bytebufferpool.Get()
        zw := network.NewWriter(w)
        if err := Write(h1Req.Request, zw); err != nil </span><span class="cov0" title="0">{
                return err.Error()
        }</span>
        <span class="cov8" title="1">if err := zw.Flush(); err != nil </span><span class="cov0" title="0">{
                return err.Error()
        }</span>
        <span class="cov8" title="1">s := string(w.B)
        bytebufferpool.Put(w)
        return s</span>
}

func GetHTTP1Request(req *protocol.Request) fmt.Stringer <span class="cov8" title="1">{
        return &amp;h1Request{req}
}</span>

// ReadHeaderAndLimitBody reads request from the given r, limiting the body size.
//
// If maxBodySize &gt; 0 and the body size exceeds maxBodySize,
// then errBodyTooLarge is returned.
//
// RemoveMultipartFormFiles or Reset must be called after
// reading multipart/form-data request in order to delete temporarily
// uploaded files.
//
// If MayContinue returns true, the caller must:
//
//   - Either send StatusExpectationFailed response if request headers don't
//     satisfy the caller.
//   - Or send StatusContinue response before reading request body
//     with ContinueReadBody.
//   - Or close the connection.
//
// io.EOF is returned if r is closed before reading the first header byte.
func ReadHeaderAndLimitBody(req *protocol.Request, r network.Reader, maxBodySize int, preParse ...bool) error <span class="cov8" title="1">{
        var parse bool
        if len(preParse) == 0 </span><span class="cov8" title="1">{
                parse = true
        }</span> else<span class="cov8" title="1"> {
                parse = preParse[0]
        }</span>
        <span class="cov8" title="1">req.ResetSkipHeader()

        if err := ReadHeader(&amp;req.Header, r); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return ReadLimitBody(req, r, maxBodySize, false, parse)</span>
}

// Read reads request (including body) from the given r.
//
// RemoveMultipartFormFiles or Reset must be called after
// reading multipart/form-data request in order to delete temporarily
// uploaded files.
//
// If MayContinue returns true, the caller must:
//
//   - Either send StatusExpectationFailed response if request headers don't
//     satisfy the caller.
//   - Or send StatusContinue response before reading request body
//     with ContinueReadBody.
//   - Or close the connection.
//
// io.EOF is returned if r is closed before reading the first header byte.
func Read(req *protocol.Request, r network.Reader, preParse ...bool) error <span class="cov8" title="1">{
        return ReadHeaderAndLimitBody(req, r, 0, preParse...)
}</span>

// Write writes request to w.
//
// Write doesn't flush request to w for performance reasons.
//
// See also WriteTo.
func Write(req *protocol.Request, w network.Writer) error <span class="cov8" title="1">{
        return write(req, w, false)
}</span>

// ProxyWrite is like Write but writes the request in the form
// expected by an HTTP proxy. In particular, ProxyWrite writes the
// initial Request-URI line of the request with an absolute URI, per
// section 5.3 of RFC 7230, including the scheme and host.
func ProxyWrite(req *protocol.Request, w network.Writer) error <span class="cov0" title="0">{
        return write(req, w, true)
}</span>

// write writes request to w.
// It supports proxy situation.
func write(req *protocol.Request, w network.Writer, usingProxy bool) error <span class="cov8" title="1">{
        if len(req.Header.Host()) == 0 || req.IsURIParsed() </span><span class="cov8" title="1">{
                uri := req.URI()
                host := uri.Host()
                if len(host) == 0 </span><span class="cov8" title="1">{
                        return errRequestHostRequired
                }</span>

                <span class="cov8" title="1">if len(req.Header.Host()) == 0 </span><span class="cov8" title="1">{
                        req.Header.SetHostBytes(host)
                }</span>

                <span class="cov8" title="1">ruri := uri.RequestURI()
                if bytes.Equal(req.Method(), bytestr.StrConnect) </span><span class="cov0" title="0">{
                        ruri = uri.Host()
                }</span> else<span class="cov8" title="1"> if usingProxy </span><span class="cov0" title="0">{
                        ruri = uri.FullURI()
                }</span>

                <span class="cov8" title="1">req.Header.SetRequestURIBytes(ruri)

                if len(uri.Username()) &gt; 0 </span><span class="cov8" title="1">{
                        // RequestHeader.SetBytesKV only uses RequestHeader.bufKV.key
                        // So we are free to use RequestHeader.bufKV.value as a scratch pad for
                        // the base64 encoding.
                        nl := len(uri.Username()) + len(uri.Password()) + 1
                        nb := nl + len(bytestr.StrBasicSpace)
                        tl := nb + base64.StdEncoding.EncodedLen(nl)

                        req.Header.InitBufValue(tl)
                        buf := req.Header.GetBufValue()[:0]
                        buf = append(buf, uri.Username()...)
                        buf = append(buf, bytestr.StrColon...)
                        buf = append(buf, uri.Password()...)
                        buf = append(buf, bytestr.StrBasicSpace...)
                        base64.StdEncoding.Encode(buf[nb:tl], buf[:nl])
                        req.Header.SetBytesKV(bytestr.StrAuthorization, buf[nl:tl])
                }</span>
        }

        <span class="cov8" title="1">if req.IsBodyStream() </span><span class="cov8" title="1">{
                return writeBodyStream(req, w)
        }</span>

        <span class="cov8" title="1">body := req.BodyBytes()
        err := handleMultipart(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error when handle multipart: %s", err)
        }</span>
        <span class="cov8" title="1">if req.OnlyMultipartForm() </span><span class="cov8" title="1">{
                m, _ := req.MultipartForm() // req.multipartForm != nil
                body, err = protocol.MarshalMultipartForm(m, req.MultipartFormBoundary())
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error when marshaling multipart form: %s", err)
                }</span>
                <span class="cov8" title="1">req.Header.SetMultipartFormBoundary(req.MultipartFormBoundary())</span>
        }

        <span class="cov8" title="1">hasBody := false
        if len(body) == 0 </span><span class="cov8" title="1">{
                body = req.PostArgString()
        }</span>
        <span class="cov8" title="1">if len(body) != 0 || !req.Header.IgnoreBody() </span><span class="cov8" title="1">{
                hasBody = true
                req.Header.SetContentLength(len(body))
        }</span>

        <span class="cov8" title="1">header := req.Header.Header()
        if _, err := w.WriteBinary(header); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write body
        <span class="cov8" title="1">if hasBody </span><span class="cov8" title="1">{
                w.WriteBinary(body) //nolint:errcheck
        }</span> else<span class="cov8" title="1"> if len(body) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("non-zero body for non-POST request. body=%q", body)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ContinueReadBodyStream reads request body in stream if request header contains
// 'Expect: 100-continue'.
//
// The caller must send StatusContinue response before calling this method.
//
// If maxBodySize &gt; 0 and the body size exceeds maxBodySize,
// then errBodyTooLarge is returned.
func ContinueReadBodyStream(req *protocol.Request, zr network.Reader, maxBodySize int, preParseMultipartForm ...bool) error <span class="cov8" title="1">{
        var err error
        contentLength := req.Header.ContentLength()
        if contentLength &gt; 0 </span><span class="cov8" title="1">{
                if len(preParseMultipartForm) == 0 || preParseMultipartForm[0] </span><span class="cov8" title="1">{
                        // Pre-read multipart form data of known length.
                        // This way we limit memory usage for large file uploads, since their contents
                        // is streamed into temporary files if file size exceeds defaultMaxInMemoryFileSize.
                        req.SetMultipartFormBoundary(string(req.Header.MultipartFormBoundary()))
                        if len(req.MultipartFormBoundary()) &gt; 0 &amp;&amp; len(req.Header.PeekContentEncoding()) == 0 </span><span class="cov0" title="0">{
                                err := protocol.ParseMultipartForm(zr.(io.Reader), req, contentLength, consts.DefaultMaxInMemoryFileSize)
                                if err != nil </span><span class="cov0" title="0">{
                                        req.Reset()
                                }</span>
                                <span class="cov0" title="0">return err</span>
                        }
                }
        }

        <span class="cov8" title="1">if contentLength == -2 </span><span class="cov8" title="1">{
                // identity body has no sense for http requests, since
                // the end of body is determined by connection close.
                // So just ignore request body for requests without
                // 'Content-Length' and 'Transfer-Encoding' headers.

                // refer to https://tools.ietf.org/html/rfc7230#section-3.3.2
                if !req.Header.IgnoreBody() </span><span class="cov8" title="1">{
                        req.Header.SetContentLength(0)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">bodyBuf := req.BodyBuffer()
        bodyBuf.Reset()
        bodyBuf.B, err = ext.ReadBodyWithStreaming(zr, contentLength, maxBodySize, bodyBuf.B)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, errs.ErrBodyTooLarge) </span><span class="cov8" title="1">{
                        req.Header.SetContentLength(contentLength)
                        req.ConstructBodyStream(bodyBuf, ext.AcquireBodyStream(bodyBuf, zr, req.Header.Trailer(), contentLength))

                        return nil
                }</span>
                <span class="cov8" title="1">if errors.Is(err, errs.ErrChunkedStream) </span><span class="cov8" title="1">{
                        req.ConstructBodyStream(bodyBuf, ext.AcquireBodyStream(bodyBuf, zr, req.Header.Trailer(), contentLength))
                        return nil
                }</span>
                <span class="cov0" title="0">req.Reset()
                return err</span>
        }

        <span class="cov8" title="1">req.ConstructBodyStream(bodyBuf, ext.AcquireBodyStream(bodyBuf, zr, req.Header.Trailer(), contentLength))
        return nil</span>
}

func ContinueReadBody(req *protocol.Request, r network.Reader, maxBodySize int, preParseMultipartForm ...bool) error <span class="cov8" title="1">{
        var err error
        contentLength := req.Header.ContentLength()
        if contentLength &gt; 0 </span><span class="cov8" title="1">{
                if maxBodySize &gt; 0 &amp;&amp; contentLength &gt; maxBodySize </span><span class="cov8" title="1">{
                        return errBodyTooLarge
                }</span>

                <span class="cov8" title="1">if len(preParseMultipartForm) == 0 || preParseMultipartForm[0] </span><span class="cov8" title="1">{
                        // Pre-read multipart form data of known length.
                        // This way we limit memory usage for large file uploads, since their contents
                        // is streamed into temporary files if file size exceeds defaultMaxInMemoryFileSize.
                        req.SetMultipartFormBoundary(string(req.Header.MultipartFormBoundary()))
                        if len(req.MultipartFormBoundary()) &gt; 0 &amp;&amp; len(req.Header.PeekContentEncoding()) == 0 </span><span class="cov8" title="1">{
                                err := protocol.ParseMultipartForm(r.(io.Reader), req, contentLength, consts.DefaultMaxInMemoryFileSize)
                                if err != nil </span><span class="cov0" title="0">{
                                        req.Reset()
                                }</span>
                                <span class="cov8" title="1">return err</span>
                        }
                }

                // This optimization is just suitable for ping-pong case and the ext.ReadBody is
                // a common function, so we just handle this situation before ext.ReadBody
                <span class="cov8" title="1">buf, err := r.Peek(contentLength)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">r.Skip(contentLength) // nolint: errcheck
                req.SetBodyRaw(buf)
                return nil</span>
        }

        <span class="cov8" title="1">if contentLength == -2 </span><span class="cov8" title="1">{
                // identity body has no sense for http requests, since
                // the end of body is determined by connection close.
                // So just ignore request body for requests without
                // 'Content-Length' and 'Transfer-Encoding' headers.

                // refer to https://tools.ietf.org/html/rfc7230#section-3.3.2
                if !req.Header.IgnoreBody() </span><span class="cov8" title="1">{
                        req.Header.SetContentLength(0)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">bodyBuf := req.BodyBuffer()
        bodyBuf.Reset()
        bodyBuf.B, err = ext.ReadBody(r, contentLength, maxBodySize, bodyBuf.B)
        if err != nil </span><span class="cov8" title="1">{
                req.Reset()
                return err
        }</span>

        <span class="cov8" title="1">if req.Header.ContentLength() == -1 </span><span class="cov8" title="1">{
                err = ext.ReadTrailer(req.Header.Trailer(), r)
                if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">req.Header.SetContentLength(len(bodyBuf.B))
        return nil</span>
}

func ReadBodyStream(req *protocol.Request, zr network.Reader, maxBodySize int, getOnly, preParseMultipartForm bool) error <span class="cov8" title="1">{
        if getOnly &amp;&amp; !req.Header.IsGet() </span><span class="cov0" title="0">{
                return errGetOnly
        }</span>

        <span class="cov8" title="1">if req.MayContinue() </span><span class="cov0" title="0">{
                // 'Expect: 100-continue' header found. Let the caller deciding
                // whether to read request body or
                // to return StatusExpectationFailed.
                return nil
        }</span>

        <span class="cov8" title="1">return ContinueReadBodyStream(req, zr, maxBodySize, preParseMultipartForm)</span>
}

func ReadLimitBody(req *protocol.Request, r network.Reader, maxBodySize int, getOnly, preParseMultipartForm bool) error <span class="cov8" title="1">{
        // Do not reset the request here - the caller must reset it before
        // calling this method.
        if getOnly &amp;&amp; !req.Header.IsGet() </span><span class="cov8" title="1">{
                return errGetOnly
        }</span>

        <span class="cov8" title="1">if req.MayContinue() </span><span class="cov8" title="1">{
                // 'Expect: 100-continue' header found. Let the caller deciding
                // whether to read request body or
                // to return StatusExpectationFailed.
                return nil
        }</span>

        <span class="cov8" title="1">return ContinueReadBody(req, r, maxBodySize, preParseMultipartForm)</span>
}

func writeBodyStream(req *protocol.Request, w network.Writer) error <span class="cov8" title="1">{
        var err error

        contentLength := req.Header.ContentLength()
        if contentLength &lt; 0 </span><span class="cov8" title="1">{
                lrSize := ext.LimitedReaderSize(req.BodyStream())
                if lrSize &gt;= 0 </span><span class="cov0" title="0">{
                        contentLength = int(lrSize)
                        if int64(contentLength) != lrSize </span><span class="cov0" title="0">{
                                contentLength = -1
                        }</span>
                        <span class="cov0" title="0">if contentLength &gt;= 0 </span><span class="cov0" title="0">{
                                req.Header.SetContentLength(contentLength)
                        }</span>
                }
        }
        <span class="cov8" title="1">if contentLength &gt;= 0 </span><span class="cov8" title="1">{
                if err = WriteHeader(&amp;req.Header, w); err == nil </span><span class="cov8" title="1">{
                        err = ext.WriteBodyFixedSize(w, req.BodyStream(), int64(contentLength))
                }</span>
        } else<span class="cov8" title="1"> {
                req.Header.SetContentLength(-1)
                err = WriteHeader(&amp;req.Header, w)
                if err == nil </span><span class="cov8" title="1">{
                        err = ext.WriteBodyChunked(w, req.BodyStream())
                }</span>
                <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                        err = ext.WriteTrailer(req.Header.Trailer(), w)
                }</span>
        }
        <span class="cov8" title="1">err1 := req.CloseBodyStream()
        if err == nil </span><span class="cov8" title="1">{
                err = err1
        }</span>
        <span class="cov8" title="1">return err</span>
}

func handleMultipart(req *protocol.Request) error <span class="cov8" title="1">{
        if len(req.MultipartFiles()) == 0 &amp;&amp; len(req.MultipartFields()) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">var err error
        bodyBuffer := &amp;bytes.Buffer{}
        w := multipart.NewWriter(bodyBuffer)
        if len(req.MultipartFiles()) &gt; 0 </span><span class="cov8" title="1">{
                for _, f := range req.MultipartFiles() </span><span class="cov8" title="1">{
                        if f.Reader != nil </span><span class="cov8" title="1">{
                                err = protocol.WriteMultipartFormFile(w, f.ParamName, f.Name, f.Reader)
                        }</span> else<span class="cov0" title="0"> {
                                err = protocol.AddFile(w, f.ParamName, f.Name)
                        }</span>
                        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">if len(req.MultipartFields()) &gt; 0 </span><span class="cov8" title="1">{
                for _, mf := range req.MultipartFields() </span><span class="cov8" title="1">{
                        if err = protocol.AddMultipartFormField(w, mf); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">req.Header.Set(consts.HeaderContentType, w.FormDataContentType())
        if err = w.Close(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">r := multipart.NewReader(bodyBuffer, w.Boundary())
        f, err := r.ReadForm(int64(bodyBuffer.Len()))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">protocol.SetMultipartFormWithBoundary(req, f, w.Boundary())

        return nil</span>
}
</pre>
		
		<pre class="file" id="file85" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015-present Aliaksandr Valialkin, VertaMedia, Kirill Danshin, Erik Dubbelboer, FastHTTP Authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This file may have been modified by CloudWeGo authors. All CloudWeGo
 * Modifications are Copyright 2022 CloudWeGo Authors.
 */

package resp

import (
        "bytes"
        "errors"
        "fmt"
        "io"
        "strings"

        "github.com/cloudwego/hertz/internal/bytesconv"
        "github.com/cloudwego/hertz/internal/bytestr"
        errs "github.com/cloudwego/hertz/pkg/common/errors"
        "github.com/cloudwego/hertz/pkg/common/utils"
        "github.com/cloudwego/hertz/pkg/network"
        "github.com/cloudwego/hertz/pkg/protocol"
        "github.com/cloudwego/hertz/pkg/protocol/consts"
        "github.com/cloudwego/hertz/pkg/protocol/http1/ext"
)

var errTimeout = errs.New(errs.ErrTimeout, errs.ErrorTypePublic, "read response header")

// Read reads response header from r.
//
// io.EOF is returned if r is closed before reading the first header byte.
func ReadHeader(h *protocol.ResponseHeader, r network.Reader) error <span class="cov8" title="1">{
        n := 1
        for </span><span class="cov8" title="1">{
                err := tryRead(h, r, n)
                if err == nil </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">if !errors.Is(err, errs.ErrNeedMore) </span><span class="cov8" title="1">{
                        h.ResetSkipNormalize()
                        return err
                }</span>

                // No more data available on the wire, try block peek(by netpoll)
                <span class="cov8" title="1">if n == r.Len() </span><span class="cov8" title="1">{
                        n++

                        continue</span>
                }
                <span class="cov8" title="1">n = r.Len()</span>
        }
}

// WriteHeader writes response header to w.
func WriteHeader(h *protocol.ResponseHeader, w network.Writer) error <span class="cov8" title="1">{
        header := h.Header()
        h.SetHeaderLength(len(header))
        _, err := w.WriteBinary(header)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ConnectionUpgrade returns true if 'Connection: Upgrade' header is set.
func ConnectionUpgrade(h *protocol.ResponseHeader) bool <span class="cov8" title="1">{
        return ext.HasHeaderValue(h.Peek(consts.HeaderConnection), bytestr.StrKeepAlive)
}</span>

func tryRead(h *protocol.ResponseHeader, r network.Reader, n int) error <span class="cov8" title="1">{
        h.ResetSkipNormalize()
        b, err := r.Peek(n)
        if len(b) == 0 </span><span class="cov8" title="1">{
                // Return ErrTimeout on any timeout.
                if err != nil &amp;&amp; strings.Contains(err.Error(), "timeout") </span><span class="cov0" title="0">{
                        return errTimeout
                }</span>
                // treat all other errors on the first byte read as EOF
                <span class="cov8" title="1">if n == 1 || err == io.EOF </span><span class="cov8" title="1">{
                        return io.EOF
                }</span>

                <span class="cov0" title="0">return fmt.Errorf("error when reading response headers: %s", err)</span>
        }
        <span class="cov8" title="1">b = ext.MustPeekBuffered(r)
        headersLen, errParse := parse(h, b)
        if errParse != nil </span><span class="cov8" title="1">{
                return ext.HeaderError("response", err, errParse, b)
        }</span>
        <span class="cov8" title="1">ext.MustDiscard(r, headersLen)
        return nil</span>
}

func parseHeaders(h *protocol.ResponseHeader, buf []byte) (int, error) <span class="cov8" title="1">{
        // 'identity' content-length by default
        h.InitContentLengthWithValue(-2)

        var s ext.HeaderScanner
        s.B = buf
        s.DisableNormalizing = h.IsDisableNormalizing()
        var err error
        for s.Next() </span><span class="cov8" title="1">{
                if len(s.Key) &gt; 0 </span><span class="cov8" title="1">{
                        switch s.Key[0] | 0x20 </span>{
                        case 'c':<span class="cov8" title="1">
                                if utils.CaseInsensitiveCompare(s.Key, bytestr.StrContentType) </span><span class="cov8" title="1">{
                                        h.SetContentTypeBytes(s.Value)
                                        continue</span>
                                }
                                <span class="cov8" title="1">if utils.CaseInsensitiveCompare(s.Key, bytestr.StrContentEncoding) </span><span class="cov8" title="1">{
                                        h.SetContentEncodingBytes(s.Value)
                                        continue</span>
                                }
                                <span class="cov8" title="1">if utils.CaseInsensitiveCompare(s.Key, bytestr.StrContentLength) </span><span class="cov8" title="1">{
                                        var contentLength int
                                        if h.ContentLength() != -1 </span><span class="cov8" title="1">{
                                                if contentLength, err = protocol.ParseContentLength(s.Value); err != nil </span><span class="cov0" title="0">{
                                                        h.InitContentLengthWithValue(-2)
                                                }</span> else<span class="cov8" title="1"> {
                                                        h.InitContentLengthWithValue(contentLength)
                                                        h.SetContentLengthBytes(s.Value)
                                                }</span>
                                        }
                                        <span class="cov8" title="1">continue</span>
                                }
                                <span class="cov0" title="0">if utils.CaseInsensitiveCompare(s.Key, bytestr.StrConnection) </span><span class="cov0" title="0">{
                                        if bytes.Equal(s.Value, bytestr.StrClose) </span><span class="cov0" title="0">{
                                                h.SetConnectionClose(true)
                                        }</span> else<span class="cov0" title="0"> {
                                                h.SetConnectionClose(false)
                                                h.AddArgBytes(s.Key, s.Value, protocol.ArgsHasValue)
                                        }</span>
                                        <span class="cov0" title="0">continue</span>
                                }
                        case 's':<span class="cov8" title="1">
                                if utils.CaseInsensitiveCompare(s.Key, bytestr.StrServer) </span><span class="cov8" title="1">{
                                        h.SetServerBytes(s.Value)
                                        continue</span>
                                }
                                <span class="cov8" title="1">if utils.CaseInsensitiveCompare(s.Key, bytestr.StrSetCookie) </span><span class="cov8" title="1">{
                                        h.ParseSetCookie(s.Value)
                                        continue</span>
                                }
                        case 't':<span class="cov8" title="1">
                                if utils.CaseInsensitiveCompare(s.Key, bytestr.StrTransferEncoding) </span><span class="cov8" title="1">{
                                        if !bytes.Equal(s.Value, bytestr.StrIdentity) </span><span class="cov8" title="1">{
                                                h.InitContentLengthWithValue(-1)
                                                h.SetArgBytes(bytestr.StrTransferEncoding, bytestr.StrChunked, protocol.ArgsHasValue)
                                        }</span>
                                        <span class="cov8" title="1">continue</span>
                                }
                                <span class="cov8" title="1">if utils.CaseInsensitiveCompare(s.Key, bytestr.StrTrailer) </span><span class="cov8" title="1">{
                                        err = h.Trailer().SetTrailers(s.Value)
                                        continue</span>
                                }
                        }
                        <span class="cov8" title="1">h.AddArgBytes(s.Key, s.Value, protocol.ArgsHasValue)</span>
                }
        }
        <span class="cov8" title="1">if s.Err != nil </span><span class="cov0" title="0">{
                h.SetConnectionClose(true)
                return 0, s.Err
        }</span>

        <span class="cov8" title="1">if h.ContentLength() &lt; 0 </span><span class="cov8" title="1">{
                h.SetContentLengthBytes(h.ContentLengthBytes()[:0])
        }</span>
        <span class="cov8" title="1">if h.ContentLength() == -2 &amp;&amp; !ConnectionUpgrade(h) &amp;&amp; !h.MustSkipContentLength() </span><span class="cov8" title="1">{
                h.SetArgBytes(bytestr.StrTransferEncoding, bytestr.StrIdentity, protocol.ArgsHasValue)
                h.SetConnectionClose(true)
        }</span>
        <span class="cov8" title="1">if !h.IsHTTP11() &amp;&amp; !h.ConnectionClose() </span><span class="cov8" title="1">{
                // close connection for non-http/1.1 response unless 'Connection: keep-alive' is set.
                v := h.PeekArgBytes(bytestr.StrConnection)
                h.SetConnectionClose(!ext.HasHeaderValue(v, bytestr.StrKeepAlive))
        }</span>

        <span class="cov8" title="1">return len(buf) - len(s.B), err</span>
}

func parse(h *protocol.ResponseHeader, buf []byte) (int, error) <span class="cov8" title="1">{
        m, err := parseFirstLine(h, buf)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>
        <span class="cov8" title="1">n, err := parseHeaders(h, buf[m:])
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return m + n, nil</span>
}

func parseFirstLine(h *protocol.ResponseHeader, buf []byte) (int, error) <span class="cov8" title="1">{
        bNext := buf
        var b []byte
        var err error
        for len(b) == 0 </span><span class="cov8" title="1">{
                if b, bNext, err = utils.NextLine(bNext); err != nil </span><span class="cov8" title="1">{
                        return 0, err
                }</span>
        }

        // parse protocol
        <span class="cov8" title="1">n := bytes.IndexByte(b, ' ')
        if n &lt; 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("cannot find whitespace in the first line of response %q", buf)
        }</span>

        <span class="cov8" title="1">isHTTP11 := bytes.Equal(b[:n], bytestr.StrHTTP11)
        if !isHTTP11 </span><span class="cov8" title="1">{
                h.SetProtocol(consts.HTTP10)
        }</span> else<span class="cov8" title="1"> {
                h.SetProtocol(consts.HTTP11)
        }</span>

        <span class="cov8" title="1">b = b[n+1:]

        // parse status code
        var statusCode int
        statusCode, n, err = bytesconv.ParseUintBuf(b)
        h.SetStatusCode(statusCode)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("cannot parse response status code: %s. Response %q", err, buf)
        }</span>
        <span class="cov8" title="1">if len(b) &gt; n &amp;&amp; b[n] != ' ' </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("unexpected char at the end of status code. Response %q", buf)
        }</span>

        <span class="cov8" title="1">return len(buf) - len(bNext), nil</span>
}
</pre>
		
		<pre class="file" id="file86" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015-present Aliaksandr Valialkin, VertaMedia, Kirill Danshin, Erik Dubbelboer, FastHTTP Authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This file may have been modified by CloudWeGo authors. All CloudWeGo
 * Modifications are Copyright 2022 CloudWeGo Authors.
 */

package resp

import (
        "errors"
        "fmt"
        "io"
        "runtime"
        "sync"

        "github.com/cloudwego/hertz/pkg/common/bytebufferpool"
        errs "github.com/cloudwego/hertz/pkg/common/errors"
        "github.com/cloudwego/hertz/pkg/common/hlog"
        "github.com/cloudwego/hertz/pkg/network"
        "github.com/cloudwego/hertz/pkg/protocol"
        "github.com/cloudwego/hertz/pkg/protocol/consts"
        "github.com/cloudwego/hertz/pkg/protocol/http1/ext"
)

// ErrBodyStreamWritePanic is returned when panic happens during writing body stream.
type ErrBodyStreamWritePanic struct {
        error
}

type h1Response struct {
        *protocol.Response
}

// String returns request representation.
//
// Returns error message instead of request representation on error.
//
// Use Write instead of String for performance-critical code.
func (h1Resp *h1Response) String() string <span class="cov0" title="0">{
        w := bytebufferpool.Get()
        zw := network.NewWriter(w)
        if err := Write(h1Resp.Response, zw); err != nil </span><span class="cov0" title="0">{
                return err.Error()
        }</span>
        <span class="cov0" title="0">if err := zw.Flush(); err != nil </span><span class="cov0" title="0">{
                return err.Error()
        }</span>
        <span class="cov0" title="0">s := string(w.B)
        bytebufferpool.Put(w)
        return s</span>
}

func GetHTTP1Response(resp *protocol.Response) fmt.Stringer <span class="cov0" title="0">{
        return &amp;h1Response{resp}
}</span>

// ReadHeaderAndLimitBody reads response from the given r, limiting the body size.
//
// If maxBodySize &gt; 0 and the body size exceeds maxBodySize,
// then ErrBodyTooLarge is returned.
//
// io.EOF is returned if r is closed before reading the first header byte.
func ReadHeaderAndLimitBody(resp *protocol.Response, r network.Reader, maxBodySize int) error <span class="cov8" title="1">{
        resp.ResetBody()
        err := ReadHeader(&amp;resp.Header, r)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if resp.Header.StatusCode() == consts.StatusContinue </span><span class="cov8" title="1">{
                // Read the next response according to http://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html .
                if err = ReadHeader(&amp;resp.Header, r); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">if !resp.MustSkipBody() </span><span class="cov8" title="1">{
                bodyBuf := resp.BodyBuffer()
                bodyBuf.Reset()
                bodyBuf.B, err = ext.ReadBody(r, resp.Header.ContentLength(), maxBodySize, bodyBuf.B)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">if resp.Header.ContentLength() == -1 </span><span class="cov8" title="1">{
                        err = ext.ReadTrailer(resp.Header.Trailer(), r)
                        if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">resp.Header.SetContentLength(len(bodyBuf.B))</span>
        }

        <span class="cov8" title="1">return nil</span>
}

type clientRespStream struct {
        r             io.Reader
        closeCallback func(shouldClose bool) error
}

func (c *clientRespStream) Close() (err error) <span class="cov8" title="1">{
        runtime.SetFinalizer(c, nil)
        // If error happened in release, the connection may be in abnormal state.
        // Close it in the callback in order to avoid other unexpected problems.
        err = ext.ReleaseBodyStream(c.r)
        shouldClose := false
        if err != nil </span><span class="cov8" title="1">{
                shouldClose = true
                hlog.Warnf("connection will be closed instead of recycled because an error occurred during the stream body release: %s", err.Error())
        }</span>
        <span class="cov8" title="1">if c.closeCallback != nil </span><span class="cov8" title="1">{
                err = c.closeCallback(shouldClose)
        }</span>
        <span class="cov8" title="1">c.reset()
        return</span>
}

func (c *clientRespStream) Read(p []byte) (n int, err error) <span class="cov8" title="1">{
        return c.r.Read(p)
}</span>

func (c *clientRespStream) reset() <span class="cov8" title="1">{
        c.closeCallback = nil
        c.r = nil
        clientRespStreamPool.Put(c)
}</span>

var clientRespStreamPool = sync.Pool{
        New: func() interface{} <span class="cov8" title="1">{
                return &amp;clientRespStream{}
        }</span>,
}

func convertClientRespStream(bs io.Reader, fn func(shouldClose bool) error) *clientRespStream <span class="cov8" title="1">{
        clientStream := clientRespStreamPool.Get().(*clientRespStream)
        clientStream.r = bs
        clientStream.closeCallback = fn
        runtime.SetFinalizer(clientStream, (*clientRespStream).Close)
        return clientStream
}</span>

// ReadBodyStream reads response body in stream
func ReadBodyStream(resp *protocol.Response, r network.Reader, maxBodySize int, closeCallBack func(shouldClose bool) error) error <span class="cov8" title="1">{
        resp.ResetBody()
        err := ReadHeader(&amp;resp.Header, r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if resp.Header.StatusCode() == consts.StatusContinue </span><span class="cov0" title="0">{
                // Read the next response according to http://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html .
                if err = ReadHeader(&amp;resp.Header, r); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">if resp.MustSkipBody() </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">bodyBuf := resp.BodyBuffer()
        bodyBuf.Reset()
        bodyBuf.B, err = ext.ReadBodyWithStreaming(r, resp.Header.ContentLength(), maxBodySize, bodyBuf.B)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, errs.ErrBodyTooLarge) </span><span class="cov0" title="0">{
                        bodyStream := ext.AcquireBodyStream(bodyBuf, r, resp.Header.Trailer(), resp.Header.ContentLength())
                        resp.ConstructBodyStream(bodyBuf, convertClientRespStream(bodyStream, closeCallBack))
                        return nil
                }</span>

                <span class="cov8" title="1">if errors.Is(err, errs.ErrChunkedStream) </span><span class="cov8" title="1">{
                        bodyStream := ext.AcquireBodyStream(bodyBuf, r, resp.Header.Trailer(), -1)
                        resp.ConstructBodyStream(bodyBuf, convertClientRespStream(bodyStream, closeCallBack))
                        return nil
                }</span>

                <span class="cov0" title="0">resp.Reset()
                return err</span>
        }

        <span class="cov8" title="1">bodyStream := ext.AcquireBodyStream(bodyBuf, r, resp.Header.Trailer(), resp.Header.ContentLength())
        resp.ConstructBodyStream(bodyBuf, convertClientRespStream(bodyStream, closeCallBack))
        return nil</span>
}

// Read reads response (including body) from the given r.
//
// io.EOF is returned if r is closed before reading the first header byte.
func Read(resp *protocol.Response, r network.Reader) error <span class="cov8" title="1">{
        return ReadHeaderAndLimitBody(resp, r, 0)
}</span>

// Write writes response to w.
//
// Write doesn't flush response to w for performance reasons.
//
// See also WriteTo.
func Write(resp *protocol.Response, w network.Writer) error <span class="cov8" title="1">{
        sendBody := !resp.MustSkipBody()

        if resp.IsBodyStream() </span><span class="cov8" title="1">{
                return writeBodyStream(resp, w, sendBody)
        }</span>

        <span class="cov8" title="1">body := resp.BodyBytes()
        bodyLen := len(body)
        if sendBody || bodyLen &gt; 0 </span><span class="cov8" title="1">{
                resp.Header.SetContentLength(bodyLen)
        }</span>

        <span class="cov8" title="1">header := resp.Header.Header()
        _, err := w.WriteBinary(header)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">resp.Header.SetHeaderLength(len(header))
        // Write body
        if sendBody &amp;&amp; bodyLen &gt; 0 </span><span class="cov8" title="1">{
                _, err = w.WriteBinary(body)
        }</span>
        <span class="cov8" title="1">return err</span>
}

func writeBodyStream(resp *protocol.Response, w network.Writer, sendBody bool) (err error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov8" title="1">{
                        err = &amp;ErrBodyStreamWritePanic{
                                error: fmt.Errorf("panic while writing body stream: %+v", r),
                        }
                }</span>
        }()

        <span class="cov8" title="1">contentLength := resp.Header.ContentLength()
        if contentLength &lt; 0 </span><span class="cov8" title="1">{
                lrSize := ext.LimitedReaderSize(resp.BodyStream())
                if lrSize &gt;= 0 </span><span class="cov0" title="0">{
                        contentLength = int(lrSize)
                        if int64(contentLength) != lrSize </span><span class="cov0" title="0">{
                                contentLength = -1
                        }</span>
                        <span class="cov0" title="0">if contentLength &gt;= 0 </span><span class="cov0" title="0">{
                                resp.Header.SetContentLength(contentLength)
                        }</span>
                }
        }
        <span class="cov8" title="1">if contentLength &gt;= 0 </span><span class="cov8" title="1">{
                if err = WriteHeader(&amp;resp.Header, w); err == nil &amp;&amp; sendBody </span><span class="cov8" title="1">{
                        if resp.ImmediateHeaderFlush </span><span class="cov8" title="1">{
                                err = w.Flush()
                        }</span>
                        <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                                err = ext.WriteBodyFixedSize(w, resp.BodyStream(), int64(contentLength))
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                resp.Header.SetContentLength(-1)
                if err = WriteHeader(&amp;resp.Header, w); err == nil &amp;&amp; sendBody </span><span class="cov8" title="1">{
                        if resp.ImmediateHeaderFlush </span><span class="cov8" title="1">{
                                err = w.Flush()
                        }</span>
                        <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                                err = ext.WriteBodyChunked(w, resp.BodyStream())
                        }</span>
                        <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                                err = ext.WriteTrailer(resp.Header.Trailer(), w)
                        }</span>
                }
        }
        <span class="cov8" title="1">err1 := resp.CloseBodyStream()
        if err == nil </span><span class="cov8" title="1">{
                err = err1
        }</span>
        <span class="cov8" title="1">return err</span>
}
</pre>
		
		<pre class="file" id="file87" style="display: none">/*
 * Copyright 2023 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package resp

import (
        "runtime"
        "sync"

        "github.com/cloudwego/hertz/pkg/network"
        "github.com/cloudwego/hertz/pkg/protocol"
        "github.com/cloudwego/hertz/pkg/protocol/http1/ext"
)

var chunkReaderPool sync.Pool

func init() <span class="cov8" title="1">{
        chunkReaderPool = sync.Pool{
                New: func() interface{} </span><span class="cov8" title="1">{
                        return &amp;chunkedBodyWriter{}
                }</span>,
        }
}

type chunkedBodyWriter struct {
        sync.Once
        finalizeErr error
        wroteHeader bool
        r           *protocol.Response
        w           network.Writer
}

// Write will encode chunked p before writing
// It will only return the length of p and a nil error if the writing is successful or 0, error otherwise.
//
// NOTE: Write will use the user buffer to flush.
// Before flush successfully, the buffer b should be valid.
func (c *chunkedBodyWriter) Write(p []byte) (n int, err error) <span class="cov8" title="1">{
        if !c.wroteHeader </span><span class="cov8" title="1">{
                c.r.Header.SetContentLength(-1)
                if err = WriteHeader(&amp;c.r.Header, c.w); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">c.wroteHeader = true</span>
        }
        <span class="cov8" title="1">if err = ext.WriteChunk(c.w, p, false); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">return len(p), nil</span>
}

func (c *chunkedBodyWriter) Flush() error <span class="cov8" title="1">{
        return c.w.Flush()
}</span>

// Finalize will write the ending chunk as well as trailer and flush the writer.
// Warning: do not call this method by yourself, unless you know what you are doing.
func (c *chunkedBodyWriter) Finalize() error <span class="cov8" title="1">{
        c.Do(func() </span><span class="cov8" title="1">{
                // in case no actual data from user
                if !c.wroteHeader </span><span class="cov8" title="1">{
                        c.r.Header.SetContentLength(-1)
                        if c.finalizeErr = WriteHeader(&amp;c.r.Header, c.w); c.finalizeErr != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">c.wroteHeader = true</span>
                }
                <span class="cov8" title="1">c.finalizeErr = ext.WriteChunk(c.w, nil, true)
                if c.finalizeErr != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">c.finalizeErr = ext.WriteTrailer(c.r.Header.Trailer(), c.w)</span>
        })
        <span class="cov8" title="1">return c.finalizeErr</span>
}

func (c *chunkedBodyWriter) release() <span class="cov8" title="1">{
        c.r = nil
        c.w = nil
        c.finalizeErr = nil
        c.wroteHeader = false
        chunkReaderPool.Put(c)
}</span>

func NewChunkedBodyWriter(r *protocol.Response, w network.Writer) network.ExtWriter <span class="cov8" title="1">{
        extWriter := chunkReaderPool.Get().(*chunkedBodyWriter)
        extWriter.r = r
        extWriter.w = w
        extWriter.Once = sync.Once{}
        runtime.SetFinalizer(extWriter, (*chunkedBodyWriter).release)
        return extWriter
}</span>
</pre>
		
		<pre class="file" id="file88" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package http1

import (
        "context"
        "crypto/tls"
        "errors"
        "io"
        "net"
        "sync"
        "time"

        "github.com/cloudwego/hertz/internal/bytestr"
        internalStats "github.com/cloudwego/hertz/internal/stats"
        "github.com/cloudwego/hertz/pkg/app"
        "github.com/cloudwego/hertz/pkg/app/server/render"
        errs "github.com/cloudwego/hertz/pkg/common/errors"
        "github.com/cloudwego/hertz/pkg/common/tracer/stats"
        "github.com/cloudwego/hertz/pkg/common/tracer/traceinfo"
        "github.com/cloudwego/hertz/pkg/common/utils"
        "github.com/cloudwego/hertz/pkg/network"
        "github.com/cloudwego/hertz/pkg/protocol"
        "github.com/cloudwego/hertz/pkg/protocol/consts"
        "github.com/cloudwego/hertz/pkg/protocol/http1/ext"
        "github.com/cloudwego/hertz/pkg/protocol/http1/req"
        "github.com/cloudwego/hertz/pkg/protocol/http1/resp"
        "github.com/cloudwego/hertz/pkg/protocol/suite"
)

func init() <span class="cov8" title="1">{
        if b, err := utils.GetBoolFromEnv("HERTZ_DISABLE_REQUEST_CONTEXT_POOL"); err == nil </span><span class="cov0" title="0">{
                disabaleRequestContextPool = b
        }</span>
}

// NextProtoTLS is the NPN/ALPN protocol negotiated during
// HTTP/1.1's TLS setup.
// Also used for server addressing
const NextProtoTLS = suite.HTTP1

var (
        errHijacked        = errs.New(errs.ErrHijacked, errs.ErrorTypePublic, nil)
        errIdleTimeout     = errs.New(errs.ErrIdleTimeout, errs.ErrorTypePrivate, nil)
        errShortConnection = errs.New(errs.ErrShortConnection, errs.ErrorTypePublic, "server is going to close the connection")
        errUnexpectedEOF   = errs.NewPublic(io.ErrUnexpectedEOF.Error() + " when reading request")

        disabaleRequestContextPool = false
)

type Option struct {
        StreamRequestBody             bool
        GetOnly                       bool
        NoDefaultDate                 bool
        NoDefaultContentType          bool
        DisablePreParseMultipartForm  bool
        DisableKeepalive              bool
        NoDefaultServerHeader         bool
        DisableHeaderNamesNormalizing bool
        MaxRequestBodySize            int
        IdleTimeout                   time.Duration
        ReadTimeout                   time.Duration
        ServerName                    []byte
        TLS                           *tls.Config
        HTMLRender                    render.HTMLRender
        EnableTrace                   bool
        ContinueHandler               func(header *protocol.RequestHeader) bool
        HijackConnHandle              func(c network.Conn, h app.HijackHandler)
}

type Server struct {
        Option
        Core suite.Core

        eventStackPool *sync.Pool
}

func (s Server) getRequestContext() *app.RequestContext <span class="cov8" title="1">{
        if disabaleRequestContextPool </span><span class="cov8" title="1">{
                return &amp;app.RequestContext{}
        }</span>
        <span class="cov8" title="1">return s.Core.GetCtxPool().Get().(*app.RequestContext)</span>
}

func (s Server) putRequestContext(ctx *app.RequestContext) <span class="cov8" title="1">{
        if disabaleRequestContextPool </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">ctx.Reset()
        s.Core.GetCtxPool().Put(ctx)</span>
}

func (s Server) Serve(c context.Context, conn network.Conn) (err error) <span class="cov8" title="1">{
        var (
                zr network.Reader
                zw network.Writer

                serverName      []byte
                isHTTP11        bool
                connectionClose bool

                continueReadingRequest = true

                hijackHandler app.HijackHandler

                // HTTP1 path
                // 1. Get a request context
                // 2. Prepare it
                // 3. Process it
                // 4. Reset and recycle(in pooled mode)
                ctx = s.getRequestContext()

                traceCtl        = s.Core.GetTracer()
                eventsToTrigger *eventStack

                // Use a new variable to hold the standard context to avoid modify the initial
                // context.
                cc = c
        )

        if s.EnableTrace </span><span class="cov8" title="1">{
                eventsToTrigger = s.eventStackPool.Get().(*eventStack)
        }</span>

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if s.EnableTrace </span><span class="cov8" title="1">{
                        // in case of error, we need to trigger all events
                        if eventsToTrigger != nil </span><span class="cov8" title="1">{
                                for last := eventsToTrigger.pop(); last != nil; last = eventsToTrigger.pop() </span><span class="cov8" title="1">{
                                        last(ctx.GetTraceInfo(), err)
                                }</span>
                                <span class="cov8" title="1">s.eventStackPool.Put(eventsToTrigger)</span>
                        }
                        <span class="cov8" title="1">if shouldRecordInTraceError(err) </span><span class="cov8" title="1">{
                                traceCtl.DoFinish(cc, ctx, err)
                        }</span> else<span class="cov8" title="1"> {
                                traceCtl.DoFinish(cc, ctx, nil)
                        }</span>
                }

                // Hijack may release and close the connection already
                <span class="cov8" title="1">if zr != nil &amp;&amp; !errors.Is(err, errs.ErrHijacked) </span><span class="cov8" title="1">{
                        zr.Release() //nolint:errcheck
                        zr = nil
                }</span>

                <span class="cov8" title="1">if ctx.IsExiled() </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov8" title="1">s.putRequestContext(ctx)</span>
        }()

        <span class="cov8" title="1">ctx.HTMLRender = s.HTMLRender
        ctx.SetConn(conn)
        ctx.Request.SetIsTLS(s.TLS != nil)
        ctx.SetEnableTrace(s.EnableTrace)

        if !s.NoDefaultServerHeader </span><span class="cov8" title="1">{
                serverName = s.ServerName
        }</span>

        <span class="cov8" title="1">connRequestNum := uint64(0)

        for </span><span class="cov8" title="1">{
                connRequestNum++

                if zr == nil </span><span class="cov8" title="1">{
                        zr = ctx.GetReader()
                }</span>

                // If this is a keep-alive connection we want to try and read the first bytes
                // within the idle time.
                <span class="cov8" title="1">if connRequestNum &gt; 1 </span><span class="cov8" title="1">{
                        ctx.GetConn().SetReadTimeout(s.IdleTimeout) //nolint:errcheck

                        _, err = zr.Peek(4)
                        // This is not the first request, and we haven't read a single byte
                        // of a new request yet. This means it's just a keep-alive connection
                        // closing down either because the remote closed it or because
                        // or a read timeout on our side. Either way just close the connection
                        // and don't return any error response.
                        if err != nil </span><span class="cov0" title="0">{
                                err = errIdleTimeout
                                return
                        }</span>

                        // Reset the real read timeout for the coming request
                        <span class="cov8" title="1">ctx.GetConn().SetReadTimeout(s.ReadTimeout)</span> //nolint:errcheck
                }

                <span class="cov8" title="1">if s.EnableTrace </span><span class="cov8" title="1">{
                        cc = traceCtl.DoStart(c, ctx)
                        internalStats.Record(ctx.GetTraceInfo(), stats.ReadHeaderStart, err)
                        eventsToTrigger.push(func(ti traceinfo.TraceInfo, err error) </span><span class="cov8" title="1">{
                                internalStats.Record(ti, stats.ReadHeaderFinish, err)
                        }</span>)
                }

                <span class="cov8" title="1">ctx.Response.Header.SetNoDefaultDate(s.NoDefaultDate)
                ctx.Response.Header.SetNoDefaultContentType(s.NoDefaultContentType)

                if s.DisableHeaderNamesNormalizing </span><span class="cov0" title="0">{
                        ctx.Request.Header.DisableNormalizing()
                        ctx.Response.Header.DisableNormalizing()
                }</span>

                // Read Headers
                <span class="cov8" title="1">if err = req.ReadHeader(&amp;ctx.Request.Header, zr); err == nil </span><span class="cov8" title="1">{
                        if s.EnableTrace </span><span class="cov8" title="1">{
                                // read header finished
                                if last := eventsToTrigger.pop(); last != nil </span><span class="cov8" title="1">{
                                        last(ctx.GetTraceInfo(), err)
                                }</span>
                                <span class="cov8" title="1">internalStats.Record(ctx.GetTraceInfo(), stats.ReadBodyStart, err)
                                eventsToTrigger.push(func(ti traceinfo.TraceInfo, err error) </span><span class="cov8" title="1">{
                                        internalStats.Record(ti, stats.ReadBodyFinish, err)
                                }</span>)
                        }
                        // Read body
                        <span class="cov8" title="1">if s.StreamRequestBody </span><span class="cov0" title="0">{
                                err = req.ReadBodyStream(&amp;ctx.Request, zr, s.MaxRequestBodySize, s.GetOnly, !s.DisablePreParseMultipartForm)
                        }</span> else<span class="cov8" title="1"> {
                                err = req.ReadLimitBody(&amp;ctx.Request, zr, s.MaxRequestBodySize, s.GetOnly, !s.DisablePreParseMultipartForm)
                        }</span>
                }

                <span class="cov8" title="1">if s.EnableTrace </span><span class="cov8" title="1">{
                        if ctx.Request.Header.ContentLength() &gt;= 0 </span><span class="cov8" title="1">{
                                ctx.GetTraceInfo().Stats().SetRecvSize(len(ctx.Request.Header.RawHeaders()) + ctx.Request.Header.ContentLength())
                        }</span> else<span class="cov8" title="1"> {
                                ctx.GetTraceInfo().Stats().SetRecvSize(0)
                        }</span>
                        // read body finished
                        <span class="cov8" title="1">if last := eventsToTrigger.pop(); last != nil </span><span class="cov8" title="1">{
                                last(ctx.GetTraceInfo(), err)
                        }</span>
                }

                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        if errors.Is(err, errs.ErrNothingRead) </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        <span class="cov8" title="1">if err == io.EOF </span><span class="cov0" title="0">{
                                return errUnexpectedEOF
                        }</span>
                        <span class="cov8" title="1">writeErrorResponse(zw, ctx, serverName, err)
                        return</span>
                }

                // 'Expect: 100-continue' request handling.
                // See https://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html#sec8.2.3 for details.
                <span class="cov8" title="1">if ctx.Request.MayContinue() </span><span class="cov8" title="1">{
                        // Allow the ability to deny reading the incoming request body
                        if s.ContinueHandler != nil </span><span class="cov8" title="1">{
                                if continueReadingRequest = s.ContinueHandler(&amp;ctx.Request.Header); !continueReadingRequest </span><span class="cov8" title="1">{
                                        ctx.SetStatusCode(consts.StatusExpectationFailed)
                                }</span>
                        }

                        <span class="cov8" title="1">if continueReadingRequest </span><span class="cov8" title="1">{
                                zw = ctx.GetWriter()
                                // Send 'HTTP/1.1 100 Continue' response.
                                _, err = zw.WriteBinary(bytestr.StrResponseContinue)
                                if err != nil </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov8" title="1">err = zw.Flush()
                                if err != nil </span><span class="cov0" title="0">{
                                        return
                                }</span>

                                // Read body.
                                <span class="cov8" title="1">if zr == nil </span><span class="cov0" title="0">{
                                        zr = ctx.GetReader()
                                }</span>
                                <span class="cov8" title="1">if s.StreamRequestBody </span><span class="cov0" title="0">{
                                        err = req.ContinueReadBodyStream(&amp;ctx.Request, zr, s.MaxRequestBodySize, !s.DisablePreParseMultipartForm)
                                }</span> else<span class="cov8" title="1"> {
                                        err = req.ContinueReadBody(&amp;ctx.Request, zr, s.MaxRequestBodySize, !s.DisablePreParseMultipartForm)
                                }</span>
                                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                        writeErrorResponse(zw, ctx, serverName, err)
                                        return
                                }</span>
                        }
                }

                <span class="cov8" title="1">connectionClose = s.DisableKeepalive || ctx.Request.Header.ConnectionClose()
                isHTTP11 = ctx.Request.Header.IsHTTP11()

                if serverName != nil </span><span class="cov0" title="0">{
                        ctx.Response.Header.SetServerBytes(serverName)
                }</span>
                <span class="cov8" title="1">if s.EnableTrace </span><span class="cov8" title="1">{
                        internalStats.Record(ctx.GetTraceInfo(), stats.ServerHandleStart, err)
                        eventsToTrigger.push(func(ti traceinfo.TraceInfo, err error) </span><span class="cov8" title="1">{
                                internalStats.Record(ti, stats.ServerHandleFinish, err)
                        }</span>)
                }
                // Handle the request
                //
                // NOTE: All middlewares and business handler will be executed in this. And at this point, the request has been parsed
                // and the route has been matched.
                <span class="cov8" title="1">s.Core.ServeHTTP(cc, ctx)
                if s.EnableTrace </span><span class="cov8" title="1">{
                        // application layer handle finished
                        if last := eventsToTrigger.pop(); last != nil </span><span class="cov8" title="1">{
                                last(ctx.GetTraceInfo(), err)
                        }</span>
                }

                // exit check
                <span class="cov8" title="1">if !s.Core.IsRunning() </span><span class="cov8" title="1">{
                        connectionClose = true
                }</span>

                <span class="cov8" title="1">if !ctx.IsGet() &amp;&amp; ctx.IsHead() </span><span class="cov0" title="0">{
                        ctx.Response.SkipBody = true
                }</span>

                <span class="cov8" title="1">hijackHandler = ctx.GetHijackHandler()
                ctx.SetHijackHandler(nil)

                connectionClose = connectionClose || ctx.Response.ConnectionClose()
                if connectionClose </span><span class="cov8" title="1">{
                        ctx.Response.Header.SetCanonical(bytestr.StrConnection, bytestr.StrClose)
                }</span> else<span class="cov8" title="1"> if !isHTTP11 </span><span class="cov0" title="0">{
                        ctx.Response.Header.SetCanonical(bytestr.StrConnection, bytestr.StrKeepAlive)
                }</span>

                <span class="cov8" title="1">if zw == nil </span><span class="cov8" title="1">{
                        zw = ctx.GetWriter()
                }</span>
                <span class="cov8" title="1">if s.EnableTrace </span><span class="cov8" title="1">{
                        internalStats.Record(ctx.GetTraceInfo(), stats.WriteStart, err)
                        eventsToTrigger.push(func(ti traceinfo.TraceInfo, err error) </span><span class="cov8" title="1">{
                                internalStats.Record(ti, stats.WriteFinish, err)
                        }</span>)
                }
                <span class="cov8" title="1">if err = writeResponse(ctx, zw); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov8" title="1">if s.EnableTrace </span><span class="cov8" title="1">{
                        if ctx.Response.Header.ContentLength() &gt; 0 </span><span class="cov0" title="0">{
                                ctx.GetTraceInfo().Stats().SetSendSize(ctx.Response.Header.GetHeaderLength() + ctx.Response.Header.ContentLength())
                        }</span> else<span class="cov8" title="1"> {
                                ctx.GetTraceInfo().Stats().SetSendSize(0)
                        }</span>
                }

                // Release the zeroCopyReader before flush to prevent data race
                <span class="cov8" title="1">if zr != nil </span><span class="cov8" title="1">{
                        zr.Release() //nolint:errcheck
                        zr = nil
                }</span>
                // Flush the response.
                <span class="cov8" title="1">if err = zw.Flush(); err != nil </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">if s.EnableTrace </span><span class="cov8" title="1">{
                        // write finished
                        if last := eventsToTrigger.pop(); last != nil </span><span class="cov8" title="1">{
                                last(ctx.GetTraceInfo(), err)
                        }</span>
                }

                // Release request body stream
                <span class="cov8" title="1">if ctx.Request.IsBodyStream() </span><span class="cov0" title="0">{
                        err = ext.ReleaseBodyStream(ctx.RequestBodyStream())
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }

                <span class="cov8" title="1">if hijackHandler != nil </span><span class="cov8" title="1">{
                        // Hijacked conn process the timeout by itself
                        err = ctx.GetConn().SetReadTimeout(0)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>

                        // Hijack and block the connection until the hijackHandler return
                        <span class="cov8" title="1">s.HijackConnHandle(ctx.GetConn(), hijackHandler)
                        err = errHijacked
                        return</span>
                }

                <span class="cov8" title="1">if connectionClose </span><span class="cov8" title="1">{
                        return errShortConnection
                }</span>
                // Back to network layer to trigger.
                // For now, only netpoll network mode has this feature.
                <span class="cov8" title="1">if s.IdleTimeout == 0 </span><span class="cov8" title="1">{
                        return
                }</span>
                // general case
                <span class="cov8" title="1">if s.EnableTrace </span><span class="cov0" title="0">{
                        if shouldRecordInTraceError(err) </span><span class="cov0" title="0">{
                                traceCtl.DoFinish(cc, ctx, err)
                        }</span> else<span class="cov0" title="0"> {
                                traceCtl.DoFinish(cc, ctx, nil)
                        }</span>
                }

                <span class="cov8" title="1">ctx.ResetWithoutConn()</span>
        }
}

func NewServer() *Server <span class="cov8" title="1">{
        return &amp;Server{
                eventStackPool: &amp;sync.Pool{
                        New: func() interface{} </span><span class="cov0" title="0">{
                                return &amp;eventStack{}
                        }</span>,
                },
        }
}

func writeErrorResponse(zw network.Writer, ctx *app.RequestContext, serverName []byte, err error) network.Writer <span class="cov8" title="1">{
        errorHandler := defaultErrorHandler

        errorHandler(ctx, err)

        if serverName != nil </span><span class="cov0" title="0">{
                ctx.Response.Header.SetServerBytes(serverName)
        }</span>
        <span class="cov8" title="1">ctx.SetConnectionClose()
        if zw == nil </span><span class="cov8" title="1">{
                zw = ctx.GetWriter()
        }</span>
        <span class="cov8" title="1">writeResponse(ctx, zw) //nolint:errcheck
        zw.Flush()             //nolint:errcheck
        return zw</span>
}

func writeResponse(ctx *app.RequestContext, w network.Writer) error <span class="cov8" title="1">{
        // Skip default response writing logic if it has been hijacked
        if ctx.Response.GetHijackWriter() != nil </span><span class="cov8" title="1">{
                return ctx.Response.GetHijackWriter().Finalize()
        }</span>

        <span class="cov8" title="1">err := resp.Write(&amp;ctx.Response, w)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return err</span>
}

func defaultErrorHandler(ctx *app.RequestContext, err error) <span class="cov8" title="1">{
        if netErr, ok := err.(*net.OpError); ok &amp;&amp; netErr.Timeout() </span><span class="cov0" title="0">{
                ctx.AbortWithMsg("Request timeout", consts.StatusRequestTimeout)
        }</span> else<span class="cov8" title="1"> if errors.Is(err, errs.ErrBodyTooLarge) </span><span class="cov0" title="0">{
                ctx.AbortWithMsg("Request Entity Too Large", consts.StatusRequestEntityTooLarge)
        }</span> else<span class="cov8" title="1"> {
                ctx.AbortWithMsg("Error when parsing request", consts.StatusBadRequest)
        }</span>
}

type eventStack []func(ti traceinfo.TraceInfo, err error)

func (e *eventStack) isEmpty() bool <span class="cov8" title="1">{
        return len(*e) == 0
}</span>

func (e *eventStack) push(f func(ti traceinfo.TraceInfo, err error)) <span class="cov8" title="1">{
        *e = append(*e, f)
}</span>

func (e *eventStack) pop() func(ti traceinfo.TraceInfo, err error) <span class="cov8" title="1">{
        if e.isEmpty() </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">last := (*e)[len(*e)-1]
        *e = (*e)[:len(*e)-1]
        return last</span>
}

func shouldRecordInTraceError(err error) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if errors.Is(err, errs.ErrIdleTimeout) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if errors.Is(err, errs.ErrHijacked) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if errors.Is(err, errs.ErrShortConnection) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file89" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015-present Aliaksandr Valialkin, VertaMedia, Kirill Danshin, Erik Dubbelboer, FastHTTP Authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This file may have been modified by CloudWeGo authors. All CloudWeGo
 * Modifications are Copyright 2022 CloudWeGo Authors.
 */

package protocol

import (
        "fmt"
        "io"
        "mime/multipart"
        "net/http"
        "net/textproto"
        "os"
        "path/filepath"
        "strings"

        "github.com/cloudwego/hertz/pkg/common/bytebufferpool"
        "github.com/cloudwego/hertz/pkg/common/utils"
        "github.com/cloudwego/hertz/pkg/network"
        "github.com/cloudwego/hertz/pkg/protocol/consts"
)

func ReadMultipartForm(r io.Reader, boundary string, size, maxInMemoryFileSize int) (*multipart.Form, error) <span class="cov8" title="1">{
        // Do not care about memory allocations here, since they are tiny
        // compared to multipart data (aka multi-MB files) usually sent
        // in multipart/form-data requests.

        if size &lt;= 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("form size must be greater than 0. Given %d", size)
        }</span>
        <span class="cov8" title="1">lr := io.LimitReader(r, int64(size))
        mr := multipart.NewReader(lr, boundary)
        f, err := mr.ReadForm(int64(maxInMemoryFileSize))
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("cannot read multipart/form-data body: %s", err)
        }</span>
        <span class="cov8" title="1">return f, nil</span>
}

// WriteMultipartForm writes the given multipart form f with the given
// boundary to w.
func WriteMultipartForm(w io.Writer, f *multipart.Form, boundary string) error <span class="cov8" title="1">{
        // Do not care about memory allocations here, since multipart
        // form processing is slow.
        if len(boundary) == 0 </span><span class="cov8" title="1">{
                panic("BUG: form boundary cannot be empty")</span>
        }

        <span class="cov8" title="1">mw := multipart.NewWriter(w)
        if err := mw.SetBoundary(boundary); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("cannot use form boundary %q: %s", boundary, err)
        }</span>

        // marshal values
        <span class="cov8" title="1">for k, vv := range f.Value </span><span class="cov8" title="1">{
                for _, v := range vv </span><span class="cov8" title="1">{
                        if err := mw.WriteField(k, v); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("cannot write form field %q value %q: %s", k, v, err)
                        }</span>
                }
        }

        // marshal files
        <span class="cov8" title="1">for k, fvv := range f.File </span><span class="cov8" title="1">{
                for _, fv := range fvv </span><span class="cov8" title="1">{
                        vw, err := mw.CreatePart(fv.Header)
                        zw := network.NewWriter(vw)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("cannot create form file %q (%q): %s", k, fv.Filename, err)
                        }</span>
                        <span class="cov8" title="1">fh, err := fv.Open()
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("cannot open form file %q (%q): %s", k, fv.Filename, err)
                        }</span>
                        <span class="cov8" title="1">if _, err = utils.CopyZeroAlloc(zw, fh); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("error when copying form file %q (%q): %s", k, fv.Filename, err)
                        }</span>
                        <span class="cov8" title="1">if err = fh.Close(); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("cannot close form file %q (%q): %s", k, fv.Filename, err)
                        }</span>
                }
        }

        <span class="cov8" title="1">if err := mw.Close(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error when closing multipart form writer: %s", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func MarshalMultipartForm(f *multipart.Form, boundary string) ([]byte, error) <span class="cov8" title="1">{
        var buf bytebufferpool.ByteBuffer
        if err := WriteMultipartForm(&amp;buf, f, boundary); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return buf.B, nil</span>
}

func WriteMultipartFormFile(w *multipart.Writer, fieldName, fileName string, r io.Reader) error <span class="cov8" title="1">{
        // Auto detect actual multipart content type
        cbuf := make([]byte, 512)
        size, err := r.Read(cbuf)
        if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">partWriter, err := w.CreatePart(CreateMultipartHeader(fieldName, fileName, http.DetectContentType(cbuf[:size])))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if _, err = partWriter.Write(cbuf[:size]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">_, err = io.Copy(partWriter, r)
        return err</span>
}

func CreateMultipartHeader(param, fileName, contentType string) textproto.MIMEHeader <span class="cov8" title="1">{
        hdr := make(textproto.MIMEHeader)

        var contentDispositionValue string
        if len(strings.TrimSpace(fileName)) == 0 </span><span class="cov8" title="1">{
                contentDispositionValue = fmt.Sprintf(`form-data; name="%s"`, param)
        }</span> else<span class="cov8" title="1"> {
                contentDispositionValue = fmt.Sprintf(`form-data; name="%s"; filename="%s"`,
                        param, fileName)
        }</span>
        <span class="cov8" title="1">hdr.Set("Content-Disposition", contentDispositionValue)

        if len(contentType) &gt; 0 </span><span class="cov8" title="1">{
                hdr.Set(consts.HeaderContentType, contentType)
        }</span>
        <span class="cov8" title="1">return hdr</span>
}

func AddFile(w *multipart.Writer, fieldName, path string) error <span class="cov8" title="1">{
        file, err := os.Open(path)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        return WriteMultipartFormFile(w, fieldName, filepath.Base(path), file)</span>
}

func ParseMultipartForm(r io.Reader, request *Request, size, maxInMemoryFileSize int) error <span class="cov8" title="1">{
        m, err := ReadMultipartForm(r, request.multipartFormBoundary, size, maxInMemoryFileSize)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">request.multipartForm = m
        return nil</span>
}

func SetMultipartFormWithBoundary(req *Request, m *multipart.Form, boundary string) <span class="cov8" title="1">{
        req.multipartForm = m
        req.multipartFormBoundary = boundary
}</span>
</pre>
		
		<pre class="file" id="file90" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015-present Aliaksandr Valialkin, VertaMedia, Kirill Danshin, Erik Dubbelboer, FastHTTP Authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This file may have been modified by CloudWeGo authors. All CloudWeGo
 * Modifications are Copyright 2022 CloudWeGo Authors.
 */

package protocol

import (
        "bytes"
        "compress/gzip"
        "encoding/base64"
        "fmt"
        "io"
        "mime/multipart"
        "net/url"
        "strings"
        "sync"

        "github.com/cloudwego/hertz/internal/bytesconv"
        "github.com/cloudwego/hertz/internal/bytestr"
        "github.com/cloudwego/hertz/internal/nocopy"
        "github.com/cloudwego/hertz/pkg/common/bytebufferpool"
        "github.com/cloudwego/hertz/pkg/common/compress"
        "github.com/cloudwego/hertz/pkg/common/config"
        "github.com/cloudwego/hertz/pkg/common/errors"
        "github.com/cloudwego/hertz/pkg/common/utils"
        "github.com/cloudwego/hertz/pkg/network"
        "github.com/cloudwego/hertz/pkg/protocol/consts"
)

var (
        ErrMissingFile = errors.NewPublic("http: no such file")

        responseBodyPool bytebufferpool.Pool
        requestBodyPool  bytebufferpool.Pool

        requestPool sync.Pool
)

// NoBody is an io.ReadCloser with no bytes. Read always returns EOF
// and Close always returns nil. It can be used in an outgoing client
// request to explicitly signal that a request has zero bytes.
var NoBody = noBody{}

type noBody struct{}

func (noBody) Read([]byte) (int, error) <span class="cov0" title="0">{ return 0, io.EOF }</span>
func (noBody) Close() error             <span class="cov0" title="0">{ return nil }</span>

type Request struct {
        noCopy nocopy.NoCopy //lint:ignore U1000 until noCopy is used

        Header RequestHeader

        uri      URI
        postArgs Args

        bodyStream      io.Reader
        w               requestBodyWriter
        body            *bytebufferpool.ByteBuffer
        bodyRaw         []byte
        maxKeepBodySize int

        multipartForm         *multipart.Form
        multipartFormBoundary string

        // Group bool members in order to reduce Request object size.
        parsedURI      bool
        parsedPostArgs bool

        isTLS bool

        multipartFiles  []*File
        multipartFields []*MultipartField

        // Request level options, service discovery options etc.
        options *config.RequestOptions
}

type requestBodyWriter struct {
        r *Request
}

// File struct represent file information for multipart request
type File struct {
        Name      string
        ParamName string
        io.Reader
}

// MultipartField struct represent custom data part for multipart request
type MultipartField struct {
        Param       string
        FileName    string
        ContentType string
        io.Reader
}

func (w *requestBodyWriter) Write(p []byte) (int, error) <span class="cov8" title="1">{
        w.r.AppendBody(p)
        return len(p), nil
}</span>

func (req *Request) Options() *config.RequestOptions <span class="cov8" title="1">{
        if req.options == nil </span><span class="cov8" title="1">{
                req.options = config.NewRequestOptions(nil)
        }</span>
        <span class="cov8" title="1">return req.options</span>
}

// AppendBody appends p to request body.
//
// It is safe re-using p after the function returns.
func (req *Request) AppendBody(p []byte) <span class="cov8" title="1">{
        req.RemoveMultipartFormFiles()
        req.CloseBodyStream()     //nolint:errcheck
        req.BodyBuffer().Write(p) //nolint:errcheck
}</span>

func (req *Request) BodyBuffer() *bytebufferpool.ByteBuffer <span class="cov8" title="1">{
        if req.body == nil </span><span class="cov8" title="1">{
                req.body = requestBodyPool.Get()
        }</span>
        <span class="cov8" title="1">req.bodyRaw = nil
        return req.body</span>
}

// MayContinue returns true if the request contains
// 'Expect: 100-continue' header.
//
// The caller must do one of the following actions if MayContinue returns true:
//
//   - Either send StatusExpectationFailed response if request headers don't
//     satisfy the caller.
//   - Or send StatusContinue response before reading request body
//     with ContinueReadBody.
//   - Or close the connection.
func (req *Request) MayContinue() bool <span class="cov8" title="1">{
        return bytes.Equal(req.Header.peek(bytestr.StrExpect), bytestr.Str100Continue)
}</span>

// Scheme returns the scheme of the request.
// uri will be parsed in ServeHTTP(before user's process), so that there is no need for uri nil-check.
func (req *Request) Scheme() []byte <span class="cov8" title="1">{
        return req.uri.Scheme()
}</span>

// For keepalive connection reuse.
// It is roughly the same as ResetSkipHeader, except that the connection related fields are removed:
// - req.isTLS
func (req *Request) resetSkipHeaderAndConn() <span class="cov8" title="1">{
        req.ResetBody()
        req.uri.Reset()
        req.parsedURI = false
        req.parsedPostArgs = false
        req.postArgs.Reset()
}</span>

func (req *Request) ResetSkipHeader() <span class="cov8" title="1">{
        req.resetSkipHeaderAndConn()
        req.isTLS = false
}</span>

func SwapRequestBody(a, b *Request) <span class="cov8" title="1">{
        a.body, b.body = b.body, a.body
        a.bodyRaw, b.bodyRaw = b.bodyRaw, a.bodyRaw
        a.bodyStream, b.bodyStream = b.bodyStream, a.bodyStream
        a.multipartFields, b.multipartFields = b.multipartFields, a.multipartFields
        a.multipartFiles, b.multipartFiles = b.multipartFiles, a.multipartFiles
}</span>

// Reset clears request contents.
func (req *Request) Reset() <span class="cov8" title="1">{
        req.Header.Reset()
        req.ResetSkipHeader()
        req.CloseBodyStream()

        req.options = nil
}</span>

func (req *Request) IsURIParsed() bool <span class="cov8" title="1">{
        return req.parsedURI
}</span>

func (req *Request) PostArgString() []byte <span class="cov8" title="1">{
        return req.postArgs.QueryString()
}</span>

// MultipartForm returns request's multipart form.
//
// Returns errors.ErrNoMultipartForm if request's Content-Type
// isn't 'multipart/form-data'.
//
// RemoveMultipartFormFiles must be called after returned multipart form
// is processed.
func (req *Request) MultipartForm() (*multipart.Form, error) <span class="cov8" title="1">{
        if req.multipartForm != nil </span><span class="cov8" title="1">{
                return req.multipartForm, nil
        }</span>
        <span class="cov8" title="1">req.multipartFormBoundary = string(req.Header.MultipartFormBoundary())
        if len(req.multipartFormBoundary) == 0 </span><span class="cov8" title="1">{
                return nil, errors.ErrNoMultipartForm
        }</span>

        <span class="cov8" title="1">ce := req.Header.peek(bytestr.StrContentEncoding)
        var err error
        var f *multipart.Form

        if !req.IsBodyStream() </span><span class="cov0" title="0">{
                body := req.BodyBytes()
                if bytes.Equal(ce, bytestr.StrGzip) </span><span class="cov0" title="0">{
                        // Do not care about memory usage here.
                        var err error
                        if body, err = compress.AppendGunzipBytes(nil, body); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("cannot gunzip request body: %s", err)
                        }</span>
                } else<span class="cov0" title="0"> if len(ce) &gt; 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unsupported Content-Encoding: %q", ce)
                }</span>
                <span class="cov0" title="0">f, err = ReadMultipartForm(bytes.NewReader(body), req.multipartFormBoundary, len(body), len(body))</span>
        } else<span class="cov8" title="1"> {
                bodyStream := req.bodyStream
                if req.Header.contentLength &gt; 0 </span><span class="cov8" title="1">{
                        bodyStream = io.LimitReader(bodyStream, int64(req.Header.contentLength))
                }</span>
                <span class="cov8" title="1">if bytes.Equal(ce, bytestr.StrGzip) </span><span class="cov8" title="1">{
                        // Do not care about memory usage here.
                        if bodyStream, err = gzip.NewReader(bodyStream); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("cannot gunzip request body: %w", err)
                        }</span>
                } else<span class="cov8" title="1"> if len(ce) &gt; 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unsupported Content-Encoding: %q", ce)
                }</span>

                <span class="cov8" title="1">mr := multipart.NewReader(bodyStream, req.multipartFormBoundary)

                f, err = mr.ReadForm(8 * 1024)</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">req.multipartForm = f
        return f, nil</span>
}

// AppendBodyString appends s to request body.
func (req *Request) AppendBodyString(s string) <span class="cov8" title="1">{
        req.RemoveMultipartFormFiles()
        req.CloseBodyStream()           //nolint:errcheck
        req.BodyBuffer().WriteString(s) //nolint:errcheck
}</span>

// SetRequestURI sets RequestURI.
func (req *Request) SetRequestURI(requestURI string) <span class="cov8" title="1">{
        req.Header.SetRequestURI(requestURI)
        req.parsedURI = false
}</span>

func (req *Request) SetMaxKeepBodySize(n int) <span class="cov8" title="1">{
        req.maxKeepBodySize = n
}</span>

// RequestURI returns the RequestURI for the given request.
func (req *Request) RequestURI() []byte <span class="cov8" title="1">{
        return req.Header.RequestURI()
}</span>

// FormFile returns the first file for the provided form key.
func (req *Request) FormFile(name string) (*multipart.FileHeader, error) <span class="cov8" title="1">{
        mf, err := req.MultipartForm()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if mf.File == nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">fhh := mf.File[name]
        if fhh == nil </span><span class="cov0" title="0">{
                return nil, ErrMissingFile
        }</span>
        <span class="cov8" title="1">return fhh[0], nil</span>
}

// SetHost sets host for the request.
func (req *Request) SetHost(host string) <span class="cov8" title="1">{
        req.URI().SetHost(host)
}</span>

// Host returns the host for the given request.
func (req *Request) Host() []byte <span class="cov8" title="1">{
        return req.URI().Host()
}</span>

// SetIsTLS is used by TLS server to mark whether the request is a TLS request.
// Client shouldn't use this method but should depend on the uri.scheme instead.
func (req *Request) SetIsTLS(isTLS bool) <span class="cov8" title="1">{
        req.isTLS = isTLS
}</span>

// SwapBody swaps request body with the given body and returns
// the previous request body.
//
// It is forbidden to use the body passed to SwapBody after
// the function returns.
func (req *Request) SwapBody(body []byte) []byte <span class="cov8" title="1">{
        bb := req.BodyBuffer()
        zw := network.NewWriter(bb)

        if req.IsBodyStream() </span><span class="cov8" title="1">{
                bb.Reset()
                _, err := utils.CopyZeroAlloc(zw, req.bodyStream)
                req.CloseBodyStream() //nolint:errcheck
                if err != nil </span><span class="cov0" title="0">{
                        bb.Reset()
                        bb.SetString(err.Error())
                }</span>
        }

        <span class="cov8" title="1">req.bodyRaw = nil

        oldBody := bb.B
        bb.B = body
        return oldBody</span>
}

// CopyTo copies req contents to dst except of body stream.
func (req *Request) CopyTo(dst *Request) <span class="cov8" title="1">{
        req.CopyToSkipBody(dst)
        if req.bodyRaw != nil </span><span class="cov8" title="1">{
                dst.bodyRaw = append(dst.bodyRaw[:0], req.bodyRaw...)
                if dst.body != nil </span><span class="cov0" title="0">{
                        dst.body.Reset()
                }</span>
        } else<span class="cov8" title="1"> if req.body != nil </span><span class="cov0" title="0">{
                dst.BodyBuffer().Set(req.body.B)
        }</span> else<span class="cov8" title="1"> if dst.body != nil </span><span class="cov0" title="0">{
                dst.body.Reset()
        }</span>
}

func (req *Request) CopyToSkipBody(dst *Request) <span class="cov8" title="1">{
        dst.Reset()
        req.Header.CopyTo(&amp;dst.Header)

        req.uri.CopyTo(&amp;dst.uri)
        dst.parsedURI = req.parsedURI

        req.postArgs.CopyTo(&amp;dst.postArgs)
        dst.parsedPostArgs = req.parsedPostArgs
        dst.isTLS = req.isTLS

        if req.options != nil </span><span class="cov8" title="1">{
                dst.options = &amp;config.RequestOptions{}
                req.options.CopyTo(dst.options)
        }</span>

        // do not copy multipartForm - it will be automatically
        // re-created on the first call to MultipartForm.
}

func (req *Request) BodyBytes() []byte <span class="cov8" title="1">{
        if req.bodyRaw != nil </span><span class="cov0" title="0">{
                return req.bodyRaw
        }</span>
        <span class="cov8" title="1">if req.body == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return req.body.B</span>
}

// ResetBody resets request body.
func (req *Request) ResetBody() <span class="cov8" title="1">{
        req.bodyRaw = nil
        req.RemoveMultipartFormFiles()
        req.CloseBodyStream() //nolint:errcheck
        if req.body != nil </span><span class="cov8" title="1">{
                if req.body.Len() &lt;= req.maxKeepBodySize </span><span class="cov8" title="1">{
                        req.body.Reset()
                        return
                }</span>
                <span class="cov8" title="1">requestBodyPool.Put(req.body)
                req.body = nil</span>
        }
}

// SetBodyRaw sets request body, but without copying it.
//
// From this point onward the body argument must not be changed.
func (req *Request) SetBodyRaw(body []byte) <span class="cov8" title="1">{
        req.ResetBody()
        req.bodyRaw = body
}</span>

// SetMultipartFormBoundary will set the multipart form boundary for the request.
func (req *Request) SetMultipartFormBoundary(b string) <span class="cov8" title="1">{
        req.multipartFormBoundary = b
}</span>

func (req *Request) MultipartFormBoundary() string <span class="cov8" title="1">{
        return req.multipartFormBoundary
}</span>

// SetBody sets request body.
//
// It is safe re-using body argument after the function returns.
func (req *Request) SetBody(body []byte) <span class="cov8" title="1">{
        req.RemoveMultipartFormFiles()
        req.CloseBodyStream() //nolint:errcheck
        req.BodyBuffer().Set(body)
}</span>

// SetBodyString sets request body.
func (req *Request) SetBodyString(body string) <span class="cov8" title="1">{
        req.RemoveMultipartFormFiles()
        req.CloseBodyStream() //nolint:errcheck
        req.BodyBuffer().SetString(body)
}</span>

// SetQueryString sets query string.
func (req *Request) SetQueryString(queryString string) <span class="cov8" title="1">{
        req.URI().SetQueryString(queryString)
}</span>

// SetFormData sets x-www-form-urlencoded params
func (req *Request) SetFormData(data map[string]string) <span class="cov8" title="1">{
        for k, v := range data </span><span class="cov8" title="1">{
                req.postArgs.Add(k, v)
        }</span>
        <span class="cov8" title="1">req.parsedPostArgs = true
        req.Header.SetContentTypeBytes(bytestr.StrPostArgsContentType)</span>
}

// SetFormDataFromValues sets x-www-form-urlencoded params from url values.
func (req *Request) SetFormDataFromValues(data url.Values) <span class="cov8" title="1">{
        for k, v := range data </span><span class="cov8" title="1">{
                for _, kv := range v </span><span class="cov8" title="1">{
                        req.postArgs.Add(k, kv)
                }</span>
        }
        <span class="cov8" title="1">req.parsedPostArgs = true
        req.Header.SetContentTypeBytes(bytestr.StrPostArgsContentType)</span>
}

// SetFile sets single file field name and its path for multipart upload.
func (req *Request) SetFile(param, filePath string) <span class="cov8" title="1">{
        req.multipartFiles = append(req.multipartFiles, &amp;File{
                Name:      filePath,
                ParamName: param,
        })
}</span>

// SetFiles sets multiple file field name and its path for multipart upload.
func (req *Request) SetFiles(files map[string]string) <span class="cov8" title="1">{
        for f, fp := range files </span><span class="cov8" title="1">{
                req.multipartFiles = append(req.multipartFiles, &amp;File{
                        Name:      fp,
                        ParamName: f,
                })
        }</span>
}

// SetFileReader sets single file using io.Reader for multipart upload.
func (req *Request) SetFileReader(param, fileName string, reader io.Reader) <span class="cov8" title="1">{
        req.multipartFiles = append(req.multipartFiles, &amp;File{
                Name:      fileName,
                ParamName: param,
                Reader:    reader,
        })
}</span>

// SetMultipartFormData method allows simple form data to be attached to the request as `multipart:form-data`
func (req *Request) SetMultipartFormData(data map[string]string) <span class="cov8" title="1">{
        for k, v := range data </span><span class="cov8" title="1">{
                req.SetMultipartField(k, "", "", strings.NewReader(v))
        }</span>
}

func (req *Request) MultipartFiles() []*File <span class="cov8" title="1">{
        return req.multipartFiles
}</span>

// SetMultipartField sets custom data using io.Reader for multipart upload.
func (req *Request) SetMultipartField(param, fileName, contentType string, reader io.Reader) <span class="cov8" title="1">{
        req.multipartFields = append(req.multipartFields, &amp;MultipartField{
                Param:       param,
                FileName:    fileName,
                ContentType: contentType,
                Reader:      reader,
        })
}</span>

// SetMultipartFields sets multiple data fields using io.Reader for multipart upload.
func (req *Request) SetMultipartFields(fields ...*MultipartField) <span class="cov8" title="1">{
        req.multipartFields = append(req.multipartFields, fields...)
}</span>

func (req *Request) MultipartFields() []*MultipartField <span class="cov8" title="1">{
        return req.multipartFields
}</span>

// SetBasicAuth sets the basic authentication header in the current HTTP request.
func (req *Request) SetBasicAuth(username, password string) <span class="cov8" title="1">{
        encodeStr := base64.StdEncoding.EncodeToString([]byte(username + ":" + password))
        req.SetHeader(consts.HeaderAuthorization, "Basic "+encodeStr)
}</span>

// BasicAuth can return the username and password in the request's Authorization
// header, if the request uses the HTTP Basic Authorization.
func (req *Request) BasicAuth() (username, password string, ok bool) <span class="cov8" title="1">{
        // Using Peek to reduce the cost for type transfer.
        auth := req.Header.Peek(consts.HeaderAuthorization)
        if auth == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">return parseBasicAuth(auth)</span>
}

var prefix = []byte{'B', 'a', 's', 'i', 'c', ' '}

// parseBasicAuth can parse an HTTP Basic Authorization string encrypted by base64.
// Example: "Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==" returns ("Aladdin", "open sesame", true).
func parseBasicAuth(auth []byte) (username, password string, ok bool) <span class="cov8" title="1">{
        if len(auth) &lt; len(prefix) || !bytes.EqualFold(auth[:len(prefix)], prefix) </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">decodeLen := base64.StdEncoding.DecodedLen(len(auth[len(prefix):]))
        // base64.StdEncoding.Decode(dst,rsc []byte) will return less than DecodedLen(len(src)))
        decodeData := make([]byte, decodeLen)
        num, err := base64.StdEncoding.Decode(decodeData, auth[len(prefix):])
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">cs := bytesconv.B2s(decodeData[:num])
        s := strings.IndexByte(cs, ':')

        if s &lt; 0 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">return cs[:s], cs[s+1:], true</span>
}

// SetAuthToken sets the auth token header(Default Scheme: Bearer) in the current HTTP request. Header example:
//
//        Authorization: Bearer &lt;auth-token-value-comes-here&gt;
func (req *Request) SetAuthToken(token string) <span class="cov8" title="1">{
        req.SetHeader(consts.HeaderAuthorization, "Bearer "+token)
}</span>

// SetAuthSchemeToken sets the auth token scheme type in the HTTP request. For Example:
//
//        Authorization: &lt;auth-scheme-value-set-here&gt; &lt;auth-token-value&gt;
func (req *Request) SetAuthSchemeToken(scheme, token string) <span class="cov8" title="1">{
        req.SetHeader(consts.HeaderAuthorization, scheme+" "+token)
}</span>

// SetHeader sets a single header field and its value in the current request.
func (req *Request) SetHeader(header, value string) <span class="cov8" title="1">{
        req.Header.Set(header, value)
}</span>

// SetHeaders sets multiple header field and its value in the current request.
func (req *Request) SetHeaders(headers map[string]string) <span class="cov8" title="1">{
        for h, v := range headers </span><span class="cov8" title="1">{
                req.Header.Set(h, v)
        }</span>
}

// SetCookie appends a single cookie in the current request instance.
func (req *Request) SetCookie(key, value string) <span class="cov8" title="1">{
        req.Header.SetCookie(key, value)
}</span>

// SetCookies sets an array of cookies in the current request instance.
func (req *Request) SetCookies(hc map[string]string) <span class="cov8" title="1">{
        for k, v := range hc </span><span class="cov8" title="1">{
                req.Header.SetCookie(k, v)
        }</span>
}

// SetMethod sets http method for this request.
func (req *Request) SetMethod(method string) <span class="cov8" title="1">{
        req.Header.SetMethod(method)
}</span>

func (req *Request) OnlyMultipartForm() bool <span class="cov8" title="1">{
        return req.multipartForm != nil &amp;&amp; (req.body == nil || len(req.body.B) == 0)
}</span>

func (req *Request) HasMultipartForm() bool <span class="cov8" title="1">{
        return req.multipartForm != nil
}</span>

// IsBodyStream returns true if body is set via SetBodyStream*
func (req *Request) IsBodyStream() bool <span class="cov8" title="1">{
        return req.bodyStream != nil &amp;&amp; req.bodyStream != NoBody
}</span>

func (req *Request) BodyStream() io.Reader <span class="cov8" title="1">{
        if req.bodyStream == nil </span><span class="cov8" title="1">{
                req.bodyStream = NoBody
        }</span>
        <span class="cov8" title="1">return req.bodyStream</span>
}

// SetBodyStream sets request body stream and, optionally body size.
//
// If bodySize is &gt;= 0, then the bodyStream must provide exactly bodySize bytes
// before returning io.EOF.
//
// If bodySize &lt; 0, then bodyStream is read until io.EOF.
//
// bodyStream.Close() is called after finishing reading all body data
// if it implements io.Closer.
//
// Note that GET and HEAD requests cannot have body.
//
// See also SetBodyStreamWriter.
func (req *Request) SetBodyStream(bodyStream io.Reader, bodySize int) <span class="cov8" title="1">{
        req.ResetBody()
        req.bodyStream = bodyStream
        req.Header.SetContentLength(bodySize)
}</span>

func (req *Request) ConstructBodyStream(body *bytebufferpool.ByteBuffer, bodyStream io.Reader) <span class="cov8" title="1">{
        req.body = body
        req.bodyStream = bodyStream
}</span>

// BodyWriter returns writer for populating request body.
func (req *Request) BodyWriter() io.Writer <span class="cov0" title="0">{
        req.w.r = req
        return &amp;req.w
}</span>

// PostArgs returns POST arguments.
func (req *Request) PostArgs() *Args <span class="cov8" title="1">{
        req.parsePostArgs()
        return &amp;req.postArgs
}</span>

func (req *Request) parsePostArgs() <span class="cov8" title="1">{
        if req.parsedPostArgs </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">req.parsedPostArgs = true

        if !bytes.HasPrefix(req.Header.ContentType(), bytestr.StrPostArgsContentType) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">req.postArgs.ParseBytes(req.Body())</span>
}

// BodyE returns request body.
func (req *Request) BodyE() ([]byte, error) <span class="cov8" title="1">{
        if req.bodyRaw != nil </span><span class="cov8" title="1">{
                return req.bodyRaw, nil
        }</span>
        <span class="cov8" title="1">if req.IsBodyStream() </span><span class="cov8" title="1">{
                bodyBuf := req.BodyBuffer()
                bodyBuf.Reset()
                zw := network.NewWriter(bodyBuf)
                _, err := utils.CopyZeroAlloc(zw, req.bodyStream)
                req.CloseBodyStream() //nolint:errcheck
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return req.BodyBytes(), nil</span>
        }
        <span class="cov8" title="1">if req.OnlyMultipartForm() </span><span class="cov8" title="1">{
                body, err := MarshalMultipartForm(req.multipartForm, req.multipartFormBoundary)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return body, nil</span>
        }
        <span class="cov8" title="1">return req.BodyBytes(), nil</span>
}

// Body returns request body.
// if get body failed, returns nil.
func (req *Request) Body() []byte <span class="cov8" title="1">{
        body, _ := req.BodyE()
        return body
}</span>

// BodyWriteTo writes request body to w.
func (req *Request) BodyWriteTo(w io.Writer) error <span class="cov8" title="1">{
        if req.IsBodyStream() </span><span class="cov0" title="0">{
                zw := network.NewWriter(w)
                _, err := utils.CopyZeroAlloc(zw, req.bodyStream)
                req.CloseBodyStream() //nolint:errcheck
                return err
        }</span>
        <span class="cov8" title="1">if req.OnlyMultipartForm() </span><span class="cov8" title="1">{
                return WriteMultipartForm(w, req.multipartForm, req.multipartFormBoundary)
        }</span>
        <span class="cov8" title="1">_, err := w.Write(req.BodyBytes())
        return err</span>
}

func (req *Request) CloseBodyStream() error <span class="cov8" title="1">{
        if req.bodyStream == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">var err error
        if bsc, ok := req.bodyStream.(io.Closer); ok </span><span class="cov0" title="0">{
                err = bsc.Close()
        }</span>
        <span class="cov8" title="1">req.bodyStream = nil
        return err</span>
}

// URI returns request URI
func (req *Request) URI() *URI <span class="cov8" title="1">{
        req.ParseURI()
        return &amp;req.uri
}</span>

func (req *Request) ParseURI() <span class="cov8" title="1">{
        if req.parsedURI </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">req.parsedURI = true

        req.uri.parse(req.Header.Host(), req.Header.RequestURI(), req.isTLS)</span>
}

// RemoveMultipartFormFiles removes multipart/form-data temporary files
// associated with the request.
func (req *Request) RemoveMultipartFormFiles() <span class="cov8" title="1">{
        if req.multipartForm != nil </span><span class="cov8" title="1">{
                // Do not check for error, since these files may be deleted or moved
                // to new places by user code.
                req.multipartForm.RemoveAll() //nolint:errcheck
                req.multipartForm = nil
        }</span>
        <span class="cov8" title="1">req.multipartFormBoundary = ""
        req.multipartFiles = nil
        req.multipartFields = nil</span>
}

func AddMultipartFormField(w *multipart.Writer, mf *MultipartField) error <span class="cov0" title="0">{
        partWriter, err := w.CreatePart(CreateMultipartHeader(mf.Param, mf.FileName, mf.ContentType))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = io.Copy(partWriter, mf.Reader)
        return err</span>
}

// Method returns request method
func (req *Request) Method() []byte <span class="cov8" title="1">{
        return req.Header.Method()
}</span>

// Path returns request path
func (req *Request) Path() []byte <span class="cov8" title="1">{
        return req.URI().Path()
}</span>

// QueryString returns request query
func (req *Request) QueryString() []byte <span class="cov8" title="1">{
        return req.URI().QueryString()
}</span>

// SetOptions is used to set request options.
// These options can be used to do something in middlewares such as service discovery.
func (req *Request) SetOptions(opts ...config.RequestOption) <span class="cov8" title="1">{
        req.Options().Apply(opts)
}</span>

// ConnectionClose returns true if 'Connection: close' header is set.
func (req *Request) ConnectionClose() bool <span class="cov8" title="1">{
        return req.Header.ConnectionClose()
}</span>

// SetConnectionClose sets 'Connection: close' header.
func (req *Request) SetConnectionClose() <span class="cov8" title="1">{
        req.Header.SetConnectionClose(true)
}</span>

func (req *Request) ResetWithoutConn() <span class="cov0" title="0">{
        req.Header.Reset()
        req.resetSkipHeaderAndConn()
        req.CloseBodyStream()

        req.options = nil
}</span>

// AcquireRequest returns an empty Request instance from request pool.
//
// The returned Request instance may be passed to ReleaseRequest when it is
// no longer needed. This allows Request recycling, reduces GC pressure
// and usually improves performance.
func AcquireRequest() *Request <span class="cov8" title="1">{
        v := requestPool.Get()
        if v == nil </span><span class="cov8" title="1">{
                return &amp;Request{}
        }</span>
        <span class="cov0" title="0">return v.(*Request)</span>
}

// ReleaseRequest returns req acquired via AcquireRequest to request pool.
//
// It is forbidden accessing req and/or its members after returning
// it to request pool.
func ReleaseRequest(req *Request) <span class="cov0" title="0">{
        req.Reset()
        requestPool.Put(req)
}</span>

// NewRequest makes a new Request given a method, URL, and
// optional body.
//
// # Method's default value is GET
//
// Url must contain fully qualified uri, i.e. with scheme and host,
// and http is assumed if scheme is omitted.
//
// Protocol version is always HTTP/1.1
//
// NewRequest just uses for unit-testing. Use AcquireRequest() in other cases.
func NewRequest(method, url string, body io.Reader) *Request <span class="cov8" title="1">{
        if method == "" </span><span class="cov8" title="1">{
                method = consts.MethodGet
        }</span>

        <span class="cov8" title="1">req := new(Request)
        req.SetRequestURI(url)
        req.SetIsTLS(bytes.HasPrefix(bytesconv.S2b(url), bytestr.StrHTTPS))
        req.ParseURI()
        req.SetMethod(method)
        req.Header.SetHost(string(req.URI().Host()))
        req.Header.SetRequestURIBytes(req.URI().RequestURI())

        if !req.Header.IgnoreBody() </span><span class="cov8" title="1">{
                req.SetBodyStream(body, -1)
                switch v := req.BodyStream().(type) </span>{
                case *bytes.Buffer:<span class="cov8" title="1">
                        req.Header.SetContentLength(v.Len())</span>
                case *bytes.Reader:<span class="cov8" title="1">
                        req.Header.SetContentLength(v.Len())</span>
                case *strings.Reader:<span class="cov8" title="1">
                        req.Header.SetContentLength(v.Len())</span>
                default:<span class="cov8" title="1"></span>
                }
        }

        <span class="cov8" title="1">return req</span>
}
</pre>
		
		<pre class="file" id="file91" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015-present Aliaksandr Valialkin, VertaMedia, Kirill Danshin, Erik Dubbelboer, FastHTTP Authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This file may have been modified by CloudWeGo authors. All CloudWeGo
 * Modifications are Copyright 2022 CloudWeGo Authors.
 */

package protocol

import (
        "io"
        "net"
        "sync"

        "github.com/cloudwego/hertz/internal/bytesconv"
        "github.com/cloudwego/hertz/internal/nocopy"
        "github.com/cloudwego/hertz/pkg/common/bytebufferpool"
        "github.com/cloudwego/hertz/pkg/common/compress"
        "github.com/cloudwego/hertz/pkg/common/utils"
        "github.com/cloudwego/hertz/pkg/network"
)

var (
        responsePool sync.Pool
        // NoResponseBody is an io.ReadCloser with no bytes. Read always returns EOF
        // and Close always returns nil. It can be used in an ingoing client
        // response to explicitly signal that a response has zero bytes.
        NoResponseBody = noBody{}
)

// Response represents HTTP response.
//
// It is forbidden copying Response instances. Create new instances
// and use CopyTo instead.
//
// Response instance MUST NOT be used from concurrently running goroutines.
type Response struct {
        noCopy nocopy.NoCopy //lint:ignore U1000 until noCopy is used

        // Response header
        //
        // Copying Header by value is forbidden. Use pointer to Header instead.
        Header ResponseHeader

        // Flush headers as soon as possible without waiting for first body bytes.
        // Relevant for bodyStream only.
        ImmediateHeaderFlush bool

        bodyStream      io.Reader
        w               responseBodyWriter
        body            *bytebufferpool.ByteBuffer
        bodyRaw         []byte
        maxKeepBodySize int

        // Response.Read() skips reading body if set to true.
        // Use it for reading HEAD responses.
        //
        // Response.Write() skips writing body if set to true.
        // Use it for writing HEAD responses.
        SkipBody bool

        // Remote TCPAddr from concurrently net.Conn
        raddr net.Addr
        // Local TCPAddr from concurrently net.Conn
        laddr net.Addr

        // If set a hijackWriter, hertz will skip the default header/body writer process.
        hijackWriter network.ExtWriter
}

func (resp *Response) GetHijackWriter() network.ExtWriter <span class="cov8" title="1">{
        return resp.hijackWriter
}</span>

func (resp *Response) HijackWriter(writer network.ExtWriter) <span class="cov8" title="1">{
        resp.hijackWriter = writer
}</span>

type responseBodyWriter struct {
        r *Response
}

func (w *responseBodyWriter) Write(p []byte) (int, error) <span class="cov8" title="1">{
        w.r.AppendBody(p)
        return len(p), nil
}</span>

func (resp *Response) MustSkipBody() bool <span class="cov8" title="1">{
        return resp.SkipBody || resp.Header.MustSkipContentLength()
}</span>

// BodyGunzip returns un-gzipped body data.
//
// This method may be used if the response header contains
// 'Content-Encoding: gzip' for reading un-gzipped body.
// Use Body for reading gzipped response body.
func (resp *Response) BodyGunzip() ([]byte, error) <span class="cov8" title="1">{
        return gunzipData(resp.Body())
}</span>

// SetConnectionClose sets 'Connection: close' header.
func (resp *Response) SetConnectionClose() <span class="cov0" title="0">{
        resp.Header.SetConnectionClose(true)
}</span>

// SetBodyString sets response body.
func (resp *Response) SetBodyString(body string) <span class="cov8" title="1">{
        resp.CloseBodyStream()            //nolint:errcheck
        resp.BodyBuffer().SetString(body) //nolint:errcheck
}</span>

func (resp *Response) ConstructBodyStream(body *bytebufferpool.ByteBuffer, bodyStream io.Reader) <span class="cov8" title="1">{
        resp.body = body
        resp.bodyStream = bodyStream
}</span>

// BodyWriter returns writer for populating response body.
//
// If used inside RequestHandler, the returned writer must not be used
// after returning from RequestHandler. Use RequestContext.Write
// or SetBodyStreamWriter in this case.
func (resp *Response) BodyWriter() io.Writer <span class="cov8" title="1">{
        resp.w.r = resp
        return &amp;resp.w
}</span>

// SetStatusCode sets response status code.
func (resp *Response) SetStatusCode(statusCode int) <span class="cov8" title="1">{
        resp.Header.SetStatusCode(statusCode)
}</span>

func (resp *Response) SetMaxKeepBodySize(n int) <span class="cov0" title="0">{
        resp.maxKeepBodySize = n
}</span>

func (resp *Response) BodyBytes() []byte <span class="cov8" title="1">{
        if resp.bodyRaw != nil </span><span class="cov8" title="1">{
                return resp.bodyRaw
        }</span>
        <span class="cov8" title="1">if resp.body == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return resp.body.B</span>
}

func (resp *Response) HasBodyBytes() bool <span class="cov8" title="1">{
        return len(resp.BodyBytes()) != 0
}</span>

func (resp *Response) CopyToSkipBody(dst *Response) <span class="cov8" title="1">{
        dst.Reset()
        resp.Header.CopyTo(&amp;dst.Header)
        dst.SkipBody = resp.SkipBody
        dst.raddr = resp.raddr
        dst.laddr = resp.laddr
}</span>

// IsBodyStream returns true if body is set via SetBodyStream*
func (resp *Response) IsBodyStream() bool <span class="cov8" title="1">{
        return resp.bodyStream != nil
}</span>

// SetBodyStream sets response body stream and, optionally body size.
//
// If bodySize is &gt;= 0, then the bodyStream must provide exactly bodySize bytes
// before returning io.EOF.
//
// If bodySize &lt; 0, then bodyStream is read until io.EOF.
//
// bodyStream.Close() is called after finishing reading all body data
// if it implements io.Closer.
//
// See also SetBodyStreamWriter.
func (resp *Response) SetBodyStream(bodyStream io.Reader, bodySize int) <span class="cov8" title="1">{
        resp.ResetBody()
        resp.bodyStream = bodyStream
        resp.Header.SetContentLength(bodySize)
}</span>

// SetBodyStreamNoReset is almost the same as SetBodyStream,
// but it doesn't reset the bodyStream before.
func (resp *Response) SetBodyStreamNoReset(bodyStream io.Reader, bodySize int) <span class="cov8" title="1">{
        resp.bodyStream = bodyStream
        resp.Header.SetContentLength(bodySize)
}</span>

// BodyE returns response body.
func (resp *Response) BodyE() ([]byte, error) <span class="cov8" title="1">{
        if resp.bodyStream != nil </span><span class="cov8" title="1">{
                bodyBuf := resp.BodyBuffer()
                bodyBuf.Reset()
                zw := network.NewWriter(bodyBuf)
                _, err := utils.CopyZeroAlloc(zw, resp.bodyStream)
                resp.CloseBodyStream() //nolint:errcheck
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">return resp.BodyBytes(), nil</span>
}

// Body returns response body.
// if get body failed, returns nil.
func (resp *Response) Body() []byte <span class="cov8" title="1">{
        body, _ := resp.BodyE()
        return body
}</span>

// BodyWriteTo writes response body to w.
func (resp *Response) BodyWriteTo(w io.Writer) error <span class="cov8" title="1">{
        zw := network.NewWriter(w)
        if resp.bodyStream != nil </span><span class="cov8" title="1">{
                _, err := utils.CopyZeroAlloc(zw, resp.bodyStream)
                resp.CloseBodyStream() //nolint:errcheck
                return err
        }</span>

        <span class="cov8" title="1">body := resp.BodyBytes()
        zw.WriteBinary(body) //nolint:errcheck
        return zw.Flush()</span>
}

// CopyTo copies resp contents to dst except of body stream.
func (resp *Response) CopyTo(dst *Response) <span class="cov8" title="1">{
        resp.CopyToSkipBody(dst)
        if resp.bodyRaw != nil </span><span class="cov8" title="1">{
                dst.bodyRaw = append(dst.bodyRaw[:0], resp.bodyRaw...)
                if dst.body != nil </span><span class="cov0" title="0">{
                        dst.body.Reset()
                }</span>
        } else<span class="cov8" title="1"> if resp.body != nil </span><span class="cov8" title="1">{
                dst.BodyBuffer().Set(resp.body.B)
        }</span> else<span class="cov8" title="1"> if dst.body != nil </span><span class="cov0" title="0">{
                dst.body.Reset()
        }</span>
}

func SwapResponseBody(a, b *Response) <span class="cov8" title="1">{
        a.body, b.body = b.body, a.body
        a.bodyRaw, b.bodyRaw = b.bodyRaw, a.bodyRaw
        a.bodyStream, b.bodyStream = b.bodyStream, a.bodyStream
}</span>

// Reset clears response contents.
func (resp *Response) Reset() <span class="cov8" title="1">{
        resp.Header.Reset()
        resp.resetSkipHeader()
        resp.SkipBody = false
        resp.raddr = nil
        resp.laddr = nil
        resp.ImmediateHeaderFlush = false
        resp.hijackWriter = nil
}</span>

func (resp *Response) resetSkipHeader() <span class="cov8" title="1">{
        resp.ResetBody()
}</span>

// ResetBody resets response body.
func (resp *Response) ResetBody() <span class="cov8" title="1">{
        resp.bodyRaw = nil
        resp.CloseBodyStream() //nolint:errcheck
        if resp.body != nil </span><span class="cov8" title="1">{
                if resp.body.Len() &lt;= resp.maxKeepBodySize </span><span class="cov8" title="1">{
                        resp.body.Reset()
                        return
                }</span>
                <span class="cov8" title="1">responseBodyPool.Put(resp.body)
                resp.body = nil</span>
        }
}

// SetBodyRaw sets response body, but without copying it.
//
// From this point onward the body argument must not be changed.
func (resp *Response) SetBodyRaw(body []byte) <span class="cov8" title="1">{
        resp.ResetBody()
        resp.bodyRaw = body
}</span>

// StatusCode returns response status code.
func (resp *Response) StatusCode() int <span class="cov0" title="0">{
        return resp.Header.StatusCode()
}</span>

// SetBody sets response body.
//
// It is safe re-using body argument after the function returns.
func (resp *Response) SetBody(body []byte) <span class="cov8" title="1">{
        resp.CloseBodyStream() //nolint:errcheck
        if resp.GetHijackWriter() == nil </span><span class="cov8" title="1">{
                resp.BodyBuffer().Set(body) //nolint:errcheck
                return
        }</span>

        // If the hijack writer support .SetBody() api, then use it.
        <span class="cov8" title="1">if setter, ok := resp.GetHijackWriter().(interface {
                SetBody(b []byte)
        }); ok </span><span class="cov8" title="1">{
                setter.SetBody(body)
                return
        }</span>

        // Otherwise, call .Write() api instead.
        <span class="cov0" title="0">resp.GetHijackWriter().Write(body)</span> //nolint:errcheck
}

func (resp *Response) BodyStream() io.Reader <span class="cov8" title="1">{
        if resp.bodyStream == nil </span><span class="cov0" title="0">{
                resp.bodyStream = NoResponseBody
        }</span>
        <span class="cov8" title="1">return resp.bodyStream</span>
}

// AppendBody appends p to response body.
//
// It is safe re-using p after the function returns.
func (resp *Response) AppendBody(p []byte) <span class="cov8" title="1">{
        resp.CloseBodyStream() //nolint:errcheck
        if resp.hijackWriter != nil </span><span class="cov8" title="1">{
                resp.hijackWriter.Write(p) //nolint:errcheck
                return
        }</span>
        <span class="cov8" title="1">resp.BodyBuffer().Write(p)</span> //nolint:errcheck
}

// AppendBodyString appends s to response body.
func (resp *Response) AppendBodyString(s string) <span class="cov8" title="1">{
        resp.CloseBodyStream() //nolint:errcheck
        if resp.hijackWriter != nil </span><span class="cov8" title="1">{
                resp.hijackWriter.Write(bytesconv.S2b(s)) //nolint:errcheck
                return
        }</span>
        <span class="cov8" title="1">resp.BodyBuffer().WriteString(s)</span> //nolint:errcheck
}

// ConnectionClose returns true if 'Connection: close' header is set.
func (resp *Response) ConnectionClose() bool <span class="cov0" title="0">{
        return resp.Header.ConnectionClose()
}</span>

func (resp *Response) CloseBodyStream() error <span class="cov8" title="1">{
        if resp.bodyStream == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">var err error
        if bsc, ok := resp.bodyStream.(io.Closer); ok </span><span class="cov8" title="1">{
                err = bsc.Close()
        }</span>
        <span class="cov8" title="1">resp.bodyStream = nil
        return err</span>
}

func (resp *Response) BodyBuffer() *bytebufferpool.ByteBuffer <span class="cov8" title="1">{
        if resp.body == nil </span><span class="cov8" title="1">{
                resp.body = responseBodyPool.Get()
        }</span>
        <span class="cov8" title="1">resp.bodyRaw = nil
        return resp.body</span>
}

func gunzipData(p []byte) ([]byte, error) <span class="cov8" title="1">{
        var bb bytebufferpool.ByteBuffer
        _, err := compress.WriteGunzip(&amp;bb, p)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return bb.B, nil</span>
}

// RemoteAddr returns the remote network address. The Addr returned is shared
// by all invocations of RemoteAddr, so do not modify it.
func (resp *Response) RemoteAddr() net.Addr <span class="cov0" title="0">{
        return resp.raddr
}</span>

// LocalAddr returns the local network address. The Addr returned is shared
// by all invocations of LocalAddr, so do not modify it.
func (resp *Response) LocalAddr() net.Addr <span class="cov0" title="0">{
        return resp.laddr
}</span>

func (resp *Response) ParseNetAddr(conn network.Conn) <span class="cov0" title="0">{
        resp.raddr = conn.RemoteAddr()
        resp.laddr = conn.LocalAddr()
}</span>

// AcquireResponse returns an empty Response instance from response pool.
//
// The returned Response instance may be passed to ReleaseResponse when it is
// no longer needed. This allows Response recycling, reduces GC pressure
// and usually improves performance.
func AcquireResponse() *Response <span class="cov8" title="1">{
        v := responsePool.Get()
        if v == nil </span><span class="cov8" title="1">{
                return &amp;Response{}
        }</span>
        <span class="cov0" title="0">return v.(*Response)</span>
}

// ReleaseResponse return resp acquired via AcquireResponse to response pool.
//
// It is forbidden accessing resp and/or its members after returning
// it to response pool.
func ReleaseResponse(resp *Response) <span class="cov8" title="1">{
        resp.Reset()
        responsePool.Put(resp)
}</span>
</pre>
		
		<pre class="file" id="file92" style="display: none">/*
 * Copyright 2023 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package protocol

import (
        "bytes"

        "github.com/cloudwego/hertz/internal/bytestr"
        errs "github.com/cloudwego/hertz/pkg/common/errors"
        "github.com/cloudwego/hertz/pkg/common/utils"
        "github.com/cloudwego/hertz/pkg/protocol/consts"
)

type Trailer struct {
        h                  []argsKV
        bufKV              argsKV
        disableNormalizing bool
}

// Get returns trailer value for the given key.
func (t *Trailer) Get(key string) string <span class="cov8" title="1">{
        return string(t.Peek(key))
}</span>

// Peek returns trailer value for the given key.
//
// Returned value is valid until the next call to Trailer.
// Do not store references to returned value. Make copies instead.
func (t *Trailer) Peek(key string) []byte <span class="cov8" title="1">{
        k := getHeaderKeyBytes(&amp;t.bufKV, key, t.disableNormalizing)
        return peekArgBytes(t.h, k)
}</span>

// Del deletes trailer with the given key.
func (t *Trailer) Del(key string) <span class="cov8" title="1">{
        k := getHeaderKeyBytes(&amp;t.bufKV, key, t.disableNormalizing)
        t.h = delAllArgsBytes(t.h, k)
}</span>

// VisitAll calls f for each header.
func (t *Trailer) VisitAll(f func(key, value []byte)) <span class="cov8" title="1">{
        visitArgs(t.h, f)
}</span>

// Set sets the given 'key: value' trailer.
//
// If the key is forbidden by RFC 7230, section 4.1.2, Set will return error
func (t *Trailer) Set(key, value string) error <span class="cov8" title="1">{
        initHeaderKV(&amp;t.bufKV, key, value, t.disableNormalizing)
        return t.setArgBytes(t.bufKV.key, t.bufKV.value, ArgsHasValue)
}</span>

// Add adds the given 'key: value' trailer.
//
// Multiple headers with the same key may be added with this function.
// Use Set for setting a single header for the given key.
//
// If the key is forbidden by RFC 7230, section 4.1.2, Add will return error
func (t *Trailer) Add(key, value string) error <span class="cov8" title="1">{
        initHeaderKV(&amp;t.bufKV, key, value, t.disableNormalizing)
        return t.addArgBytes(t.bufKV.key, t.bufKV.value, ArgsHasValue)
}</span>

func (t *Trailer) addArgBytes(key, value []byte, noValue bool) error <span class="cov8" title="1">{
        if IsBadTrailer(key) </span><span class="cov8" title="1">{
                return errs.NewPublicf("forbidden trailer key: %q", key)
        }</span>
        <span class="cov8" title="1">t.h = appendArgBytes(t.h, key, value, noValue)
        return nil</span>
}

func (t *Trailer) setArgBytes(key, value []byte, noValue bool) error <span class="cov8" title="1">{
        if IsBadTrailer(key) </span><span class="cov8" title="1">{
                return errs.NewPublicf("forbidden trailer key: %q", key)
        }</span>
        <span class="cov8" title="1">t.h = setArgBytes(t.h, key, value, noValue)
        return nil</span>
}

func (t *Trailer) UpdateArgBytes(key, value []byte) error <span class="cov8" title="1">{
        if IsBadTrailer(key) </span><span class="cov0" title="0">{
                return errs.NewPublicf("forbidden trailer key: %q", key)
        }</span>

        <span class="cov8" title="1">t.h = updateArgBytes(t.h, key, value)
        return nil</span>
}

func (t *Trailer) GetTrailers() []argsKV <span class="cov0" title="0">{
        return t.h
}</span>

func (t *Trailer) Empty() bool <span class="cov8" title="1">{
        return len(t.h) == 0
}</span>

// GetBytes return the 'Trailer' Header which is composed by the Trailer key
func (t *Trailer) GetBytes() []byte <span class="cov8" title="1">{
        var dst []byte
        for i, n := 0, len(t.h); i &lt; n; i++ </span><span class="cov8" title="1">{
                kv := &amp;t.h[i]
                dst = append(dst, kv.key...)
                if i+1 &lt; n </span><span class="cov8" title="1">{
                        dst = append(dst, bytestr.StrCommaSpace...)
                }</span>
        }
        <span class="cov8" title="1">return dst</span>
}

func (t *Trailer) ResetSkipNormalize() <span class="cov8" title="1">{
        t.h = t.h[:0]
}</span>

func (t *Trailer) Reset() <span class="cov8" title="1">{
        t.disableNormalizing = false
        t.ResetSkipNormalize()
}</span>

func (t *Trailer) DisableNormalizing() <span class="cov0" title="0">{
        t.disableNormalizing = true
}</span>

func (t *Trailer) IsDisableNormalizing() bool <span class="cov0" title="0">{
        return t.disableNormalizing
}</span>

// CopyTo copies all the trailer to dst.
func (t *Trailer) CopyTo(dst *Trailer) <span class="cov8" title="1">{
        dst.Reset()

        dst.disableNormalizing = t.disableNormalizing
        dst.h = copyArgs(dst.h, t.h)
}</span>

func (t *Trailer) SetTrailers(trailers []byte) (err error) <span class="cov8" title="1">{
        t.ResetSkipNormalize()
        for i := -1; i+1 &lt; len(trailers); </span><span class="cov8" title="1">{
                trailers = trailers[i+1:]
                i = bytes.IndexByte(trailers, ',')
                if i &lt; 0 </span><span class="cov8" title="1">{
                        i = len(trailers)
                }</span>
                <span class="cov8" title="1">trailerKey := trailers[:i]
                for len(trailerKey) &gt; 0 &amp;&amp; trailerKey[0] == ' ' </span><span class="cov8" title="1">{
                        trailerKey = trailerKey[1:]
                }</span>
                <span class="cov8" title="1">for len(trailerKey) &gt; 0 &amp;&amp; trailerKey[len(trailerKey)-1] == ' ' </span><span class="cov8" title="1">{
                        trailerKey = trailerKey[:len(trailerKey)-1]
                }</span>

                <span class="cov8" title="1">utils.NormalizeHeaderKey(trailerKey, t.disableNormalizing)
                err = t.addArgBytes(trailerKey, nilByteSlice, argsNoValue)</span>
        }
        <span class="cov8" title="1">return</span>
}

func (t *Trailer) Header() []byte <span class="cov8" title="1">{
        t.bufKV.value = t.AppendBytes(t.bufKV.value[:0])
        return t.bufKV.value
}</span>

func (t *Trailer) AppendBytes(dst []byte) []byte <span class="cov8" title="1">{
        for i, n := 0, len(t.h); i &lt; n; i++ </span><span class="cov8" title="1">{
                kv := &amp;t.h[i]
                dst = appendHeaderLine(dst, kv.key, kv.value)
        }</span>

        <span class="cov8" title="1">dst = append(dst, bytestr.StrCRLF...)
        return dst</span>
}

func IsBadTrailer(key []byte) bool <span class="cov8" title="1">{
        switch key[0] | 0x20 </span>{
        case 'a':<span class="cov8" title="1">
                return utils.CaseInsensitiveCompare(key, bytestr.StrAuthorization)</span>
        case 'c':<span class="cov8" title="1">
                if len(key) &gt;= len(consts.HeaderContentType) &amp;&amp; utils.CaseInsensitiveCompare(key[:8], bytestr.StrContentType[:8]) </span><span class="cov8" title="1">{
                        // skip compare prefix 'Content-'
                        return utils.CaseInsensitiveCompare(key[8:], bytestr.StrContentEncoding[8:]) ||
                                utils.CaseInsensitiveCompare(key[8:], bytestr.StrContentLength[8:]) ||
                                utils.CaseInsensitiveCompare(key[8:], bytestr.StrContentType[8:]) ||
                                utils.CaseInsensitiveCompare(key[8:], bytestr.StrContentRange[8:])
                }</span>
                <span class="cov8" title="1">return utils.CaseInsensitiveCompare(key, bytestr.StrConnection)</span>
        case 'e':<span class="cov8" title="1">
                return utils.CaseInsensitiveCompare(key, bytestr.StrExpect)</span>
        case 'h':<span class="cov8" title="1">
                return utils.CaseInsensitiveCompare(key, bytestr.StrHost)</span>
        case 'k':<span class="cov8" title="1">
                return utils.CaseInsensitiveCompare(key, bytestr.StrKeepAlive)</span>
        case 'm':<span class="cov8" title="1">
                return utils.CaseInsensitiveCompare(key, bytestr.StrMaxForwards)</span>
        case 'p':<span class="cov8" title="1">
                if len(key) &gt;= len(consts.HeaderProxyConnection) &amp;&amp; utils.CaseInsensitiveCompare(key[:6], bytestr.StrProxyConnection[:6]) </span><span class="cov8" title="1">{
                        // skip compare prefix 'Proxy-'
                        return utils.CaseInsensitiveCompare(key[6:], bytestr.StrProxyConnection[6:]) ||
                                utils.CaseInsensitiveCompare(key[6:], bytestr.StrProxyAuthenticate[6:]) ||
                                utils.CaseInsensitiveCompare(key[6:], bytestr.StrProxyAuthorization[6:])
                }</span>
        case 'r':<span class="cov8" title="1">
                return utils.CaseInsensitiveCompare(key, bytestr.StrRange)</span>
        case 't':<span class="cov8" title="1">
                return utils.CaseInsensitiveCompare(key, bytestr.StrTE) ||
                        utils.CaseInsensitiveCompare(key, bytestr.StrTrailer) ||
                        utils.CaseInsensitiveCompare(key, bytestr.StrTransferEncoding)</span>
        case 'w':<span class="cov8" title="1">
                return utils.CaseInsensitiveCompare(key, bytestr.StrWWWAuthenticate)</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file93" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015-present Aliaksandr Valialkin, VertaMedia, Kirill Danshin, Erik Dubbelboer, FastHTTP Authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This file may have been modified by CloudWeGo authors. All CloudWeGo
 * Modifications are Copyright 2022 CloudWeGo Authors.
 */

package protocol

import (
        "bytes"
        "path/filepath"
        "sync"

        "github.com/cloudwego/hertz/internal/bytesconv"
        "github.com/cloudwego/hertz/internal/bytestr"
        "github.com/cloudwego/hertz/internal/nocopy"
)

// AcquireURI returns an empty URI instance from the pool.
//
// Release the URI with ReleaseURI after the URI is no longer needed.
// This allows reducing GC load.
func AcquireURI() *URI <span class="cov8" title="1">{
        return uriPool.Get().(*URI)
}</span>

// ReleaseURI releases the URI acquired via AcquireURI.
//
// The released URI mustn't be used after releasing it, otherwise data races
// may occur.
func ReleaseURI(u *URI) <span class="cov8" title="1">{
        u.Reset()
        uriPool.Put(u)
}</span>

var uriPool = &amp;sync.Pool{
        New: func() interface{} <span class="cov8" title="1">{
                return &amp;URI{}
        }</span>,
}

type URI struct {
        noCopy nocopy.NoCopy //lint:ignore U1000 until noCopy is used

        pathOriginal []byte
        scheme       []byte
        path         []byte
        queryString  []byte
        hash         []byte
        host         []byte

        queryArgs       Args
        parsedQueryArgs bool

        DisablePathNormalizing bool

        fullURI    []byte
        requestURI []byte

        username []byte
        password []byte
}

type argsKV struct {
        key     []byte
        value   []byte
        noValue bool
}

func (kv *argsKV) GetKey() []byte <span class="cov8" title="1">{
        return kv.key
}</span>

func (kv *argsKV) GetValue() []byte <span class="cov8" title="1">{
        return kv.value
}</span>

// CopyTo copies uri contents to dst.
func (u *URI) CopyTo(dst *URI) <span class="cov8" title="1">{
        dst.Reset()
        dst.pathOriginal = append(dst.pathOriginal[:0], u.pathOriginal...)
        dst.scheme = append(dst.scheme[:0], u.scheme...)
        dst.path = append(dst.path[:0], u.path...)
        dst.queryString = append(dst.queryString[:0], u.queryString...)
        dst.hash = append(dst.hash[:0], u.hash...)
        dst.host = append(dst.host[:0], u.host...)
        dst.username = append(dst.username[:0], u.username...)
        dst.password = append(dst.password[:0], u.password...)

        u.queryArgs.CopyTo(&amp;dst.queryArgs)
        dst.parsedQueryArgs = u.parsedQueryArgs
        dst.DisablePathNormalizing = u.DisablePathNormalizing

        // fullURI and requestURI shouldn't be copied, since they are created
        // from scratch on each FullURI() and RequestURI() call.
}</span>

// QueryArgs returns query args.
func (u *URI) QueryArgs() *Args <span class="cov8" title="1">{
        u.parseQueryArgs()
        return &amp;u.queryArgs
}</span>

func (u *URI) parseQueryArgs() <span class="cov8" title="1">{
        if u.parsedQueryArgs </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">u.queryArgs.ParseBytes(u.queryString)
        u.parsedQueryArgs = true</span>
}

// Hash returns URI hash, i.e. qwe of http://aaa.com/foo/bar?baz=123#qwe .
//
// The returned value is valid until the next URI method call.
func (u *URI) Hash() []byte <span class="cov8" title="1">{
        return u.hash
}</span>

// SetHash sets URI hash.
func (u *URI) SetHash(hash string) <span class="cov8" title="1">{
        u.hash = append(u.hash[:0], hash...)
}</span>

// SetHashBytes sets URI hash.
func (u *URI) SetHashBytes(hash []byte) <span class="cov8" title="1">{
        u.hash = append(u.hash[:0], hash...)
}</span>

// Username returns URI username
func (u *URI) Username() []byte <span class="cov8" title="1">{
        return u.username
}</span>

// SetUsername sets URI username.
func (u *URI) SetUsername(username string) <span class="cov8" title="1">{
        u.username = append(u.username[:0], username...)
}</span>

// SetUsernameBytes sets URI username.
func (u *URI) SetUsernameBytes(username []byte) <span class="cov8" title="1">{
        u.username = append(u.username[:0], username...)
}</span>

// Password returns URI password
func (u *URI) Password() []byte <span class="cov8" title="1">{
        return u.password
}</span>

// SetPassword sets URI password.
func (u *URI) SetPassword(password string) <span class="cov8" title="1">{
        u.password = append(u.password[:0], password...)
}</span>

// SetPasswordBytes sets URI password.
func (u *URI) SetPasswordBytes(password []byte) <span class="cov8" title="1">{
        u.password = append(u.password[:0], password...)
}</span>

// QueryString returns URI query string,
// i.e. baz=123 of http://aaa.com/foo/bar?baz=123#qwe .
//
// The returned value is valid until the next URI method call.
func (u *URI) QueryString() []byte <span class="cov8" title="1">{
        return u.queryString
}</span>

// SetQueryString sets URI query string.
func (u *URI) SetQueryString(queryString string) <span class="cov8" title="1">{
        u.queryString = append(u.queryString[:0], queryString...)
        u.parsedQueryArgs = false
}</span>

// SetQueryStringBytes sets URI query string.
func (u *URI) SetQueryStringBytes(queryString []byte) <span class="cov8" title="1">{
        u.queryString = append(u.queryString[:0], queryString...)
        u.parsedQueryArgs = false
}</span>

// Path returns URI path, i.e. /foo/bar of http://aaa.com/foo/bar?baz=123#qwe .
//
// The returned path is always urldecoded and normalized,
// i.e. '//f%20obar/baz/../zzz' becomes '/f obar/zzz'.
//
// The returned value is valid until the next URI method call.
func (u *URI) Path() []byte <span class="cov8" title="1">{
        path := u.path
        if len(path) == 0 </span><span class="cov8" title="1">{
                path = bytestr.StrSlash
        }</span>
        <span class="cov8" title="1">return path</span>
}

// SetPath sets URI path.
func (u *URI) SetPath(path string) <span class="cov8" title="1">{
        u.pathOriginal = append(u.pathOriginal[:0], path...)
        u.path = normalizePath(u.path, u.pathOriginal)
}</span>

// String returns full uri.
func (u *URI) String() string <span class="cov8" title="1">{
        return string(u.FullURI())
}</span>

// SetPathBytes sets URI path.
func (u *URI) SetPathBytes(path []byte) <span class="cov8" title="1">{
        u.pathOriginal = append(u.pathOriginal[:0], path...)
        u.path = normalizePath(u.path, u.pathOriginal)
}</span>

// PathOriginal returns the original path from requestURI passed to URI.Parse().
//
// The returned value is valid until the next URI method call.
func (u *URI) PathOriginal() []byte <span class="cov8" title="1">{
        return u.pathOriginal
}</span>

// Scheme returns URI scheme, i.e. http of http://aaa.com/foo/bar?baz=123#qwe .
//
// Returned scheme is always lowercased.
//
// The returned value is valid until the next URI method call.
func (u *URI) Scheme() []byte <span class="cov8" title="1">{
        scheme := u.scheme
        if len(scheme) == 0 </span><span class="cov8" title="1">{
                scheme = bytestr.StrHTTP
        }</span>
        <span class="cov8" title="1">return scheme</span>
}

// SetScheme sets URI scheme, i.e. http, https, ftp, etc.
func (u *URI) SetScheme(scheme string) <span class="cov8" title="1">{
        u.scheme = append(u.scheme[:0], scheme...)
        bytesconv.LowercaseBytes(u.scheme)
}</span>

// SetSchemeBytes sets URI scheme, i.e. http, https, ftp, etc.
func (u *URI) SetSchemeBytes(scheme []byte) <span class="cov8" title="1">{
        u.scheme = append(u.scheme[:0], scheme...)
        bytesconv.LowercaseBytes(u.scheme)
}</span>

// Reset clears uri.
func (u *URI) Reset() <span class="cov8" title="1">{
        u.pathOriginal = u.pathOriginal[:0]
        u.scheme = u.scheme[:0]
        u.path = u.path[:0]
        u.queryString = u.queryString[:0]
        u.hash = u.hash[:0]
        u.username = u.username[:0]
        u.password = u.password[:0]

        u.host = u.host[:0]
        u.queryArgs.Reset()
        u.parsedQueryArgs = false
        u.DisablePathNormalizing = false

        // There is no need in u.fullURI = u.fullURI[:0], since full uri
        // is calculated on each call to FullURI().

        // There is no need in u.requestURI = u.requestURI[:0], since requestURI
        // is calculated on each call to RequestURI().
}</span>

// Host returns host part, i.e. aaa.com of http://aaa.com/foo/bar?baz=123#qwe .
//
// Host is always lowercased.
func (u *URI) Host() []byte <span class="cov8" title="1">{
        return u.host
}</span>

// SetHost sets host for the uri.
func (u *URI) SetHost(host string) <span class="cov8" title="1">{
        u.host = append(u.host[:0], host...)
        bytesconv.LowercaseBytes(u.host)
}</span>

// SetHostBytes sets host for the uri.
func (u *URI) SetHostBytes(host []byte) <span class="cov8" title="1">{
        u.host = append(u.host[:0], host...)
        bytesconv.LowercaseBytes(u.host)
}</span>

// LastPathSegment returns the last part of uri path after '/'.
//
// Examples:
//
//   - For /foo/bar/baz.html path returns baz.html.
//   - For /foo/bar/ returns empty byte slice.
//   - For /foobar.js returns foobar.js.
func (u *URI) LastPathSegment() []byte <span class="cov8" title="1">{
        path := u.Path()
        n := bytes.LastIndexByte(path, '/')
        if n &lt; 0 </span><span class="cov0" title="0">{
                return path
        }</span>
        <span class="cov8" title="1">return path[n+1:]</span>
}

// Update updates uri.
//
// The following newURI types are accepted:
//
//   - Absolute, i.e. http://foobar.com/aaa/bb?cc . In this case the original
//     uri is replaced by newURI.
//   - Absolute without scheme, i.e. //foobar.com/aaa/bb?cc. In this case
//     the original scheme is preserved.
//   - Missing host, i.e. /aaa/bb?cc . In this case only RequestURI part
//     of the original uri is replaced.
//   - Relative path, i.e.  xx?yy=abc . In this case the original RequestURI
//     is updated according to the new relative path.
func (u *URI) Update(newURI string) <span class="cov8" title="1">{
        u.UpdateBytes(bytesconv.S2b(newURI))
}</span>

// UpdateBytes updates uri.
//
// The following newURI types are accepted:
//
//   - Absolute, i.e. http://foobar.com/aaa/bb?cc . In this case the original
//     uri is replaced by newURI.
//   - Absolute without scheme, i.e. //foobar.com/aaa/bb?cc. In this case
//     the original scheme is preserved.
//   - Missing host, i.e. /aaa/bb?cc . In this case only RequestURI part
//     of the original uri is replaced.
//   - Relative path, i.e.  xx?yy=abc . In this case the original RequestURI
//     is updated according to the new relative path.
func (u *URI) UpdateBytes(newURI []byte) <span class="cov8" title="1">{
        u.requestURI = u.updateBytes(newURI, u.requestURI)
}</span>

// Parse initializes URI from the given host and uri.
//
// host may be nil. In this case uri must contain fully qualified uri,
// i.e. with scheme and host. http is assumed if scheme is omitted.
//
// uri may contain e.g. RequestURI without scheme and host if host is non-empty.
func (u *URI) Parse(host, uri []byte) <span class="cov8" title="1">{
        u.parse(host, uri, false)
}</span>

// Maybe rawURL is of the form scheme:path.
// (Scheme must be [a-zA-Z][a-zA-Z0-9+-.]*)
// If so, return scheme, path; else return nil, rawURL.
func getScheme(rawURL []byte) (scheme, path []byte) <span class="cov8" title="1">{
        for i := 0; i &lt; len(rawURL); i++ </span><span class="cov8" title="1">{
                c := rawURL[i]
                switch </span>{
                case 'a' &lt;= c &amp;&amp; c &lt;= 'z' || 'A' &lt;= c &amp;&amp; c &lt;= 'Z':<span class="cov8" title="1"></span>
                // do nothing
                case '0' &lt;= c &amp;&amp; c &lt;= '9' || c == '+' || c == '-' || c == '.':<span class="cov8" title="1">
                        if i == 0 </span><span class="cov8" title="1">{
                                return nil, rawURL
                        }</span>
                case c == ':':<span class="cov8" title="1">
                        return checkSchemeWhenCharIsColon(i, rawURL)</span>
                default:<span class="cov8" title="1">
                        // we have encountered an invalid character,
                        // so there is no valid scheme
                        return nil, rawURL</span>
                }
        }
        <span class="cov0" title="0">return nil, rawURL</span>
}

func (u *URI) parse(host, uri []byte, isTLS bool) <span class="cov8" title="1">{
        u.Reset()

        if stringContainsCTLByte(uri) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if len(host) == 0 || bytes.Contains(uri, bytestr.StrColonSlashSlash) </span><span class="cov8" title="1">{
                scheme, newHost, newURI := splitHostURI(host, uri)
                u.scheme = append(u.scheme, scheme...)
                bytesconv.LowercaseBytes(u.scheme)
                host = newHost
                uri = newURI
        }</span>

        <span class="cov8" title="1">if isTLS </span><span class="cov0" title="0">{
                u.scheme = append(u.scheme[:0], bytestr.StrHTTPS...)
        }</span>

        <span class="cov8" title="1">if n := bytes.Index(host, bytestr.StrAt); n &gt;= 0 </span><span class="cov8" title="1">{
                auth := host[:n]
                host = host[n+1:]

                if n := bytes.Index(auth, bytestr.StrColon); n &gt;= 0 </span><span class="cov8" title="1">{
                        u.username = append(u.username[:0], auth[:n]...)
                        u.password = append(u.password[:0], auth[n+1:]...)
                }</span> else<span class="cov8" title="1"> {
                        u.username = append(u.username[:0], auth...)
                        u.password = u.password[:0]
                }</span>
        }

        <span class="cov8" title="1">u.host = append(u.host, host...)
        bytesconv.LowercaseBytes(u.host)

        b := uri
        queryIndex := bytes.IndexByte(b, '?')
        fragmentIndex := bytes.IndexByte(b, '#')
        // Ignore query in fragment part
        if fragmentIndex &gt;= 0 &amp;&amp; queryIndex &gt; fragmentIndex </span><span class="cov8" title="1">{
                queryIndex = -1
        }</span>

        <span class="cov8" title="1">if queryIndex &lt; 0 &amp;&amp; fragmentIndex &lt; 0 </span><span class="cov8" title="1">{
                u.pathOriginal = append(u.pathOriginal, b...)
                u.path = normalizePath(u.path, u.pathOriginal)
                return
        }</span>

        <span class="cov8" title="1">if queryIndex &gt;= 0 </span><span class="cov8" title="1">{
                // Path is everything up to the start of the query
                u.pathOriginal = append(u.pathOriginal, b[:queryIndex]...)
                u.path = normalizePath(u.path, u.pathOriginal)

                if fragmentIndex &lt; 0 </span><span class="cov8" title="1">{
                        u.queryString = append(u.queryString, b[queryIndex+1:]...)
                }</span> else<span class="cov8" title="1"> {
                        u.queryString = append(u.queryString, b[queryIndex+1:fragmentIndex]...)
                        u.hash = append(u.hash, b[fragmentIndex+1:]...)
                }</span>
                <span class="cov8" title="1">return</span>
        }

        // fragmentIndex &gt;= 0 &amp;&amp; queryIndex &lt; 0
        // Path is up to the start of fragment
        <span class="cov8" title="1">u.pathOriginal = append(u.pathOriginal, b[:fragmentIndex]...)
        u.path = normalizePath(u.path, u.pathOriginal)
        u.hash = append(u.hash, b[fragmentIndex+1:]...)</span>
}

// stringContainsCTLByte reports whether s contains any ASCII control character.
func stringContainsCTLByte(s []byte) bool <span class="cov8" title="1">{
        for i := 0; i &lt; len(s); i++ </span><span class="cov8" title="1">{
                b := s[i]
                if b &lt; ' ' || b == 0x7f </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func splitHostURI(host, uri []byte) ([]byte, []byte, []byte) <span class="cov8" title="1">{
        scheme, path := getScheme(uri)

        if scheme == nil </span><span class="cov8" title="1">{
                return bytestr.StrHTTP, host, uri
        }</span>

        <span class="cov8" title="1">uri = path[len(bytestr.StrSlashSlash):]
        n := bytes.IndexByte(uri, '/')
        if n &lt; 0 </span><span class="cov8" title="1">{
                // A hack for bogus urls like foobar.com?a=b without
                // slash after host.
                if n = bytes.IndexByte(uri, '?'); n &gt;= 0 </span><span class="cov8" title="1">{
                        return scheme, uri[:n], uri[n:]
                }</span>
                <span class="cov8" title="1">return scheme, uri, bytestr.StrSlash</span>
        }
        <span class="cov8" title="1">return scheme, uri[:n], uri[n:]</span>
}

func normalizePath(dst, src []byte) []byte <span class="cov8" title="1">{
        dst = dst[:0]
        dst = addLeadingSlash(dst, src)
        dst = decodeArgAppendNoPlus(dst, src)

        // Windows server need to replace all backslashes with
        // forward slashes to avoid path traversal attacks.
        if filepath.Separator == '\\' </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        n := bytes.IndexByte(dst, '\\')
                        if n &lt; 0 </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">dst[n] = '/'</span>
                }
        }

        // remove duplicate slashes
        <span class="cov8" title="1">b := dst
        bSize := len(b)
        for </span><span class="cov8" title="1">{
                n := bytes.Index(b, bytestr.StrSlashSlash)
                if n &lt; 0 </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">b = b[n:]
                copy(b, b[1:])
                b = b[:len(b)-1]
                bSize--</span>
        }
        <span class="cov8" title="1">dst = dst[:bSize]

        // remove /./ parts
        b = dst
        for </span><span class="cov8" title="1">{
                n := bytes.Index(b, bytestr.StrSlashDotSlash)
                if n &lt; 0 </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">nn := n + len(bytestr.StrSlashDotSlash) - 1
                copy(b[n:], b[nn:])
                b = b[:len(b)-nn+n]</span>
        }

        // remove /foo/../ parts
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                n := bytes.Index(b, bytestr.StrSlashDotDotSlash)
                if n &lt; 0 </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">nn := bytes.LastIndexByte(b[:n], '/')
                if nn &lt; 0 </span><span class="cov8" title="1">{
                        nn = 0
                }</span>
                <span class="cov8" title="1">n += len(bytestr.StrSlashDotDotSlash) - 1
                copy(b[nn:], b[n:])
                b = b[:len(b)-n+nn]</span>
        }

        // remove trailing /foo/..
        <span class="cov8" title="1">n := bytes.LastIndex(b, bytestr.StrSlashDotDot)
        if n &gt;= 0 &amp;&amp; n+len(bytestr.StrSlashDotDot) == len(b) </span><span class="cov8" title="1">{
                nn := bytes.LastIndexByte(b[:n], '/')
                if nn &lt; 0 </span><span class="cov8" title="1">{
                        return bytestr.StrSlash
                }</span>
                <span class="cov8" title="1">b = b[:nn+1]</span>
        }

        <span class="cov8" title="1">return b</span>
}

func copyArgs(dst, src []argsKV) []argsKV <span class="cov8" title="1">{
        if cap(dst) &lt; len(src) </span><span class="cov8" title="1">{
                tmp := make([]argsKV, len(src))
                copy(tmp, dst)
                dst = tmp
        }</span>
        <span class="cov8" title="1">n := len(src)
        dst = dst[:n]
        for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                dstKV := &amp;dst[i]
                srcKV := &amp;src[i]
                dstKV.key = append(dstKV.key[:0], srcKV.key...)
                if srcKV.noValue </span><span class="cov0" title="0">{
                        dstKV.value = dstKV.value[:0]
                }</span> else<span class="cov8" title="1"> {
                        dstKV.value = append(dstKV.value[:0], srcKV.value...)
                }</span>
                <span class="cov8" title="1">dstKV.noValue = srcKV.noValue</span>
        }
        <span class="cov8" title="1">return dst</span>
}

func (u *URI) updateBytes(newURI, buf []byte) []byte <span class="cov8" title="1">{
        if len(newURI) == 0 </span><span class="cov8" title="1">{
                return buf
        }</span>

        <span class="cov8" title="1">n := bytes.Index(newURI, bytestr.StrSlashSlash)
        if n &gt;= 0 </span><span class="cov8" title="1">{
                // absolute uri
                var b [32]byte
                schemeOriginal := b[:0]
                if len(u.scheme) &gt; 0 </span><span class="cov8" title="1">{
                        schemeOriginal = append([]byte(nil), u.scheme...)
                }</span>
                <span class="cov8" title="1">if n == 0 </span><span class="cov8" title="1">{
                        newURI = bytes.Join([][]byte{u.scheme, bytestr.StrColon, newURI}, nil)
                }</span>
                <span class="cov8" title="1">u.Parse(nil, newURI)
                if len(schemeOriginal) &gt; 0 &amp;&amp; len(u.scheme) == 0 </span><span class="cov0" title="0">{
                        u.scheme = append(u.scheme[:0], schemeOriginal...)
                }</span>
                <span class="cov8" title="1">return buf</span>
        }

        <span class="cov8" title="1">if newURI[0] == '/' </span><span class="cov8" title="1">{
                // uri without host
                buf = u.appendSchemeHost(buf[:0])
                buf = append(buf, newURI...)
                u.Parse(nil, buf)
                return buf
        }</span>

        // relative path
        <span class="cov8" title="1">switch newURI[0] </span>{
        case '?':<span class="cov8" title="1">
                // query string only update
                u.SetQueryStringBytes(newURI[1:])
                return append(buf[:0], u.FullURI()...)</span>
        case '#':<span class="cov8" title="1">
                // update only hash
                u.SetHashBytes(newURI[1:])
                return append(buf[:0], u.FullURI()...)</span>
        default:<span class="cov8" title="1">
                // update the last path part after the slash
                path := u.Path()
                n = bytes.LastIndexByte(path, '/')
                if n &lt; 0 </span><span class="cov0" title="0">{
                        panic("BUG: path must contain at least one slash")</span>
                }
                <span class="cov8" title="1">buf = u.appendSchemeHost(buf[:0])
                buf = bytesconv.AppendQuotedPath(buf, path[:n+1])
                buf = append(buf, newURI...)
                u.Parse(nil, buf)
                return buf</span>
        }
}

// AppendBytes appends full uri to dst and returns the extended dst.
func (u *URI) AppendBytes(dst []byte) []byte <span class="cov8" title="1">{
        dst = u.appendSchemeHost(dst)
        dst = append(dst, u.RequestURI()...)
        if len(u.hash) &gt; 0 </span><span class="cov8" title="1">{
                dst = append(dst, '#')
                dst = append(dst, u.hash...)
        }</span>
        <span class="cov8" title="1">return dst</span>
}

// RequestURI returns RequestURI - i.e. URI without Scheme and Host.
func (u *URI) RequestURI() []byte <span class="cov8" title="1">{
        var dst []byte
        if u.DisablePathNormalizing </span><span class="cov0" title="0">{
                dst = append(u.requestURI[:0], u.PathOriginal()...)
        }</span> else<span class="cov8" title="1"> {
                dst = bytesconv.AppendQuotedPath(u.requestURI[:0], u.Path())
        }</span>
        <span class="cov8" title="1">if u.queryArgs.Len() &gt; 0 </span><span class="cov8" title="1">{
                dst = append(dst, '?')
                dst = u.queryArgs.AppendBytes(dst)
        }</span> else<span class="cov8" title="1"> if len(u.queryString) &gt; 0 </span><span class="cov8" title="1">{
                dst = append(dst, '?')
                dst = append(dst, u.queryString...)
        }</span>
        <span class="cov8" title="1">u.requestURI = dst
        return u.requestURI</span>
}

func (u *URI) appendSchemeHost(dst []byte) []byte <span class="cov8" title="1">{
        dst = append(dst, u.Scheme()...)
        dst = append(dst, bytestr.StrColonSlashSlash...)
        return append(dst, u.Host()...)
}</span>

// FullURI returns full uri in the form {Scheme}://{Host}{RequestURI}#{Hash}.
func (u *URI) FullURI() []byte <span class="cov8" title="1">{
        u.fullURI = u.AppendBytes(u.fullURI[:0])
        return u.fullURI
}</span>

func ParseURI(uriStr string) *URI <span class="cov8" title="1">{
        uri := &amp;URI{}
        uri.Parse(nil, []byte(uriStr))

        return uri
}</span>

type Proxy func(*Request) (*URI, error)

func ProxyURI(fixedURI *URI) Proxy <span class="cov0" title="0">{
        return func(*Request) (*URI, error) </span><span class="cov0" title="0">{
                return fixedURI, nil
        }</span>
}
</pre>
		
		<pre class="file" id="file94" style="display: none">//go:build !windows
// +build !windows

/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015-present Aliaksandr Valialkin, VertaMedia, Kirill Danshin, Erik Dubbelboer, FastHTTP Authors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This file may have been modified by CloudWeGo authors. All CloudWeGo
 * Modifications are Copyright 2022 CloudWeGo Authors.
 */

package protocol

import "github.com/cloudwego/hertz/pkg/common/hlog"

func addLeadingSlash(dst, src []byte) []byte <span class="cov8" title="1">{
        // add leading slash for unix paths
        if len(src) == 0 || src[0] != '/' </span><span class="cov8" title="1">{
                dst = append(dst, '/')
        }</span>

        <span class="cov8" title="1">return dst</span>
}

// checkSchemeWhenCharIsColon check url begin with :
// Scenarios that handle protocols like "http:"
func checkSchemeWhenCharIsColon(i int, rawURL []byte) (scheme, path []byte) <span class="cov8" title="1">{
        if i == 0 </span><span class="cov8" title="1">{
                hlog.Errorf("error happened when try to parse the rawURL(%s): missing protocol scheme", rawURL)
                return
        }</span>
        <span class="cov8" title="1">return rawURL[:i], rawURL[i+1:]</span>
}
</pre>
		
		<pre class="file" id="file95" style="display: none">// Copyright 2022 CloudWeGo Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

//go:build !windows
// +build !windows

package route

import (
        "github.com/cloudwego/hertz/pkg/network/netpoll"
)

func init() <span class="cov8" title="1">{
        defaultTransporter = netpoll.NewTransporter
}</span>
</pre>
		
		<pre class="file" id="file96" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * The MIT License (MIT)
 * Copyright (c) 2014 Manuel MartÃ­nez-Almeida
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This file may have been modified by CloudWeGo authors. All CloudWeGo
 * Modifications are Copyright 2022 CloudWeGo Authors
 */

package route

import (
        "bytes"
        "context"
        "crypto/tls"
        "errors"
        "fmt"
        "html/template"
        "io"
        "path/filepath"
        "reflect"
        "runtime"
        "strings"
        "sync"
        "sync/atomic"

        "github.com/cloudwego/hertz/internal/bytesconv"
        "github.com/cloudwego/hertz/internal/bytestr"
        "github.com/cloudwego/hertz/internal/nocopy"
        internalStats "github.com/cloudwego/hertz/internal/stats"
        "github.com/cloudwego/hertz/pkg/app"
        "github.com/cloudwego/hertz/pkg/app/server/binding"
        "github.com/cloudwego/hertz/pkg/app/server/render"
        "github.com/cloudwego/hertz/pkg/common/config"
        errs "github.com/cloudwego/hertz/pkg/common/errors"
        "github.com/cloudwego/hertz/pkg/common/hlog"
        "github.com/cloudwego/hertz/pkg/common/tracer"
        "github.com/cloudwego/hertz/pkg/common/tracer/stats"
        "github.com/cloudwego/hertz/pkg/common/tracer/traceinfo"
        "github.com/cloudwego/hertz/pkg/common/utils"
        "github.com/cloudwego/hertz/pkg/network"
        "github.com/cloudwego/hertz/pkg/network/standard"
        "github.com/cloudwego/hertz/pkg/protocol"
        "github.com/cloudwego/hertz/pkg/protocol/consts"
        "github.com/cloudwego/hertz/pkg/protocol/http1"
        "github.com/cloudwego/hertz/pkg/protocol/http1/factory"
        "github.com/cloudwego/hertz/pkg/protocol/suite"
        "github.com/cloudwego/hertz/pkg/route/param"
)

const unknownTransporterName = "unknown"

var (
        defaultTransporter = standard.NewTransporter

        errInitFailed       = errs.NewPrivate("engine has been init already")
        errAlreadyRunning   = errs.NewPrivate("engine is already running")
        errStatusNotRunning = errs.NewPrivate("engine is not running")

        default404Body = []byte("404 page not found")
        default405Body = []byte("405 method not allowed")
        default400Body = []byte("400 bad request")

        requiredHostBody = []byte("missing required Host header")
)

type hijackConn struct {
        network.Conn
        e *Engine
}

type CtxCallback func(ctx context.Context)

type CtxErrCallback func(ctx context.Context) error

// RouteInfo represents a request route's specification which contains method and path and its handler.
type RouteInfo struct {
        Method      string
        Path        string
        Handler     string
        HandlerFunc app.HandlerFunc
}

// RoutesInfo defines a RouteInfo array.
type RoutesInfo []RouteInfo

type Engine struct {
        noCopy nocopy.NoCopy //lint:ignore U1000 until noCopy is used

        // engine name
        Name       string
        serverName atomic.Value

        // Options for route and protocol server
        options *config.Options

        // route
        RouterGroup
        trees MethodTrees

        maxParams uint16

        allNoMethod app.HandlersChain
        allNoRoute  app.HandlersChain
        noRoute     app.HandlersChain
        noMethod    app.HandlersChain

        // For render HTML
        delims     render.Delims
        funcMap    template.FuncMap
        htmlRender render.HTMLRender

        // NoHijackConnPool will control whether invite pool to acquire/release the hijackConn or not.
        // If it is difficult to guarantee that hijackConn will not be closed repeatedly, set it to true.
        NoHijackConnPool bool
        hijackConnPool   sync.Pool
        // KeepHijackedConns is an opt-in disable of connection
        // close by hertz after connections' HijackHandler returns.
        // This allows to save goroutines, e.g. when hertz used to upgrade
        // http connections to WS and connection goes to another handler,
        // which will close it when needed.
        KeepHijackedConns bool

        // underlying transport
        transport network.Transporter

        // trace
        tracerCtl   tracer.Controller
        enableTrace bool

        // protocol layer management
        protocolSuite         *suite.Config
        protocolServers       map[string]protocol.Server
        protocolStreamServers map[string]protocol.StreamServer

        // RequestContext pool
        ctxPool sync.Pool

        // Function to handle panics recovered from http handlers.
        // It should be used to generate an error page and return the http error code
        // 500 (Internal Server Error).
        // The handler can be used to keep your server from crashing because of
        // unrecovered panics.
        PanicHandler app.HandlerFunc

        // ContinueHandler is called after receiving the Expect 100 Continue Header
        //
        // https://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html#sec8.2.3
        // https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.1.1
        // Using ContinueHandler a server can make decisioning on whether or not
        // to read a potentially large request body based on the headers
        //
        // The default is to automatically read request bodies of Expect 100 Continue requests
        // like they are normal requests
        ContinueHandler func(header *protocol.RequestHeader) bool

        // Indicates the engine status (Init/Running/Shutdown/Closed).
        status uint32

        // Hook functions get triggered sequentially when engine start
        OnRun []CtxErrCallback

        // Hook functions get triggered simultaneously when engine shutdown
        OnShutdown []CtxCallback

        // Custom Functions
        clientIPFunc  app.ClientIP
        formValueFunc app.FormValueFunc

        // Custom Binder and Validator
        binder    binding.Binder
        validator binding.StructValidator
}

func (engine *Engine) IsTraceEnable() bool <span class="cov8" title="1">{
        return engine.enableTrace
}</span>

func (engine *Engine) GetCtxPool() *sync.Pool <span class="cov8" title="1">{
        return &amp;engine.ctxPool
}</span>

func (engine *Engine) GetOptions() *config.Options <span class="cov0" title="0">{
        return engine.options
}</span>

// SetTransporter only sets the global default value for the transporter.
// Use WithTransporter during engine creation to set the transporter for the engine.
func SetTransporter(transporter func(options *config.Options) network.Transporter) <span class="cov8" title="1">{
        defaultTransporter = transporter
}</span>

func (engine *Engine) GetTransporterName() (tName string) <span class="cov8" title="1">{
        return getTransporterName(engine.transport)
}</span>

func getTransporterName(transporter network.Transporter) (tName string) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                err := recover()
                if err != nil || tName == "" </span><span class="cov0" title="0">{
                        tName = unknownTransporterName
                }</span>
        }()
        <span class="cov8" title="1">t := reflect.ValueOf(transporter).Type().String()
        tName = strings.Split(strings.TrimPrefix(t, "*"), ".")[0]
        return tName</span>
}

// Deprecated: This only get the global default transporter - may not be the real one used by the engine.
// Use engine.GetTransporterName for the real transporter used.
func GetTransporterName() (tName string) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                err := recover()
                if err != nil || tName == "" </span><span class="cov0" title="0">{
                        tName = unknownTransporterName
                }</span>
        }()
        <span class="cov8" title="1">fName := runtime.FuncForPC(reflect.ValueOf(defaultTransporter).Pointer()).Name()
        fSlice := strings.Split(fName, "/")
        name := fSlice[len(fSlice)-1]
        fSlice = strings.Split(name, ".")
        tName = fSlice[0]
        return</span>
}

func (engine *Engine) IsStreamRequestBody() bool <span class="cov0" title="0">{
        return engine.options.StreamRequestBody
}</span>

func (engine *Engine) IsRunning() bool <span class="cov8" title="1">{
        return atomic.LoadUint32(&amp;engine.status) == statusRunning
}</span>

func (engine *Engine) HijackConnHandle(c network.Conn, h app.HijackHandler) <span class="cov0" title="0">{
        engine.hijackConnHandler(c, h)
}</span>

func (engine *Engine) GetTracer() tracer.Controller <span class="cov8" title="1">{
        return engine.tracerCtl
}</span>

const (
        _ uint32 = iota
        statusInitialized
        statusRunning
        statusShutdown
        statusClosed
)

// NewContext make a pure RequestContext without any http request/response information
//
// Set the Request filed before use it for handlers
func (engine *Engine) NewContext() *app.RequestContext <span class="cov8" title="1">{
        return app.NewContext(engine.maxParams)
}</span>

// Shutdown starts the server's graceful exit by next steps:
//
//  1. Trigger OnShutdown hooks concurrently and wait them until wait timeout or finish
//  2. Close the net listener, which means new connection won't be accepted
//  3. Wait all connections get closed:
//     One connection gets closed after reaching out the shorter time of processing
//     one request (in hand or next incoming), idleTimeout or ExitWaitTime
//  4. Exit
func (engine *Engine) Shutdown(ctx context.Context) (err error) <span class="cov8" title="1">{
        if atomic.LoadUint32(&amp;engine.status) != statusRunning </span><span class="cov8" title="1">{
                return errStatusNotRunning
        }</span>
        <span class="cov8" title="1">if !atomic.CompareAndSwapUint32(&amp;engine.status, statusRunning, statusShutdown) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">ch := make(chan struct{})
        // trigger hooks if any
        go engine.executeOnShutdownHooks(ctx, ch)

        defer func() </span><span class="cov8" title="1">{
                // ensure that the hook is executed until wait timeout or finish
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        hlog.SystemLogger().Infof("Execute OnShutdownHooks timeout: error=%v", ctx.Err())
                        return</span>
                case &lt;-ch:<span class="cov8" title="1">
                        hlog.SystemLogger().Info("Execute OnShutdownHooks finish")
                        return</span>
                }
        }()

        <span class="cov8" title="1">if opt := engine.options; opt != nil &amp;&amp; opt.Registry != nil </span><span class="cov8" title="1">{
                if err = opt.Registry.Deregister(opt.RegistryInfo); err != nil </span><span class="cov8" title="1">{
                        hlog.SystemLogger().Errorf("Deregister error=%v", err)
                        return err
                }</span>
        }

        // call transport shutdown
        <span class="cov8" title="1">if err := engine.transport.Shutdown(ctx); err != ctx.Err() </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov0" title="0">return</span>
}

func (engine *Engine) executeOnShutdownHooks(ctx context.Context, ch chan struct{}) <span class="cov8" title="1">{
        wg := sync.WaitGroup{}
        for i := range engine.OnShutdown </span><span class="cov8" title="1">{
                wg.Add(1)
                go func(index int) </span><span class="cov8" title="1">{
                        defer wg.Done()
                        engine.OnShutdown[index](ctx)
                }</span>(i)
        }
        <span class="cov8" title="1">wg.Wait()
        ch &lt;- struct{}{}</span>
}

func (engine *Engine) Run() (err error) <span class="cov8" title="1">{
        if err = engine.Init(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // trigger hooks if any
        <span class="cov8" title="1">ctx := context.Background()
        for i := range engine.OnRun </span><span class="cov0" title="0">{
                if err = engine.OnRun[i](ctx); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">if err = engine.MarkAsRunning(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer atomic.StoreUint32(&amp;engine.status, statusClosed)

        return engine.listenAndServe()</span>
}

func (engine *Engine) Init() error <span class="cov8" title="1">{
        // add built-in http1 server by default
        if !engine.HasServer(suite.HTTP1) </span><span class="cov8" title="1">{
                engine.AddProtocol(suite.HTTP1, factory.NewServerFactory(newHttp1OptionFromEngine(engine)))
        }</span>

        <span class="cov8" title="1">serverMap, streamServerMap, err := engine.protocolSuite.LoadAll(engine)
        if err != nil </span><span class="cov0" title="0">{
                return errs.New(err, errs.ErrorTypePrivate, "LoadAll protocol suite error")
        }</span>

        <span class="cov8" title="1">engine.protocolServers = serverMap
        engine.protocolStreamServers = streamServerMap

        if engine.alpnEnable() </span><span class="cov0" title="0">{
                engine.options.TLS.NextProtos = append(engine.options.TLS.NextProtos, suite.HTTP1)
        }</span>

        <span class="cov8" title="1">if !atomic.CompareAndSwapUint32(&amp;engine.status, 0, statusInitialized) </span><span class="cov8" title="1">{
                return errInitFailed
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (engine *Engine) alpnEnable() bool <span class="cov8" title="1">{
        return engine.options.TLS != nil &amp;&amp; engine.options.ALPN
}</span>

func (engine *Engine) listenAndServe() error <span class="cov8" title="1">{
        hlog.SystemLogger().Infof("Using network library=%s", engine.GetTransporterName())
        return engine.transport.ListenAndServe(engine.onData)
}</span>

func (c *hijackConn) Close() error <span class="cov0" title="0">{
        if !c.e.KeepHijackedConns </span><span class="cov0" title="0">{
                // when we do not keep hijacked connections,
                // it is closed in hijackConnHandler.
                return nil
        }</span>

        <span class="cov0" title="0">conn := c.Conn
        c.e.releaseHijackConn(c)
        return conn.Close()</span>
}

func (engine *Engine) getNextProto(conn network.Conn) (proto string, err error) <span class="cov8" title="1">{
        if tlsConn, ok := conn.(network.ConnTLSer); ok </span><span class="cov8" title="1">{
                if engine.options.ReadTimeout &gt; 0 </span><span class="cov8" title="1">{
                        if err := conn.SetReadTimeout(engine.options.ReadTimeout); err != nil </span><span class="cov0" title="0">{
                                hlog.SystemLogger().Errorf("BUG: error in SetReadDeadline=%s: error=%s", engine.options.ReadTimeout, err)
                        }</span>
                }
                <span class="cov8" title="1">err = tlsConn.Handshake()
                if err == nil </span><span class="cov8" title="1">{
                        proto = tlsConn.ConnectionState().NegotiatedProtocol
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

func (engine *Engine) onData(c context.Context, conn interface{}) (err error) <span class="cov8" title="1">{
        switch conn := conn.(type) </span>{
        case network.Conn:<span class="cov8" title="1">
                err = engine.Serve(c, conn)</span>
        case network.StreamConn:<span class="cov8" title="1">
                err = engine.ServeStream(c, conn)</span>
        }
        <span class="cov8" title="1">return</span>
}

func errProcess(conn io.Closer, err error) <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov8" title="1">{
                        conn.Close()
                }</span>
        }()

        // Quiet close the connection
        <span class="cov8" title="1">if errors.Is(err, errs.ErrShortConnection) || errors.Is(err, errs.ErrIdleTimeout) </span><span class="cov8" title="1">{
                return
        }</span>

        // Do not process the hijack connection error
        <span class="cov0" title="0">if errors.Is(err, errs.ErrHijacked) </span><span class="cov0" title="0">{
                err = nil
                return
        }</span>

        // Get remote address
        <span class="cov0" title="0">rip := getRemoteAddrFromCloser(conn)

        // Handle Specific error
        if hsp, ok := conn.(network.HandleSpecificError); ok </span><span class="cov0" title="0">{
                if hsp.HandleSpecificError(err, rip) </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        // other errors
        <span class="cov0" title="0">hlog.SystemLogger().Errorf(hlog.EngineErrorFormat, err.Error(), rip)</span>
}

func getRemoteAddrFromCloser(conn io.Closer) string <span class="cov0" title="0">{
        if c, ok := conn.(network.Conn); ok </span><span class="cov0" title="0">{
                if addr := c.RemoteAddr(); addr != nil </span><span class="cov0" title="0">{
                        return addr.String()
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func (engine *Engine) Close() error <span class="cov0" title="0">{
        if engine.htmlRender != nil </span><span class="cov0" title="0">{
                engine.htmlRender.Close() //nolint:errcheck
        }</span>
        <span class="cov0" title="0">return engine.transport.Close()</span>
}

func (engine *Engine) GetServerName() []byte <span class="cov8" title="1">{
        v := engine.serverName.Load()
        var serverName []byte
        if v == nil </span><span class="cov8" title="1">{
                serverName = []byte(engine.Name)
                if len(serverName) == 0 </span><span class="cov8" title="1">{
                        serverName = bytestr.DefaultServerName
                }</span>
                <span class="cov8" title="1">engine.serverName.Store(serverName)</span>
        } else<span class="cov0" title="0"> {
                serverName = v.([]byte)
        }</span>
        <span class="cov8" title="1">return serverName</span>
}

func (engine *Engine) Serve(c context.Context, conn network.Conn) (err error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                errProcess(conn, err)
        }</span>()

        // H2C path
        <span class="cov8" title="1">if engine.options.H2C </span><span class="cov8" title="1">{
                // protocol sniffer
                buf, _ := conn.Peek(len(bytestr.StrClientPreface))
                if bytes.Equal(buf, bytestr.StrClientPreface) &amp;&amp; engine.protocolServers[suite.HTTP2] != nil </span><span class="cov8" title="1">{
                        return engine.protocolServers[suite.HTTP2].Serve(c, conn)
                }</span>
                <span class="cov0" title="0">hlog.SystemLogger().Warn("HTTP2 server is not loaded, request is going to fallback to HTTP1 server")</span>
        }

        // ALPN path
        <span class="cov8" title="1">if engine.options.ALPN &amp;&amp; engine.options.TLS != nil </span><span class="cov8" title="1">{
                proto, err1 := engine.getNextProto(conn)
                if err1 != nil </span><span class="cov0" title="0">{
                        // The client closes the connection when handshake. So just ignore it.
                        if err1 == io.EOF </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">if re, ok := err1.(tls.RecordHeaderError); ok &amp;&amp; re.Conn != nil &amp;&amp; utils.TLSRecordHeaderLooksLikeHTTP(re.RecordHeader) </span><span class="cov0" title="0">{
                                io.WriteString(re.Conn, "HTTP/1.0 400 Bad Request\r\n\r\nClient sent an HTTP request to an HTTPS server.\n")
                                re.Conn.Close()
                                return re
                        }</span>
                        <span class="cov0" title="0">return err1</span>
                }
                <span class="cov8" title="1">if server, ok := engine.protocolServers[proto]; ok </span><span class="cov0" title="0">{
                        return server.Serve(c, conn)
                }</span>
        }

        // HTTP1 path
        <span class="cov8" title="1">err = engine.protocolServers[suite.HTTP1].Serve(c, conn)

        return</span>
}

func (engine *Engine) ServeStream(ctx context.Context, conn network.StreamConn) error <span class="cov8" title="1">{
        // ALPN path
        if engine.options.ALPN &amp;&amp; engine.options.TLS != nil </span><span class="cov8" title="1">{
                version := conn.GetVersion()
                nextProtocol := versionToALNP(version)
                if server, ok := engine.protocolStreamServers[nextProtocol]; ok </span><span class="cov8" title="1">{
                        return server.Serve(ctx, conn)
                }</span>
        }

        // default path
        <span class="cov8" title="1">if server, ok := engine.protocolStreamServers[suite.HTTP3]; ok </span><span class="cov8" title="1">{
                return server.Serve(ctx, conn)
        }</span>
        <span class="cov8" title="1">return errs.ErrNotSupportProtocol</span>
}

func (engine *Engine) initBinderAndValidator(opt *config.Options) <span class="cov8" title="1">{
        // init validator
        if opt.CustomValidator != nil </span><span class="cov8" title="1">{
                customValidator, ok := opt.CustomValidator.(binding.StructValidator)
                if !ok </span><span class="cov8" title="1">{
                        panic("customized validator does not implement binding.StructValidator")</span>
                }
                <span class="cov8" title="1">engine.validator = customValidator</span>
        } else<span class="cov8" title="1"> {
                engine.validator = binding.NewValidator(binding.NewValidateConfig())
                if opt.ValidateConfig != nil </span><span class="cov8" title="1">{
                        vConf, ok := opt.ValidateConfig.(*binding.ValidateConfig)
                        if !ok </span><span class="cov0" title="0">{
                                panic("opt.ValidateConfig is not the '*binding.ValidateConfig' type")</span>
                        }
                        <span class="cov8" title="1">engine.validator = binding.NewValidator(vConf)</span>
                }
        }

        <span class="cov8" title="1">if opt.CustomBinder != nil </span><span class="cov8" title="1">{
                customBinder, ok := opt.CustomBinder.(binding.Binder)
                if !ok </span><span class="cov0" title="0">{
                        panic("customized binder can not implement binding.Binder")</span>
                }
                <span class="cov8" title="1">engine.binder = customBinder
                return</span>
        }
        // Init binder. Due to the existence of the "BindAndValidate" interface, the Validator needs to be injected here.
        <span class="cov8" title="1">defaultBindConfig := binding.NewBindConfig()
        defaultBindConfig.Validator = engine.validator
        engine.binder = binding.NewDefaultBinder(defaultBindConfig)
        if opt.BindConfig != nil </span><span class="cov8" title="1">{
                bConf, ok := opt.BindConfig.(*binding.BindConfig)
                if !ok </span><span class="cov0" title="0">{
                        panic("opt.BindConfig is not the '*binding.BindConfig' type")</span>
                }
                <span class="cov8" title="1">if bConf.Validator == nil </span><span class="cov0" title="0">{
                        bConf.Validator = engine.validator
                }</span>
                <span class="cov8" title="1">engine.binder = binding.NewDefaultBinder(bConf)</span>
        }
}

func NewEngine(opt *config.Options) *Engine <span class="cov8" title="1">{
        engine := &amp;Engine{
                trees: make(MethodTrees, 0, 9),
                RouterGroup: RouterGroup{
                        Handlers: nil,
                        basePath: opt.BasePath,
                        root:     true,
                },
                transport:             defaultTransporter(opt),
                tracerCtl:             &amp;internalStats.Controller{},
                protocolServers:       make(map[string]protocol.Server),
                protocolStreamServers: make(map[string]protocol.StreamServer),
                enableTrace:           true,
                options:               opt,
        }
        engine.initBinderAndValidator(opt)
        if opt.TransporterNewer != nil </span><span class="cov8" title="1">{
                engine.transport = opt.TransporterNewer(opt)
        }</span>
        <span class="cov8" title="1">engine.RouterGroup.engine = engine

        traceLevel := initTrace(engine)

        // prepare RequestContext pool
        engine.ctxPool.New = func() interface{} </span><span class="cov8" title="1">{
                ctx := engine.allocateContext()
                if engine.enableTrace </span><span class="cov0" title="0">{
                        ti := traceinfo.NewTraceInfo()
                        ti.Stats().SetLevel(traceLevel)
                        ctx.SetTraceInfo(ti)
                }</span>
                <span class="cov8" title="1">return ctx</span>
        }

        // Init protocolSuite
        <span class="cov8" title="1">engine.protocolSuite = suite.New()

        return engine</span>
}

func initTrace(engine *Engine) stats.Level <span class="cov8" title="1">{
        for _, ti := range engine.options.Tracers </span><span class="cov0" title="0">{
                if tracer, ok := ti.(tracer.Tracer); ok </span><span class="cov0" title="0">{
                        engine.tracerCtl.Append(tracer)
                }</span>
        }

        <span class="cov8" title="1">if !engine.tracerCtl.HasTracer() </span><span class="cov8" title="1">{
                engine.enableTrace = false
        }</span>

        <span class="cov8" title="1">traceLevel := stats.LevelDetailed
        if tl, ok := engine.options.TraceLevel.(stats.Level); ok </span><span class="cov0" title="0">{
                traceLevel = tl
        }</span>
        <span class="cov8" title="1">return traceLevel</span>
}

func debugPrintRoute(httpMethod, absolutePath string, handlers app.HandlersChain) <span class="cov8" title="1">{
        nuHandlers := len(handlers)
        handlerName := app.GetHandlerName(handlers.Last())
        if handlerName == "" </span><span class="cov8" title="1">{
                handlerName = utils.NameOfFunction(handlers.Last())
        }</span>
        <span class="cov8" title="1">hlog.SystemLogger().Debugf("Method=%-6s absolutePath=%-25s --&gt; handlerName=%s (num=%d handlers)", httpMethod, absolutePath, handlerName, nuHandlers)</span>
}

func (engine *Engine) addRoute(method, path string, handlers app.HandlersChain) <span class="cov8" title="1">{
        if len(path) == 0 </span><span class="cov0" title="0">{
                panic("path should not be ''")</span>
        }
        <span class="cov8" title="1">utils.Assert(path[0] == '/', "path must begin with '/'")
        utils.Assert(method != "", "HTTP method can not be empty")
        utils.Assert(len(handlers) &gt; 0, "there must be at least one handler")

        if !engine.options.DisablePrintRoute </span><span class="cov8" title="1">{
                debugPrintRoute(method, path, handlers)
        }</span>

        <span class="cov8" title="1">methodRouter := engine.trees.get(method)
        if methodRouter == nil </span><span class="cov8" title="1">{
                methodRouter = &amp;router{method: method, root: &amp;node{}, hasTsrHandler: make(map[string]bool)}
                engine.trees = append(engine.trees, methodRouter)
        }</span>
        <span class="cov8" title="1">methodRouter.addRoute(path, handlers)

        // Update maxParams
        if paramsCount := countParams(path); paramsCount &gt; engine.maxParams </span><span class="cov8" title="1">{
                engine.maxParams = paramsCount
        }</span>
}

func (engine *Engine) PrintRoute(method string) <span class="cov0" title="0">{
        root := engine.trees.get(method)
        printNode(root.root, 0)
}</span>

// debug use
func printNode(node *node, level int) <span class="cov0" title="0">{
        fmt.Println("node.prefix: " + node.prefix)
        fmt.Println("node.ppath: " + node.ppath)
        fmt.Printf("level: %#v\n\n", level)
        for i := 0; i &lt; len(node.children); i++ </span><span class="cov0" title="0">{
                printNode(node.children[i], level+1)
        }</span>
}

func (engine *Engine) recv(ctx *app.RequestContext) <span class="cov0" title="0">{
        if rcv := recover(); rcv != nil </span><span class="cov0" title="0">{
                engine.PanicHandler(context.Background(), ctx)
        }</span>
}

// ServeHTTP makes the router implement the Handler interface.
func (engine *Engine) ServeHTTP(c context.Context, ctx *app.RequestContext) <span class="cov8" title="1">{
        ctx.SetBinder(engine.binder)
        ctx.SetValidator(engine.validator)
        if engine.PanicHandler != nil </span><span class="cov0" title="0">{
                defer engine.recv(ctx)
        }</span>

        <span class="cov8" title="1">rPath := string(ctx.Request.URI().Path())

        // align with https://datatracker.ietf.org/doc/html/rfc2616#section-5.2
        if len(ctx.Request.Host()) == 0 &amp;&amp; ctx.Request.Header.IsHTTP11() &amp;&amp; bytesconv.B2s(ctx.Request.Method()) != consts.MethodConnect </span><span class="cov0" title="0">{
                ctx.SetHandlers(engine.Handlers)
                serveError(c, ctx, consts.StatusBadRequest, requiredHostBody)
                return
        }</span>

        <span class="cov8" title="1">httpMethod := bytesconv.B2s(ctx.Request.Header.Method())
        unescape := false
        if engine.options.UseRawPath </span><span class="cov8" title="1">{
                rPath = string(ctx.Request.URI().PathOriginal())
                unescape = engine.options.UnescapePathValues
        }</span>

        <span class="cov8" title="1">if engine.options.RemoveExtraSlash </span><span class="cov8" title="1">{
                rPath = utils.CleanPath(rPath)
        }</span>

        // Follow RFC7230#section-5.3
        <span class="cov8" title="1">if rPath == "" || rPath[0] != '/' </span><span class="cov0" title="0">{
                ctx.SetHandlers(engine.Handlers)
                serveError(c, ctx, consts.StatusBadRequest, default400Body)
                return
        }</span>

        // if Params is re-assigned in HandlerFunc and the capacity is not enough we need to realloc
        <span class="cov8" title="1">maxParams := int(engine.maxParams)
        if cap(ctx.Params) &lt; maxParams </span><span class="cov8" title="1">{
                ctx.Params = make(param.Params, 0, maxParams)
        }</span>

        // Find root of the tree for the given HTTP method
        <span class="cov8" title="1">t := engine.trees
        paramsPointer := &amp;ctx.Params
        for i, tl := 0, len(t); i &lt; tl; i++ </span><span class="cov8" title="1">{
                if t[i].method != httpMethod </span><span class="cov8" title="1">{
                        continue</span>
                }
                // Find route in tree
                <span class="cov8" title="1">value := t[i].find(rPath, paramsPointer, unescape)

                if value.handlers != nil </span><span class="cov8" title="1">{
                        ctx.SetHandlers(value.handlers)
                        ctx.SetFullPath(value.fullPath)
                        ctx.Next(c)
                        return
                }</span>
                <span class="cov8" title="1">if httpMethod != consts.MethodConnect &amp;&amp; rPath != "/" </span><span class="cov8" title="1">{
                        if value.tsr &amp;&amp; engine.options.RedirectTrailingSlash </span><span class="cov8" title="1">{
                                redirectTrailingSlash(ctx)
                                return
                        }</span>
                        <span class="cov8" title="1">if engine.options.RedirectFixedPath &amp;&amp; redirectFixedPath(ctx, t[i].root, engine.options.RedirectFixedPath) </span><span class="cov8" title="1">{
                                return
                        }</span>
                }
                <span class="cov8" title="1">break</span>
        }

        <span class="cov8" title="1">if engine.options.HandleMethodNotAllowed </span><span class="cov8" title="1">{
                for _, tree := range engine.trees </span><span class="cov8" title="1">{
                        if tree.method == httpMethod </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if value := tree.find(rPath, paramsPointer, unescape); value.handlers != nil </span><span class="cov8" title="1">{
                                ctx.SetHandlers(engine.allNoMethod)
                                serveError(c, ctx, consts.StatusMethodNotAllowed, default405Body)
                                return
                        }</span>
                }
        }
        <span class="cov8" title="1">ctx.SetHandlers(engine.allNoRoute)
        serveError(c, ctx, consts.StatusNotFound, default404Body)</span>
}

func (engine *Engine) allocateContext() *app.RequestContext <span class="cov8" title="1">{
        ctx := engine.NewContext()
        ctx.Request.SetMaxKeepBodySize(engine.options.MaxKeepBodySize)
        ctx.Response.SetMaxKeepBodySize(engine.options.MaxKeepBodySize)
        ctx.SetClientIPFunc(engine.clientIPFunc)
        ctx.SetFormValueFunc(engine.formValueFunc)
        return ctx
}</span>

func serveError(c context.Context, ctx *app.RequestContext, code int, defaultMessage []byte) <span class="cov8" title="1">{
        ctx.SetStatusCode(code)
        ctx.Next(c)
        if ctx.Response.StatusCode() == code </span><span class="cov8" title="1">{
                // if body exists(maybe customized by users), leave it alone.
                if ctx.Response.HasBodyBytes() || ctx.Response.IsBodyStream() </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">ctx.Response.Header.Set("Content-Type", "text/plain")
                ctx.Response.SetBody(defaultMessage)</span>
        }
}

func trailingSlashURL(ts string) string <span class="cov8" title="1">{
        tmpURI := ts + "/"
        if length := len(ts); length &gt; 1 &amp;&amp; ts[length-1] == '/' </span><span class="cov8" title="1">{
                tmpURI = ts[:length-1]
        }</span>
        <span class="cov8" title="1">return tmpURI</span>
}

func redirectTrailingSlash(c *app.RequestContext) <span class="cov8" title="1">{
        p := bytesconv.B2s(c.Request.URI().Path())
        if prefix := utils.CleanPath(bytesconv.B2s(c.Request.Header.Peek("X-Forwarded-Prefix"))); prefix != "." </span><span class="cov8" title="1">{
                p = prefix + "/" + p
        }</span>

        <span class="cov8" title="1">tmpURI := trailingSlashURL(p)

        query := c.Request.URI().QueryString()

        if len(query) &gt; 0 </span><span class="cov8" title="1">{
                tmpURI = tmpURI + "?" + bytesconv.B2s(query)
        }</span>

        <span class="cov8" title="1">c.Request.SetRequestURI(tmpURI)
        redirectRequest(c)</span>
}

func redirectRequest(c *app.RequestContext) <span class="cov8" title="1">{
        code := consts.StatusMovedPermanently // Permanent redirect, request with GET method
        if bytesconv.B2s(c.Request.Header.Method()) != consts.MethodGet </span><span class="cov8" title="1">{
                code = consts.StatusTemporaryRedirect
        }</span>

        <span class="cov8" title="1">c.Redirect(code, c.Request.URI().RequestURI())</span>
}

func redirectFixedPath(c *app.RequestContext, root *node, trailingSlash bool) bool <span class="cov8" title="1">{
        rPath := bytesconv.B2s(c.Request.URI().Path())
        if fixedPath, ok := root.findCaseInsensitivePath(utils.CleanPath(rPath), trailingSlash); ok </span><span class="cov8" title="1">{
                c.Request.SetRequestURI(bytesconv.B2s(fixedPath))
                redirectRequest(c)
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

// NoRoute adds handlers for NoRoute. It returns a 404 code by default.
func (engine *Engine) NoRoute(handlers ...app.HandlerFunc) <span class="cov8" title="1">{
        engine.noRoute = handlers
        engine.rebuild404Handlers()
}</span>

// NoMethod sets the handlers called when the HTTP method does not match.
func (engine *Engine) NoMethod(handlers ...app.HandlerFunc) <span class="cov8" title="1">{
        engine.noMethod = handlers
        engine.rebuild405Handlers()
}</span>

func (engine *Engine) rebuild404Handlers() <span class="cov8" title="1">{
        engine.allNoRoute = engine.combineHandlers(engine.noRoute)
}</span>

func (engine *Engine) rebuild405Handlers() <span class="cov8" title="1">{
        engine.allNoMethod = engine.combineHandlers(engine.noMethod)
}</span>

// Use attaches a global middleware to the router. ie. the middleware attached though Use() will be
// included in the handlers chain for every single request. Even 404, 405, static files...
//
// For example, this is the right place for a logger or error management middleware.
func (engine *Engine) Use(middleware ...app.HandlerFunc) IRoutes <span class="cov8" title="1">{
        engine.RouterGroup.Use(middleware...)
        engine.rebuild404Handlers()
        engine.rebuild405Handlers()
        return engine
}</span>

// LoadHTMLGlob loads HTML files identified by glob pattern
// and associates the result with HTML renderer.
func (engine *Engine) LoadHTMLGlob(pattern string) <span class="cov8" title="1">{
        tmpl := template.Must(template.New("").
                Delims(engine.delims.Left, engine.delims.Right).
                Funcs(engine.funcMap).
                ParseGlob(pattern))

        if engine.options.AutoReloadRender </span><span class="cov8" title="1">{
                files, err := filepath.Glob(pattern)
                if err != nil </span><span class="cov0" title="0">{
                        hlog.SystemLogger().Errorf("LoadHTMLGlob: %v", err)
                        return
                }</span>
                <span class="cov8" title="1">engine.SetAutoReloadHTMLTemplate(tmpl, files)
                return</span>
        }

        <span class="cov8" title="1">engine.SetHTMLTemplate(tmpl)</span>
}

// LoadHTMLFiles loads a slice of HTML files
// and associates the result with HTML renderer.
func (engine *Engine) LoadHTMLFiles(files ...string) <span class="cov8" title="1">{
        tmpl := template.Must(template.New("").
                Delims(engine.delims.Left, engine.delims.Right).
                Funcs(engine.funcMap).
                ParseFiles(files...))

        if engine.options.AutoReloadRender </span><span class="cov8" title="1">{
                engine.SetAutoReloadHTMLTemplate(tmpl, files)
                return
        }</span>

        <span class="cov0" title="0">engine.SetHTMLTemplate(tmpl)</span>
}

// SetHTMLTemplate associate a template with HTML renderer.
func (engine *Engine) SetHTMLTemplate(tmpl *template.Template) <span class="cov8" title="1">{
        engine.htmlRender = render.HTMLProduction{Template: tmpl.Funcs(engine.funcMap)}
}</span>

// SetAutoReloadHTMLTemplate associate a template with HTML renderer.
func (engine *Engine) SetAutoReloadHTMLTemplate(tmpl *template.Template, files []string) <span class="cov8" title="1">{
        engine.htmlRender = &amp;render.HTMLDebug{
                Template:        tmpl,
                Files:           files,
                FuncMap:         engine.funcMap,
                Delims:          engine.delims,
                RefreshInterval: engine.options.AutoReloadInterval,
        }
}</span>

// SetFuncMap sets the funcMap used for template.funcMap.
func (engine *Engine) SetFuncMap(funcMap template.FuncMap) <span class="cov8" title="1">{
        engine.funcMap = funcMap
}</span>

func (engine *Engine) SetClientIPFunc(f app.ClientIP) <span class="cov8" title="1">{
        engine.clientIPFunc = f
}</span>

func (engine *Engine) SetFormValueFunc(f app.FormValueFunc) <span class="cov8" title="1">{
        engine.formValueFunc = f
}</span>

// Delims sets template left and right delims and returns an Engine instance.
func (engine *Engine) Delims(left, right string) *Engine <span class="cov8" title="1">{
        engine.delims = render.Delims{Left: left, Right: right}
        return engine
}</span>

func (engine *Engine) acquireHijackConn(c network.Conn) *hijackConn <span class="cov8" title="1">{
        if engine.NoHijackConnPool </span><span class="cov8" title="1">{
                return &amp;hijackConn{
                        Conn: c,
                        e:    engine,
                }
        }</span>
        <span class="cov8" title="1">v := engine.hijackConnPool.Get()
        if v == nil </span><span class="cov8" title="1">{
                return &amp;hijackConn{
                        Conn: c,
                        e:    engine,
                }
        }</span>
        <span class="cov0" title="0">hjc := v.(*hijackConn)
        hjc.Conn = c
        return hjc</span>
}

func (engine *Engine) releaseHijackConn(hjc *hijackConn) <span class="cov0" title="0">{
        if engine.NoHijackConnPool </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">hjc.Conn = nil
        engine.hijackConnPool.Put(hjc)</span>
}

func (engine *Engine) hijackConnHandler(c network.Conn, h app.HijackHandler) <span class="cov0" title="0">{
        hjc := engine.acquireHijackConn(c)
        h(hjc)

        if !engine.KeepHijackedConns </span><span class="cov0" title="0">{
                c.Close()
                engine.releaseHijackConn(hjc)
        }</span>
}

// Routes returns a slice of registered routes, including some useful information, such as:
// the http method, path and the handler name.
func (engine *Engine) Routes() (routes RoutesInfo) <span class="cov8" title="1">{
        for _, tree := range engine.trees </span><span class="cov8" title="1">{
                routes = iterate(tree.method, routes, tree.root)
        }</span>

        <span class="cov8" title="1">return routes</span>
}

func (engine *Engine) AddProtocol(protocol string, factory interface{}) <span class="cov8" title="1">{
        engine.protocolSuite.Add(protocol, factory)
}</span>

// SetAltHeader sets the value of "Alt-Svc" header for protocols other than targetProtocol.
func (engine *Engine) SetAltHeader(targetProtocol, altHeaderValue string) <span class="cov0" title="0">{
        engine.protocolSuite.SetAltHeader(targetProtocol, altHeaderValue)
}</span>

func (engine *Engine) HasServer(name string) bool <span class="cov8" title="1">{
        return engine.protocolSuite.Get(name) != nil
}</span>

// iterate iterates the method tree by depth firstly.
func iterate(method string, routes RoutesInfo, root *node) RoutesInfo <span class="cov8" title="1">{
        if len(root.handlers) &gt; 0 </span><span class="cov8" title="1">{
                handlerFunc := root.handlers.Last()
                routes = append(routes, RouteInfo{
                        Method:      method,
                        Path:        root.ppath,
                        Handler:     utils.NameOfFunction(handlerFunc),
                        HandlerFunc: handlerFunc,
                })
        }</span>

        <span class="cov8" title="1">for _, child := range root.children </span><span class="cov8" title="1">{
                routes = iterate(method, routes, child)
        }</span>

        <span class="cov8" title="1">if root.paramChild != nil </span><span class="cov8" title="1">{
                routes = iterate(method, routes, root.paramChild)
        }</span>

        <span class="cov8" title="1">if root.anyChild != nil </span><span class="cov8" title="1">{
                routes = iterate(method, routes, root.anyChild)
        }</span>
        <span class="cov8" title="1">return routes</span>
}

// for built-in http1 impl only.
func newHttp1OptionFromEngine(engine *Engine) *http1.Option <span class="cov8" title="1">{
        opt := &amp;http1.Option{
                StreamRequestBody:             engine.options.StreamRequestBody,
                GetOnly:                       engine.options.GetOnly,
                DisablePreParseMultipartForm:  engine.options.DisablePreParseMultipartForm,
                DisableKeepalive:              engine.options.DisableKeepalive,
                NoDefaultServerHeader:         engine.options.NoDefaultServerHeader,
                MaxRequestBodySize:            engine.options.MaxRequestBodySize,
                IdleTimeout:                   engine.options.IdleTimeout,
                ReadTimeout:                   engine.options.ReadTimeout,
                ServerName:                    engine.GetServerName(),
                ContinueHandler:               engine.ContinueHandler,
                TLS:                           engine.options.TLS,
                HTMLRender:                    engine.htmlRender,
                EnableTrace:                   engine.IsTraceEnable(),
                HijackConnHandle:              engine.HijackConnHandle,
                DisableHeaderNamesNormalizing: engine.options.DisableHeaderNamesNormalizing,
                NoDefaultDate:                 engine.options.NoDefaultDate,
                NoDefaultContentType:          engine.options.NoDefaultContentType,
        }
        // Idle timeout of standard network must not be zero. Set it to -1 seconds if it is zero.
        // Due to the different triggering ways of the network library, see the actual use of this value for the detailed reasons.
        if opt.IdleTimeout == 0 &amp;&amp; engine.GetTransporterName() == "standard" </span><span class="cov8" title="1">{
                opt.IdleTimeout = -1
        }</span>
        <span class="cov8" title="1">return opt</span>
}

func versionToALNP(v uint32) string <span class="cov8" title="1">{
        if v == network.Version1 || v == network.Version2 </span><span class="cov8" title="1">{
                return suite.HTTP3
        }</span>
        <span class="cov0" title="0">if v == network.VersionTLS || v == network.VersionDraft29 </span><span class="cov0" title="0">{
                return suite.HTTP3Draft29
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// MarkAsRunning will mark the status of the hertz engine as "running".
// Warning: do not call this method by yourself, unless you know what you are doing.
func (engine *Engine) MarkAsRunning() (err error) <span class="cov8" title="1">{
        if !atomic.CompareAndSwapUint32(&amp;engine.status, statusInitialized, statusRunning) </span><span class="cov0" title="0">{
                return errAlreadyRunning
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file97" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Manuel MartÃ­nez-Almeida
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This file may have been modified by CloudWeGo authors. All CloudWeGo
 * Modifications are Copyright 2022 CloudWeGo Authors
 */

package route

import (
        "context"
        "path"
        "regexp"
        "strings"

        "github.com/cloudwego/hertz/pkg/app"
        "github.com/cloudwego/hertz/pkg/protocol/consts"
        rConsts "github.com/cloudwego/hertz/pkg/route/consts"
)

// IRouter defines all router handle interface includes single and group router.
type IRouter interface {
        IRoutes
        Group(string, ...app.HandlerFunc) *RouterGroup
}

// IRoutes defines all router handle interface.
type IRoutes interface {
        Use(...app.HandlerFunc) IRoutes
        Handle(string, string, ...app.HandlerFunc) IRoutes
        Any(string, ...app.HandlerFunc) IRoutes
        GET(string, ...app.HandlerFunc) IRoutes
        POST(string, ...app.HandlerFunc) IRoutes
        DELETE(string, ...app.HandlerFunc) IRoutes
        PATCH(string, ...app.HandlerFunc) IRoutes
        PUT(string, ...app.HandlerFunc) IRoutes
        OPTIONS(string, ...app.HandlerFunc) IRoutes
        HEAD(string, ...app.HandlerFunc) IRoutes
        StaticFile(string, string) IRoutes
        Static(string, string) IRoutes
        StaticFS(string, *app.FS) IRoutes
}

// RouterGroup is used internally to configure router, a RouterGroup is associated with
// a prefix and an array of handlers (middleware).
type RouterGroup struct {
        Handlers app.HandlersChain
        basePath string
        engine   *Engine
        root     bool
}

var _ IRouter = (*RouterGroup)(nil)

// Use adds middleware to the group, see example code in GitHub.
func (group *RouterGroup) Use(middleware ...app.HandlerFunc) IRoutes <span class="cov8" title="1">{
        group.Handlers = append(group.Handlers, middleware...)
        return group.returnObj()
}</span>

// Group creates a new router group. You should add all the routes that have common middlewares or the same path prefix.
// For example, all the routes that use a common middleware for authorization could be grouped.
func (group *RouterGroup) Group(relativePath string, handlers ...app.HandlerFunc) *RouterGroup <span class="cov8" title="1">{
        return &amp;RouterGroup{
                Handlers: group.combineHandlers(handlers),
                basePath: group.calculateAbsolutePath(relativePath),
                engine:   group.engine,
        }
}</span>

// BasePath returns the base path of router group.
// For example, if v := router.Group("/rest/n/v1/api"), v.BasePath() is "/rest/n/v1/api".
func (group *RouterGroup) BasePath() string <span class="cov8" title="1">{
        return group.basePath
}</span>

func (group *RouterGroup) handle(httpMethod, relativePath string, handlers app.HandlersChain) IRoutes <span class="cov8" title="1">{
        absolutePath := group.calculateAbsolutePath(relativePath)
        handlers = group.combineHandlers(handlers)
        group.engine.addRoute(httpMethod, absolutePath, handlers)
        return group.returnObj()
}</span>

var upperLetterReg = regexp.MustCompile("^[A-Z]+$")

// Handle registers a new request handle and middleware with the given path and method.
// The last handler should be the real handler, the other ones should be middleware that can and should be shared among different routes.
// See the example code in GitHub.
//
// For GET, POST, PUT, PATCH and DELETE requests the respective shortcut
// functions can be used.
//
// This function is intended for bulk loading and to allow the usage of less
// frequently used, non-standardized or custom methods (e.g. for internal
// communication with a proxy).
func (group *RouterGroup) Handle(httpMethod, relativePath string, handlers ...app.HandlerFunc) IRoutes <span class="cov8" title="1">{
        if matches := upperLetterReg.MatchString(httpMethod); !matches </span><span class="cov8" title="1">{
                panic("http method " + httpMethod + " is not valid")</span>
        }
        <span class="cov8" title="1">return group.handle(httpMethod, relativePath, handlers)</span>
}

// POST is a shortcut for router.Handle("POST", path, handle).
func (group *RouterGroup) POST(relativePath string, handlers ...app.HandlerFunc) IRoutes <span class="cov8" title="1">{
        return group.handle(consts.MethodPost, relativePath, handlers)
}</span>

// GET is a shortcut for router.Handle("GET", path, handle).
func (group *RouterGroup) GET(relativePath string, handlers ...app.HandlerFunc) IRoutes <span class="cov8" title="1">{
        return group.handle(consts.MethodGet, relativePath, handlers)
}</span>

// DELETE is a shortcut for router.Handle("DELETE", path, handle).
func (group *RouterGroup) DELETE(relativePath string, handlers ...app.HandlerFunc) IRoutes <span class="cov8" title="1">{
        return group.handle(consts.MethodDelete, relativePath, handlers)
}</span>

// PATCH is a shortcut for router.Handle("PATCH", path, handle).
func (group *RouterGroup) PATCH(relativePath string, handlers ...app.HandlerFunc) IRoutes <span class="cov8" title="1">{
        return group.handle(consts.MethodPatch, relativePath, handlers)
}</span>

// PUT is a shortcut for router.Handle("PUT", path, handle).
func (group *RouterGroup) PUT(relativePath string, handlers ...app.HandlerFunc) IRoutes <span class="cov8" title="1">{
        return group.handle(consts.MethodPut, relativePath, handlers)
}</span>

// OPTIONS is a shortcut for router.Handle("OPTIONS", path, handle).
func (group *RouterGroup) OPTIONS(relativePath string, handlers ...app.HandlerFunc) IRoutes <span class="cov8" title="1">{
        return group.handle(consts.MethodOptions, relativePath, handlers)
}</span>

// HEAD is a shortcut for router.Handle("HEAD", path, handle).
func (group *RouterGroup) HEAD(relativePath string, handlers ...app.HandlerFunc) IRoutes <span class="cov8" title="1">{
        return group.handle(consts.MethodHead, relativePath, handlers)
}</span>

// Any registers a route that matches all the HTTP methods.
// GET, POST, PUT, PATCH, HEAD, OPTIONS, DELETE, CONNECT, TRACE.
func (group *RouterGroup) Any(relativePath string, handlers ...app.HandlerFunc) IRoutes <span class="cov8" title="1">{
        group.handle(consts.MethodGet, relativePath, handlers)
        group.handle(consts.MethodPost, relativePath, handlers)
        group.handle(consts.MethodPut, relativePath, handlers)
        group.handle(consts.MethodPatch, relativePath, handlers)
        group.handle(consts.MethodHead, relativePath, handlers)
        group.handle(consts.MethodOptions, relativePath, handlers)
        group.handle(consts.MethodDelete, relativePath, handlers)
        group.handle(consts.MethodConnect, relativePath, handlers)
        group.handle(consts.MethodTrace, relativePath, handlers)
        return group.returnObj()
}</span>

// StaticFile registers a single route in order to Serve a single file of the local filesystem.
// router.StaticFile("favicon.ico", "./resources/favicon.ico")
func (group *RouterGroup) StaticFile(relativePath, filepath string) IRoutes <span class="cov8" title="1">{
        if strings.Contains(relativePath, ":") || strings.Contains(relativePath, "*") </span><span class="cov8" title="1">{
                panic("URL parameters can not be used when serving a static file")</span>
        }
        <span class="cov8" title="1">handler := func(c context.Context, ctx *app.RequestContext) </span><span class="cov8" title="1">{
                ctx.File(filepath)
        }</span>
        <span class="cov8" title="1">group.GET(relativePath, handler)
        group.HEAD(relativePath, handler)
        return group.returnObj()</span>
}

// Static serves files from the given file system root.
// To use the operating system's file system implementation,
// use :
//
//        router.Static("/static", "/var/www")
func (group *RouterGroup) Static(relativePath, root string) IRoutes <span class="cov8" title="1">{
        return group.StaticFS(relativePath, &amp;app.FS{Root: root})
}</span>

// StaticFS works just like `Static()` but a custom `FS` can be used instead.
func (group *RouterGroup) StaticFS(relativePath string, fs *app.FS) IRoutes <span class="cov8" title="1">{
        if strings.Contains(relativePath, ":") || strings.Contains(relativePath, "*") </span><span class="cov8" title="1">{
                panic("URL parameters can not be used when serving a static folder")</span>
        }
        <span class="cov8" title="1">handler := fs.NewRequestHandler()
        urlPattern := path.Join(relativePath, "/*filepath")

        // Register GET and HEAD handlers
        group.GET(urlPattern, handler)
        group.HEAD(urlPattern, handler)
        return group.returnObj()</span>
}

func (group *RouterGroup) combineHandlers(handlers app.HandlersChain) app.HandlersChain <span class="cov8" title="1">{
        finalSize := len(group.Handlers) + len(handlers)
        if finalSize &gt;= int(rConsts.AbortIndex) </span><span class="cov8" title="1">{
                panic("too many handlers")</span>
        }
        <span class="cov8" title="1">mergedHandlers := make(app.HandlersChain, finalSize)
        copy(mergedHandlers, group.Handlers)
        copy(mergedHandlers[len(group.Handlers):], handlers)
        return mergedHandlers</span>
}

func (group *RouterGroup) calculateAbsolutePath(relativePath string) string <span class="cov8" title="1">{
        return joinPaths(group.basePath, relativePath)
}</span>

func (group *RouterGroup) returnObj() IRoutes <span class="cov8" title="1">{
        if group.root </span><span class="cov8" title="1">{
                return group.engine
        }</span>
        <span class="cov8" title="1">return group</span>
}

// GETEX adds a handlerName param. When handler is decorated or handler is an anonymous function,
// Hertz cannot get handler name directly. In this case, pass handlerName explicitly.
func (group *RouterGroup) GETEX(relativePath string, handler app.HandlerFunc, handlerName string) IRoutes <span class="cov0" title="0">{
        app.SetHandlerName(handler, handlerName)
        return group.GET(relativePath, handler)
}</span>

// POSTEX adds a handlerName param. When handler is decorated or handler is an anonymous function,
// Hertz cannot get handler name directly. In this case, pass handlerName explicitly.
func (group *RouterGroup) POSTEX(relativePath string, handler app.HandlerFunc, handlerName string) IRoutes <span class="cov0" title="0">{
        app.SetHandlerName(handler, handlerName)
        return group.POST(relativePath, handler)
}</span>

// PUTEX adds a handlerName param. When handler is decorated or handler is an anonymous function,
// Hertz cannot get handler name directly. In this case, pass handlerName explicitly.
func (group *RouterGroup) PUTEX(relativePath string, handler app.HandlerFunc, handlerName string) IRoutes <span class="cov0" title="0">{
        app.SetHandlerName(handler, handlerName)
        return group.PUT(relativePath, handler)
}</span>

// DELETEEX adds a handlerName param. When handler is decorated or handler is an anonymous function,
// Hertz cannot get handler name directly. In this case, pass handlerName explicitly.
func (group *RouterGroup) DELETEEX(relativePath string, handler app.HandlerFunc, handlerName string) IRoutes <span class="cov0" title="0">{
        app.SetHandlerName(handler, handlerName)
        return group.DELETE(relativePath, handler)
}</span>

// HEADEX adds a handlerName param. When handler is decorated or handler is an anonymous function,
// Hertz cannot get handler name directly. In this case, pass handlerName explicitly.
func (group *RouterGroup) HEADEX(relativePath string, handler app.HandlerFunc, handlerName string) IRoutes <span class="cov0" title="0">{
        app.SetHandlerName(handler, handlerName)
        return group.HEAD(relativePath, handler)
}</span>

// AnyEX adds a handlerName param. When handler is decorated or handler is an anonymous function,
// Hertz cannot get handler name directly. In this case, pass handlerName explicitly.
func (group *RouterGroup) AnyEX(relativePath string, handler app.HandlerFunc, handlerName string) IRoutes <span class="cov0" title="0">{
        app.SetHandlerName(handler, handlerName)
        return group.Any(relativePath, handler)
}</span>

// HandleEX adds a handlerName param. When handler is decorated or handler is an anonymous function,
// Hertz cannot get handler name directly. In this case, pass handlerName explicitly.
func (group *RouterGroup) HandleEX(httpMethod, relativePath string, handler app.HandlerFunc, handlerName string) IRoutes <span class="cov0" title="0">{
        app.SetHandlerName(handler, handlerName)
        return group.Handle(httpMethod, relativePath, handler)
}</span>

func joinPaths(absolutePath, relativePath string) string <span class="cov8" title="1">{
        if relativePath == "" </span><span class="cov0" title="0">{
                return absolutePath
        }</span>

        <span class="cov8" title="1">finalPath := path.Join(absolutePath, relativePath)
        appendSlash := lastChar(relativePath) == '/' &amp;&amp; lastChar(finalPath) != '/'
        if appendSlash </span><span class="cov8" title="1">{
                return finalPath + "/"
        }</span>
        <span class="cov8" title="1">return finalPath</span>
}

func lastChar(str string) uint8 <span class="cov8" title="1">{
        if str == "" </span><span class="cov0" title="0">{
                panic("The length of the string can't be 0")</span>
        }
        <span class="cov8" title="1">return str[len(str)-1]</span>
}
</pre>
		
		<pre class="file" id="file98" style="display: none">/*
 * Copyright 2022 CloudWeGo Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2021 LabStack
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * This file may have been modified by CloudWeGo authors. All CloudWeGo
 * Modifications are Copyright 2022 CloudWeGo Authors.
 */

package route

import (
        "bytes"
        "fmt"
        "net/url"
        "strings"
        "unicode"

        "github.com/cloudwego/hertz/internal/bytesconv"
        "github.com/cloudwego/hertz/internal/bytestr"
        "github.com/cloudwego/hertz/pkg/app"
        "github.com/cloudwego/hertz/pkg/route/param"
)

type router struct {
        method        string
        root          *node
        hasTsrHandler map[string]bool
}

type MethodTrees []*router

func (trees MethodTrees) get(method string) *router <span class="cov8" title="1">{
        for _, tree := range trees </span><span class="cov8" title="1">{
                if tree.method == method </span><span class="cov8" title="1">{
                        return tree
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func countParams(path string) uint16 <span class="cov8" title="1">{
        var n uint16
        s := bytesconv.S2b(path)
        n += uint16(bytes.Count(s, bytestr.StrColon))
        n += uint16(bytes.Count(s, bytestr.StrStar))
        return n
}</span>

type (
        node struct {
                kind     kind
                label    byte
                prefix   string
                parent   *node
                children children
                // original path
                ppath string
                // param names
                pnames     []string
                handlers   app.HandlersChain
                paramChild *node
                anyChild   *node
                // isLeaf indicates that node does not have child routes
                isLeaf bool
        }
        kind     uint8
        children []*node
)

const (
        // static kind
        skind kind = iota
        // param kind
        pkind
        // all kind
        akind
        paramLabel = byte(':')
        anyLabel   = byte('*')
        slash      = "/"
        nilString  = ""
)

func checkPathValid(path string) <span class="cov8" title="1">{
        if path == nilString </span><span class="cov8" title="1">{
                panic("empty path")</span>
        }
        <span class="cov8" title="1">if path[0] != '/' </span><span class="cov8" title="1">{
                panic("path must begin with '/'")</span>
        }
        <span class="cov8" title="1">for i, c := range []byte(path) </span><span class="cov8" title="1">{
                switch c </span>{
                case ':':<span class="cov8" title="1">
                        if (i &lt; len(path)-1 &amp;&amp; path[i+1] == '/') || i == (len(path)-1) </span><span class="cov8" title="1">{
                                panic("wildcards must be named with a non-empty name in path '" + path + "'")</span>
                        }
                        <span class="cov8" title="1">i++
                        for ; i &lt; len(path) &amp;&amp; path[i] != '/'; i++ </span><span class="cov8" title="1">{
                                if path[i] == ':' || path[i] == '*' </span><span class="cov8" title="1">{
                                        panic("only one wildcard per path segment is allowed, find multi in path '" + path + "'")</span>
                                }
                        }
                case '*':<span class="cov8" title="1">
                        if i == len(path)-1 </span><span class="cov8" title="1">{
                                panic("wildcards must be named with a non-empty name in path '" + path + "'")</span>
                        }
                        <span class="cov8" title="1">if i &gt; 0 &amp;&amp; path[i-1] != '/' </span><span class="cov8" title="1">{
                                panic(" no / before wildcards in path " + path)</span>
                        }
                        <span class="cov8" title="1">for ; i &lt; len(path); i++ </span><span class="cov8" title="1">{
                                if path[i] == '/' </span><span class="cov8" title="1">{
                                        panic("catch-all routes are only allowed at the end of the path in path '" + path + "'")</span>
                                }
                        }
                }
        }
}

// addRoute adds a node with the given handle to the path.
func (r *router) addRoute(path string, h app.HandlersChain) <span class="cov8" title="1">{
        checkPathValid(path)

        var (
                pnames []string // Param names
                ppath  = path   // Pristine path
        )

        if h == nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("Adding route without handler function: %v", path))</span>
        }

        // Add the front static route part of a non-static route
        <span class="cov8" title="1">for i, lcpIndex := 0, len(path); i &lt; lcpIndex; i++ </span><span class="cov8" title="1">{
                // param route
                if path[i] == paramLabel </span><span class="cov8" title="1">{
                        j := i + 1

                        r.insert(path[:i], nil, skind, nilString, nil)
                        for ; i &lt; lcpIndex &amp;&amp; path[i] != '/'; i++ </span>{<span class="cov8" title="1">
                        }</span>

                        <span class="cov8" title="1">pnames = append(pnames, path[j:i])
                        path = path[:j] + path[i:]
                        i, lcpIndex = j, len(path)

                        if i == lcpIndex </span><span class="cov8" title="1">{
                                // path node is last fragment of route path. ie. `/users/:id`
                                r.insert(path[:i], h, pkind, ppath, pnames)
                                return
                        }</span> else<span class="cov8" title="1"> {
                                r.insert(path[:i], nil, pkind, nilString, pnames)
                        }</span>
                } else<span class="cov8" title="1"> if path[i] == anyLabel </span><span class="cov8" title="1">{
                        r.insert(path[:i], nil, skind, nilString, nil)
                        pnames = append(pnames, path[i+1:])
                        r.insert(path[:i+1], h, akind, ppath, pnames)
                        return
                }</span>
        }

        <span class="cov8" title="1">r.insert(path, h, skind, ppath, pnames)</span>
}

func (r *router) insert(path string, h app.HandlersChain, t kind, ppath string, pnames []string) <span class="cov8" title="1">{
        currentNode := r.root
        if currentNode == nil </span><span class="cov0" title="0">{
                panic("hertz: invalid node")</span>
        }
        <span class="cov8" title="1">search := path

        for </span><span class="cov8" title="1">{
                searchLen := len(search)
                prefixLen := len(currentNode.prefix)
                lcpLen := 0

                max := prefixLen
                if searchLen &lt; max </span><span class="cov8" title="1">{
                        max = searchLen
                }</span>
                <span class="cov8" title="1">for ; lcpLen &lt; max &amp;&amp; search[lcpLen] == currentNode.prefix[lcpLen]; lcpLen++ </span>{<span class="cov8" title="1">
                }</span>

                <span class="cov8" title="1">if lcpLen == 0 </span><span class="cov8" title="1">{
                        // At root node
                        currentNode.label = search[0]
                        currentNode.prefix = search
                        if h != nil </span><span class="cov8" title="1">{
                                currentNode.kind = t
                                currentNode.handlers = h
                                currentNode.ppath = ppath
                                currentNode.pnames = pnames
                        }</span>
                        <span class="cov8" title="1">currentNode.isLeaf = currentNode.children == nil &amp;&amp; currentNode.paramChild == nil &amp;&amp; currentNode.anyChild == nil</span>
                } else<span class="cov8" title="1"> if lcpLen &lt; prefixLen </span><span class="cov8" title="1">{
                        // Split node
                        n := newNode(
                                currentNode.kind,
                                currentNode.prefix[lcpLen:],
                                currentNode,
                                currentNode.children,
                                currentNode.handlers,
                                currentNode.ppath,
                                currentNode.pnames,
                                currentNode.paramChild,
                                currentNode.anyChild,
                        )
                        // Update parent path for all children to new node
                        for _, child := range currentNode.children </span><span class="cov8" title="1">{
                                child.parent = n
                        }</span>
                        <span class="cov8" title="1">if currentNode.paramChild != nil </span><span class="cov8" title="1">{
                                currentNode.paramChild.parent = n
                        }</span>
                        <span class="cov8" title="1">if currentNode.anyChild != nil </span><span class="cov8" title="1">{
                                currentNode.anyChild.parent = n
                        }</span>

                        // Reset parent node
                        <span class="cov8" title="1">currentNode.kind = skind
                        currentNode.label = currentNode.prefix[0]
                        currentNode.prefix = currentNode.prefix[:lcpLen]
                        currentNode.children = nil
                        currentNode.handlers = nil
                        currentNode.ppath = nilString
                        currentNode.pnames = nil
                        currentNode.paramChild = nil
                        currentNode.anyChild = nil
                        currentNode.isLeaf = false

                        // Only Static children could reach here
                        currentNode.children = append(currentNode.children, n)

                        if lcpLen == searchLen </span><span class="cov8" title="1">{
                                // At parent node
                                currentNode.kind = t
                                currentNode.handlers = h
                                currentNode.ppath = ppath
                                currentNode.pnames = pnames
                        }</span> else<span class="cov8" title="1"> {
                                // Create child node
                                n = newNode(t, search[lcpLen:], currentNode, nil, h, ppath, pnames, nil, nil)
                                // Only Static children could reach here
                                currentNode.children = append(currentNode.children, n)
                        }</span>
                        <span class="cov8" title="1">currentNode.isLeaf = currentNode.children == nil &amp;&amp; currentNode.paramChild == nil &amp;&amp; currentNode.anyChild == nil</span>
                } else<span class="cov8" title="1"> if lcpLen &lt; searchLen </span><span class="cov8" title="1">{
                        search = search[lcpLen:]
                        c := currentNode.findChildWithLabel(search[0])
                        if c != nil </span><span class="cov8" title="1">{
                                // Go deeper
                                currentNode = c
                                continue</span>
                        }
                        // Create child node
                        <span class="cov8" title="1">n := newNode(t, search, currentNode, nil, h, ppath, pnames, nil, nil)
                        switch t </span>{
                        case skind:<span class="cov8" title="1">
                                currentNode.children = append(currentNode.children, n)</span>
                        case pkind:<span class="cov8" title="1">
                                currentNode.paramChild = n</span>
                        case akind:<span class="cov8" title="1">
                                currentNode.anyChild = n</span>
                        }
                        <span class="cov8" title="1">currentNode.isLeaf = currentNode.children == nil &amp;&amp; currentNode.paramChild == nil &amp;&amp; currentNode.anyChild == nil</span>
                } else<span class="cov8" title="1"> {
                        // Node already exists
                        if currentNode.handlers != nil &amp;&amp; h != nil </span><span class="cov8" title="1">{
                                panic("handlers are already registered for path '" + ppath + "'")</span>
                        }

                        <span class="cov8" title="1">if h != nil </span><span class="cov8" title="1">{
                                currentNode.handlers = h
                                currentNode.ppath = ppath
                                currentNode.pnames = pnames
                        }</span>
                }
                <span class="cov8" title="1">return</span>
        }
}

// find finds registered handler by method and path, parses URL params and puts params to context
func (r *router) find(path string, paramsPointer *param.Params, unescape bool) (res nodeValue) <span class="cov8" title="1">{
        var (
                cn          = r.root // current node
                search      = path   // current path
                searchIndex = 0
                buf         []byte
                paramIndex  int
        )

        backtrackToNextNodeKind := func(fromKind kind) (nextNodeKind kind, valid bool) </span><span class="cov8" title="1">{
                previous := cn
                cn = previous.parent
                valid = cn != nil

                // Next node type by priority
                if previous.kind == akind </span><span class="cov0" title="0">{
                        nextNodeKind = skind
                }</span> else<span class="cov8" title="1"> {
                        nextNodeKind = previous.kind + 1
                }</span>

                <span class="cov8" title="1">if fromKind == skind </span><span class="cov8" title="1">{
                        // when backtracking is done from static kind block we did not change search so nothing to restore
                        return
                }</span>

                // restore search to value it was before we move to current node we are backtracking from.
                <span class="cov8" title="1">if previous.kind == skind </span><span class="cov8" title="1">{
                        searchIndex -= len(previous.prefix)
                }</span> else<span class="cov8" title="1"> {
                        paramIndex--
                        // for param/any node.prefix value is always `:` so we can not deduce searchIndex from that and must use pValue
                        // for that index as it would also contain part of path we cut off before moving into node we are backtracking from
                        searchIndex -= len((*paramsPointer)[paramIndex].Value)
                        (*paramsPointer) = (*paramsPointer)[:paramIndex]
                }</span>
                <span class="cov8" title="1">search = path[searchIndex:]
                return</span>
        }

        // search order: static &gt; param &gt; any
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                if cn.kind == skind </span><span class="cov8" title="1">{
                        if len(search) &gt;= len(cn.prefix) &amp;&amp; cn.prefix == search[:len(cn.prefix)] </span><span class="cov8" title="1">{
                                // Continue search
                                search = search[len(cn.prefix):]
                                searchIndex = searchIndex + len(cn.prefix)
                        }</span> else<span class="cov8" title="1"> {
                                // not equal
                                if (len(cn.prefix) == len(search)+1) &amp;&amp;
                                        (cn.prefix[len(search)]) == '/' &amp;&amp; cn.prefix[:len(search)] == search &amp;&amp; (cn.handlers != nil || cn.anyChild != nil) </span><span class="cov8" title="1">{
                                        res.tsr = true
                                }</span>
                                // No matching prefix, let's backtrack to the first possible alternative node of the decision path
                                <span class="cov8" title="1">nk, ok := backtrackToNextNodeKind(skind)
                                if !ok </span><span class="cov8" title="1">{
                                        return // No other possibilities on the decision path
                                }</span> else<span class="cov8" title="1"> if nk == pkind </span><span class="cov8" title="1">{
                                        goto Param</span>
                                } else<span class="cov0" title="0"> {
                                        // Not found (this should never be possible for static node we are looking currently)
                                        break</span>
                                }
                        }
                }
                <span class="cov8" title="1">if search == nilString &amp;&amp; len(cn.handlers) != 0 </span><span class="cov8" title="1">{
                        res.handlers = cn.handlers
                        break</span>
                }

                // Static node
                <span class="cov8" title="1">if search != nilString </span><span class="cov8" title="1">{
                        // If it can execute that logic, there is handler registered on the current node and search is `/`.
                        if search == "/" &amp;&amp; cn.handlers != nil </span><span class="cov8" title="1">{
                                res.tsr = true
                        }</span>
                        <span class="cov8" title="1">if child := cn.findChild(search[0]); child != nil </span><span class="cov8" title="1">{
                                cn = child
                                continue</span>
                        }
                }

                <span class="cov8" title="1">if search == nilString </span><span class="cov8" title="1">{
                        if cd := cn.findChild('/'); cd != nil &amp;&amp; (cd.handlers != nil || cd.anyChild != nil) </span><span class="cov8" title="1">{
                                res.tsr = true
                        }</span>
                }

        Param:
                // Param node
                <span class="cov8" title="1">if child := cn.paramChild; search != nilString &amp;&amp; child != nil </span><span class="cov8" title="1">{
                        cn = child
                        i := strings.Index(search, slash)
                        if i == -1 </span><span class="cov8" title="1">{
                                i = len(search)
                        }</span>
                        <span class="cov8" title="1">(*paramsPointer) = (*paramsPointer)[:(paramIndex + 1)]
                        val := search[:i]
                        if unescape </span><span class="cov8" title="1">{
                                if v, err := url.QueryUnescape(search[:i]); err == nil </span><span class="cov8" title="1">{
                                        val = v
                                }</span>
                        }
                        <span class="cov8" title="1">(*paramsPointer)[paramIndex].Value = val
                        paramIndex++
                        search = search[i:]
                        searchIndex = searchIndex + i
                        if search == nilString </span><span class="cov8" title="1">{
                                if cd := cn.findChild('/'); cd != nil &amp;&amp; (cd.handlers != nil || cd.anyChild != nil) </span><span class="cov8" title="1">{
                                        res.tsr = true
                                }</span>
                        }
                        <span class="cov8" title="1">continue</span>
                }
        Any:
                // Any node
                <span class="cov8" title="1">if child := cn.anyChild; child != nil </span><span class="cov8" title="1">{
                        // If any node is found, use remaining path for paramValues
                        cn = child
                        (*paramsPointer) = (*paramsPointer)[:(paramIndex + 1)]
                        index := len(cn.pnames) - 1
                        val := search
                        if unescape </span><span class="cov8" title="1">{
                                if v, err := url.QueryUnescape(search); err == nil </span><span class="cov8" title="1">{
                                        val = v
                                }</span>
                        }

                        <span class="cov8" title="1">(*paramsPointer)[index].Value = bytesconv.B2s(append(buf, val...))
                        // update indexes/search in case we need to backtrack when no handler match is found
                        paramIndex++
                        searchIndex += len(search)
                        search = nilString
                        res.handlers = cn.handlers
                        break</span>
                }

                // Let's backtrack to the first possible alternative node of the decision path
                <span class="cov8" title="1">nk, ok := backtrackToNextNodeKind(akind)
                if !ok </span><span class="cov8" title="1">{
                        break</span> // No other possibilities on the decision path
                } else<span class="cov8" title="1"> if nk == pkind </span><span class="cov8" title="1">{
                        goto Param</span>
                } else<span class="cov8" title="1"> if nk == akind </span><span class="cov8" title="1">{
                        goto Any</span>
                } else<span class="cov0" title="0"> {
                        // Not found
                        break</span>
                }
        }

        <span class="cov8" title="1">if cn != nil </span><span class="cov8" title="1">{
                res.fullPath = cn.ppath
                for i, name := range cn.pnames </span><span class="cov8" title="1">{
                        (*paramsPointer)[i].Key = name
                }</span>
        }

        <span class="cov8" title="1">return</span>
}

func (n *node) findChild(l byte) *node <span class="cov8" title="1">{
        for _, c := range n.children </span><span class="cov8" title="1">{
                if c.label == l </span><span class="cov8" title="1">{
                        return c
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (n *node) findChildWithLabel(l byte) *node <span class="cov8" title="1">{
        for _, c := range n.children </span><span class="cov8" title="1">{
                if c.label == l </span><span class="cov8" title="1">{
                        return c
                }</span>
        }
        <span class="cov8" title="1">if l == paramLabel </span><span class="cov8" title="1">{
                return n.paramChild
        }</span>
        <span class="cov8" title="1">if l == anyLabel </span><span class="cov8" title="1">{
                return n.anyChild
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func newNode(t kind, pre string, p *node, child children, mh app.HandlersChain, ppath string, pnames []string, paramChildren, anyChildren *node) *node <span class="cov8" title="1">{
        return &amp;node{
                kind:       t,
                label:      pre[0],
                prefix:     pre,
                parent:     p,
                children:   child,
                ppath:      ppath,
                pnames:     pnames,
                handlers:   mh,
                paramChild: paramChildren,
                anyChild:   anyChildren,
                isLeaf:     child == nil &amp;&amp; paramChildren == nil &amp;&amp; anyChildren == nil,
        }
}</span>

// nodeValue holds return values of (*Node).getValue method
type nodeValue struct {
        handlers app.HandlersChain
        tsr      bool
        fullPath string
}

// Makes a case-insensitive lookup of the given path and tries to find a handler.
// It returns the case-corrected path and a bool indicating whether the lookup
// was successful.
func (n *node) findCaseInsensitivePath(path string, fixTrailingSlash bool) (ciPath []byte, found bool) <span class="cov8" title="1">{
        ciPath = make([]byte, 0, len(path)+1) // preallocate enough memory
        // Match paramKind.
        if n.label == paramLabel </span><span class="cov8" title="1">{
                end := 0
                for end &lt; len(path) &amp;&amp; path[end] != '/' </span><span class="cov8" title="1">{
                        end++
                }</span>
                <span class="cov8" title="1">ciPath = append(ciPath, path[:end]...)
                if end &lt; len(path) </span><span class="cov8" title="1">{
                        if len(n.children) &gt; 0 </span><span class="cov8" title="1">{
                                path = path[end:]

                                goto loop</span>
                        }

                        <span class="cov8" title="1">if fixTrailingSlash &amp;&amp; len(path) == end+1 </span><span class="cov8" title="1">{
                                return ciPath, true
                        }</span>
                        <span class="cov8" title="1">return</span>
                }

                <span class="cov8" title="1">if n.handlers != nil </span><span class="cov8" title="1">{
                        return ciPath, true
                }</span>
                <span class="cov8" title="1">if fixTrailingSlash &amp;&amp; len(n.children) == 1 </span><span class="cov8" title="1">{
                        // No handle found. Check if a handle for this path with(without) a trailing slash exists
                        n = n.children[0]
                        if n.prefix == "/" &amp;&amp; n.handlers != nil </span><span class="cov8" title="1">{
                                return append(ciPath, '/'), true
                        }</span>
                }
                <span class="cov8" title="1">return</span>
        }

        // Match allKind.
        <span class="cov8" title="1">if n.label == anyLabel </span><span class="cov8" title="1">{
                return append(ciPath, path...), true
        }</span>

        // Match static kind.
        <span class="cov8" title="1">if len(path) &gt;= len(n.prefix) &amp;&amp; strings.EqualFold(path[:len(n.prefix)], n.prefix) </span><span class="cov8" title="1">{
                path = path[len(n.prefix):]
                ciPath = append(ciPath, n.prefix...)

                if len(path) == 0 </span><span class="cov8" title="1">{
                        if n.handlers != nil </span><span class="cov8" title="1">{
                                return ciPath, true
                        }</span>
                        // No handle found.
                        // Try to fix the path by adding a trailing slash.
                        <span class="cov8" title="1">if fixTrailingSlash </span><span class="cov8" title="1">{
                                for i := 0; i &lt; len(n.children); i++ </span><span class="cov8" title="1">{
                                        if n.children[i].label == '/' </span><span class="cov8" title="1">{
                                                n = n.children[i]
                                                if (len(n.prefix) == 1 &amp;&amp; n.handlers != nil) ||
                                                        (n.prefix == "*" &amp;&amp; n.children[0].handlers != nil) </span><span class="cov8" title="1">{
                                                        return append(ciPath, '/'), true
                                                }</span>
                                                <span class="cov8" title="1">return</span>
                                        }
                                }
                        }
                        <span class="cov8" title="1">return</span>
                }
        } else<span class="cov8" title="1"> if fixTrailingSlash </span><span class="cov8" title="1">{
                // Nothing found.
                // Try to fix the path by adding / removing a trailing slash.
                if path == "/" </span><span class="cov8" title="1">{
                        return ciPath, true
                }</span>
                <span class="cov8" title="1">if len(path)+1 == len(n.prefix) &amp;&amp; n.prefix[len(path)] == '/' &amp;&amp;
                        strings.EqualFold(path, n.prefix[:len(path)]) &amp;&amp;
                        n.handlers != nil </span><span class="cov8" title="1">{
                        return append(ciPath, n.prefix...), true
                }</span>
        }

<span class="cov8" title="1">loop:
        // First match static kind.
        for _, node := range n.children </span><span class="cov8" title="1">{
                if unicode.ToLower(rune(path[0])) == unicode.ToLower(rune(node.label)) </span><span class="cov8" title="1">{
                        out, found := node.findCaseInsensitivePath(path, fixTrailingSlash)
                        if found </span><span class="cov8" title="1">{
                                return append(ciPath, out...), true
                        }</span>
                }
        }

        <span class="cov8" title="1">if n.paramChild != nil </span><span class="cov8" title="1">{
                out, found := n.paramChild.findCaseInsensitivePath(path, fixTrailingSlash)
                if found </span><span class="cov8" title="1">{
                        return append(ciPath, out...), true
                }</span>
        }

        <span class="cov8" title="1">if n.anyChild != nil </span><span class="cov8" title="1">{
                out, found := n.anyChild.findCaseInsensitivePath(path, fixTrailingSlash)
                if found </span><span class="cov8" title="1">{
                        return append(ciPath, out...), true
                }</span>
        }

        // Nothing found. We can recommend to redirect to the same URL
        // without a trailing slash if a leaf exists for that path
        <span class="cov8" title="1">found = fixTrailingSlash &amp;&amp; path == "/" &amp;&amp; n.handlers != nil
        return</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
